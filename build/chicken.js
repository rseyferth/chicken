(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.Chicken = factory());
}(this, (function () { 'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
  }

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var jquery = createCommonjsModule(function (module) {
  /*!
   * jQuery JavaScript Library v3.3.1
   * https://jquery.com/
   *
   * Includes Sizzle.js
   * https://sizzlejs.com/
   *
   * Copyright JS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2018-01-20T17:24Z
   */
  ( function( global, factory ) {

  	{

  		// For CommonJS and CommonJS-like environments where a proper `window`
  		// is present, execute the factory and get jQuery.
  		// For environments that do not have a `window` with a `document`
  		// (such as Node.js), expose a factory as module.exports.
  		// This accentuates the need for the creation of a real `window`.
  		// e.g. var jQuery = require("jquery")(window);
  		// See ticket #14549 for more info.
  		module.exports = global.document ?
  			factory( global, true ) :
  			function( w ) {
  				if ( !w.document ) {
  					throw new Error( "jQuery requires a window with a document" );
  				}
  				return factory( w );
  			};
  	}

  // Pass this if window is not defined yet
  } )( typeof window !== "undefined" ? window : commonjsGlobal, function( window, noGlobal ) {

  var arr = [];

  var document = window.document;

  var getProto = Object.getPrototypeOf;

  var slice = arr.slice;

  var concat = arr.concat;

  var push = arr.push;

  var indexOf = arr.indexOf;

  var class2type = {};

  var toString = class2type.toString;

  var hasOwn = class2type.hasOwnProperty;

  var fnToString = hasOwn.toString;

  var ObjectFunctionString = fnToString.call( Object );

  var support = {};

  var isFunction = function isFunction( obj ) {

        // Support: Chrome <=57, Firefox <=52
        // In some browsers, typeof returns "function" for HTML <object> elements
        // (i.e., `typeof document.createElement( "object" ) === "function"`).
        // We don't want to classify *any* DOM node as a function.
        return typeof obj === "function" && typeof obj.nodeType !== "number";
    };


  var isWindow = function isWindow( obj ) {
  		return obj != null && obj === obj.window;
  	};




  	var preservedScriptAttributes = {
  		type: true,
  		src: true,
  		noModule: true
  	};

  	function DOMEval( code, doc, node ) {
  		doc = doc || document;

  		var i,
  			script = doc.createElement( "script" );

  		script.text = code;
  		if ( node ) {
  			for ( i in preservedScriptAttributes ) {
  				if ( node[ i ] ) {
  					script[ i ] = node[ i ];
  				}
  			}
  		}
  		doc.head.appendChild( script ).parentNode.removeChild( script );
  	}


  function toType( obj ) {
  	if ( obj == null ) {
  		return obj + "";
  	}

  	// Support: Android <=2.3 only (functionish RegExp)
  	return typeof obj === "object" || typeof obj === "function" ?
  		class2type[ toString.call( obj ) ] || "object" :
  		typeof obj;
  }
  /* global Symbol */
  // Defining this global in .eslintrc.json would create a danger of using the global
  // unguarded in another place, it seems safer to define global only for this module



  var
  	version = "3.3.1",

  	// Define a local copy of jQuery
  	jQuery = function( selector, context ) {

  		// The jQuery object is actually just the init constructor 'enhanced'
  		// Need init if jQuery is called (just allow error to be thrown if not included)
  		return new jQuery.fn.init( selector, context );
  	},

  	// Support: Android <=4.0 only
  	// Make sure we trim BOM and NBSP
  	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

  jQuery.fn = jQuery.prototype = {

  	// The current version of jQuery being used
  	jquery: version,

  	constructor: jQuery,

  	// The default length of a jQuery object is 0
  	length: 0,

  	toArray: function() {
  		return slice.call( this );
  	},

  	// Get the Nth element in the matched element set OR
  	// Get the whole matched element set as a clean array
  	get: function( num ) {

  		// Return all the elements in a clean array
  		if ( num == null ) {
  			return slice.call( this );
  		}

  		// Return just the one element from the set
  		return num < 0 ? this[ num + this.length ] : this[ num ];
  	},

  	// Take an array of elements and push it onto the stack
  	// (returning the new matched element set)
  	pushStack: function( elems ) {

  		// Build a new jQuery matched element set
  		var ret = jQuery.merge( this.constructor(), elems );

  		// Add the old object onto the stack (as a reference)
  		ret.prevObject = this;

  		// Return the newly-formed element set
  		return ret;
  	},

  	// Execute a callback for every element in the matched set.
  	each: function( callback ) {
  		return jQuery.each( this, callback );
  	},

  	map: function( callback ) {
  		return this.pushStack( jQuery.map( this, function( elem, i ) {
  			return callback.call( elem, i, elem );
  		} ) );
  	},

  	slice: function() {
  		return this.pushStack( slice.apply( this, arguments ) );
  	},

  	first: function() {
  		return this.eq( 0 );
  	},

  	last: function() {
  		return this.eq( -1 );
  	},

  	eq: function( i ) {
  		var len = this.length,
  			j = +i + ( i < 0 ? len : 0 );
  		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
  	},

  	end: function() {
  		return this.prevObject || this.constructor();
  	},

  	// For internal use only.
  	// Behaves like an Array's method, not like a jQuery method.
  	push: push,
  	sort: arr.sort,
  	splice: arr.splice
  };

  jQuery.extend = jQuery.fn.extend = function() {
  	var options, name, src, copy, copyIsArray, clone,
  		target = arguments[ 0 ] || {},
  		i = 1,
  		length = arguments.length,
  		deep = false;

  	// Handle a deep copy situation
  	if ( typeof target === "boolean" ) {
  		deep = target;

  		// Skip the boolean and the target
  		target = arguments[ i ] || {};
  		i++;
  	}

  	// Handle case when target is a string or something (possible in deep copy)
  	if ( typeof target !== "object" && !isFunction( target ) ) {
  		target = {};
  	}

  	// Extend jQuery itself if only one argument is passed
  	if ( i === length ) {
  		target = this;
  		i--;
  	}

  	for ( ; i < length; i++ ) {

  		// Only deal with non-null/undefined values
  		if ( ( options = arguments[ i ] ) != null ) {

  			// Extend the base object
  			for ( name in options ) {
  				src = target[ name ];
  				copy = options[ name ];

  				// Prevent never-ending loop
  				if ( target === copy ) {
  					continue;
  				}

  				// Recurse if we're merging plain objects or arrays
  				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
  					( copyIsArray = Array.isArray( copy ) ) ) ) {

  					if ( copyIsArray ) {
  						copyIsArray = false;
  						clone = src && Array.isArray( src ) ? src : [];

  					} else {
  						clone = src && jQuery.isPlainObject( src ) ? src : {};
  					}

  					// Never move original objects, clone them
  					target[ name ] = jQuery.extend( deep, clone, copy );

  				// Don't bring in undefined values
  				} else if ( copy !== undefined ) {
  					target[ name ] = copy;
  				}
  			}
  		}
  	}

  	// Return the modified object
  	return target;
  };

  jQuery.extend( {

  	// Unique for each copy of jQuery on the page
  	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

  	// Assume jQuery is ready without the ready module
  	isReady: true,

  	error: function( msg ) {
  		throw new Error( msg );
  	},

  	noop: function() {},

  	isPlainObject: function( obj ) {
  		var proto, Ctor;

  		// Detect obvious negatives
  		// Use toString instead of jQuery.type to catch host objects
  		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
  			return false;
  		}

  		proto = getProto( obj );

  		// Objects with no prototype (e.g., `Object.create( null )`) are plain
  		if ( !proto ) {
  			return true;
  		}

  		// Objects with prototype are plain iff they were constructed by a global Object function
  		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
  		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
  	},

  	isEmptyObject: function( obj ) {

  		/* eslint-disable no-unused-vars */
  		// See https://github.com/eslint/eslint/issues/6125
  		var name;

  		for ( name in obj ) {
  			return false;
  		}
  		return true;
  	},

  	// Evaluates a script in a global context
  	globalEval: function( code ) {
  		DOMEval( code );
  	},

  	each: function( obj, callback ) {
  		var length, i = 0;

  		if ( isArrayLike( obj ) ) {
  			length = obj.length;
  			for ( ; i < length; i++ ) {
  				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
  					break;
  				}
  			}
  		} else {
  			for ( i in obj ) {
  				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
  					break;
  				}
  			}
  		}

  		return obj;
  	},

  	// Support: Android <=4.0 only
  	trim: function( text ) {
  		return text == null ?
  			"" :
  			( text + "" ).replace( rtrim, "" );
  	},

  	// results is for internal usage only
  	makeArray: function( arr, results ) {
  		var ret = results || [];

  		if ( arr != null ) {
  			if ( isArrayLike( Object( arr ) ) ) {
  				jQuery.merge( ret,
  					typeof arr === "string" ?
  					[ arr ] : arr
  				);
  			} else {
  				push.call( ret, arr );
  			}
  		}

  		return ret;
  	},

  	inArray: function( elem, arr, i ) {
  		return arr == null ? -1 : indexOf.call( arr, elem, i );
  	},

  	// Support: Android <=4.0 only, PhantomJS 1 only
  	// push.apply(_, arraylike) throws on ancient WebKit
  	merge: function( first, second ) {
  		var len = +second.length,
  			j = 0,
  			i = first.length;

  		for ( ; j < len; j++ ) {
  			first[ i++ ] = second[ j ];
  		}

  		first.length = i;

  		return first;
  	},

  	grep: function( elems, callback, invert ) {
  		var callbackInverse,
  			matches = [],
  			i = 0,
  			length = elems.length,
  			callbackExpect = !invert;

  		// Go through the array, only saving the items
  		// that pass the validator function
  		for ( ; i < length; i++ ) {
  			callbackInverse = !callback( elems[ i ], i );
  			if ( callbackInverse !== callbackExpect ) {
  				matches.push( elems[ i ] );
  			}
  		}

  		return matches;
  	},

  	// arg is for internal usage only
  	map: function( elems, callback, arg ) {
  		var length, value,
  			i = 0,
  			ret = [];

  		// Go through the array, translating each of the items to their new values
  		if ( isArrayLike( elems ) ) {
  			length = elems.length;
  			for ( ; i < length; i++ ) {
  				value = callback( elems[ i ], i, arg );

  				if ( value != null ) {
  					ret.push( value );
  				}
  			}

  		// Go through every key on the object,
  		} else {
  			for ( i in elems ) {
  				value = callback( elems[ i ], i, arg );

  				if ( value != null ) {
  					ret.push( value );
  				}
  			}
  		}

  		// Flatten any nested arrays
  		return concat.apply( [], ret );
  	},

  	// A global GUID counter for objects
  	guid: 1,

  	// jQuery.support is not used in Core but other projects attach their
  	// properties to it so it needs to exist.
  	support: support
  } );

  if ( typeof Symbol === "function" ) {
  	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
  }

  // Populate the class2type map
  jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
  function( i, name ) {
  	class2type[ "[object " + name + "]" ] = name.toLowerCase();
  } );

  function isArrayLike( obj ) {

  	// Support: real iOS 8.2 only (not reproducible in simulator)
  	// `in` check used to prevent JIT error (gh-2145)
  	// hasOwn isn't used here due to false negatives
  	// regarding Nodelist length in IE
  	var length = !!obj && "length" in obj && obj.length,
  		type = toType( obj );

  	if ( isFunction( obj ) || isWindow( obj ) ) {
  		return false;
  	}

  	return type === "array" || length === 0 ||
  		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
  }
  var Sizzle =
  /*!
   * Sizzle CSS Selector Engine v2.3.3
   * https://sizzlejs.com/
   *
   * Copyright jQuery Foundation and other contributors
   * Released under the MIT license
   * http://jquery.org/license
   *
   * Date: 2016-08-08
   */
  (function( window ) {

  var i,
  	support,
  	Expr,
  	getText,
  	isXML,
  	tokenize,
  	compile,
  	select,
  	outermostContext,
  	sortInput,
  	hasDuplicate,

  	// Local document vars
  	setDocument,
  	document,
  	docElem,
  	documentIsHTML,
  	rbuggyQSA,
  	rbuggyMatches,
  	matches,
  	contains,

  	// Instance-specific data
  	expando = "sizzle" + 1 * new Date(),
  	preferredDoc = window.document,
  	dirruns = 0,
  	done = 0,
  	classCache = createCache(),
  	tokenCache = createCache(),
  	compilerCache = createCache(),
  	sortOrder = function( a, b ) {
  		if ( a === b ) {
  			hasDuplicate = true;
  		}
  		return 0;
  	},

  	// Instance methods
  	hasOwn = ({}).hasOwnProperty,
  	arr = [],
  	pop = arr.pop,
  	push_native = arr.push,
  	push = arr.push,
  	slice = arr.slice,
  	// Use a stripped-down indexOf as it's faster than native
  	// https://jsperf.com/thor-indexof-vs-for/5
  	indexOf = function( list, elem ) {
  		var i = 0,
  			len = list.length;
  		for ( ; i < len; i++ ) {
  			if ( list[i] === elem ) {
  				return i;
  			}
  		}
  		return -1;
  	},

  	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

  	// Regular expressions

  	// http://www.w3.org/TR/css3-selectors/#whitespace
  	whitespace = "[\\x20\\t\\r\\n\\f]",

  	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
  	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

  	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
  	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
  		// Operator (capture 2)
  		"*([*^$|!~]?=)" + whitespace +
  		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
  		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
  		"*\\]",

  	pseudos = ":(" + identifier + ")(?:\\((" +
  		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
  		// 1. quoted (capture 3; capture 4 or capture 5)
  		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
  		// 2. simple (capture 6)
  		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
  		// 3. anything else (capture 2)
  		".*" +
  		")\\)|)",

  	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
  	rwhitespace = new RegExp( whitespace + "+", "g" ),
  	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

  	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
  	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

  	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

  	rpseudo = new RegExp( pseudos ),
  	ridentifier = new RegExp( "^" + identifier + "$" ),

  	matchExpr = {
  		"ID": new RegExp( "^#(" + identifier + ")" ),
  		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
  		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
  		"ATTR": new RegExp( "^" + attributes ),
  		"PSEUDO": new RegExp( "^" + pseudos ),
  		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
  			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
  			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
  		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
  		// For use in libraries implementing .is()
  		// We use this for POS matching in `select`
  		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
  			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
  	},

  	rinputs = /^(?:input|select|textarea|button)$/i,
  	rheader = /^h\d$/i,

  	rnative = /^[^{]+\{\s*\[native \w/,

  	// Easily-parseable/retrievable ID or TAG or CLASS selectors
  	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

  	rsibling = /[+~]/,

  	// CSS escapes
  	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
  	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
  	funescape = function( _, escaped, escapedWhitespace ) {
  		var high = "0x" + escaped - 0x10000;
  		// NaN means non-codepoint
  		// Support: Firefox<24
  		// Workaround erroneous numeric interpretation of +"0x"
  		return high !== high || escapedWhitespace ?
  			escaped :
  			high < 0 ?
  				// BMP codepoint
  				String.fromCharCode( high + 0x10000 ) :
  				// Supplemental Plane codepoint (surrogate pair)
  				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
  	},

  	// CSS string/identifier serialization
  	// https://drafts.csswg.org/cssom/#common-serializing-idioms
  	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
  	fcssescape = function( ch, asCodePoint ) {
  		if ( asCodePoint ) {

  			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
  			if ( ch === "\0" ) {
  				return "\uFFFD";
  			}

  			// Control characters and (dependent upon position) numbers get escaped as code points
  			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
  		}

  		// Other potentially-special ASCII characters get backslash-escaped
  		return "\\" + ch;
  	},

  	// Used for iframes
  	// See setDocument()
  	// Removing the function wrapper causes a "Permission Denied"
  	// error in IE
  	unloadHandler = function() {
  		setDocument();
  	},

  	disabledAncestor = addCombinator(
  		function( elem ) {
  			return elem.disabled === true && ("form" in elem || "label" in elem);
  		},
  		{ dir: "parentNode", next: "legend" }
  	);

  // Optimize for push.apply( _, NodeList )
  try {
  	push.apply(
  		(arr = slice.call( preferredDoc.childNodes )),
  		preferredDoc.childNodes
  	);
  	// Support: Android<4.0
  	// Detect silently failing push.apply
  	arr[ preferredDoc.childNodes.length ].nodeType;
  } catch ( e ) {
  	push = { apply: arr.length ?

  		// Leverage slice if possible
  		function( target, els ) {
  			push_native.apply( target, slice.call(els) );
  		} :

  		// Support: IE<9
  		// Otherwise append directly
  		function( target, els ) {
  			var j = target.length,
  				i = 0;
  			// Can't trust NodeList.length
  			while ( (target[j++] = els[i++]) ) {}
  			target.length = j - 1;
  		}
  	};
  }

  function Sizzle( selector, context, results, seed ) {
  	var m, i, elem, nid, match, groups, newSelector,
  		newContext = context && context.ownerDocument,

  		// nodeType defaults to 9, since context defaults to document
  		nodeType = context ? context.nodeType : 9;

  	results = results || [];

  	// Return early from calls with invalid selector or context
  	if ( typeof selector !== "string" || !selector ||
  		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

  		return results;
  	}

  	// Try to shortcut find operations (as opposed to filters) in HTML documents
  	if ( !seed ) {

  		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
  			setDocument( context );
  		}
  		context = context || document;

  		if ( documentIsHTML ) {

  			// If the selector is sufficiently simple, try using a "get*By*" DOM method
  			// (excepting DocumentFragment context, where the methods don't exist)
  			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

  				// ID selector
  				if ( (m = match[1]) ) {

  					// Document context
  					if ( nodeType === 9 ) {
  						if ( (elem = context.getElementById( m )) ) {

  							// Support: IE, Opera, Webkit
  							// TODO: identify versions
  							// getElementById can match elements by name instead of ID
  							if ( elem.id === m ) {
  								results.push( elem );
  								return results;
  							}
  						} else {
  							return results;
  						}

  					// Element context
  					} else {

  						// Support: IE, Opera, Webkit
  						// TODO: identify versions
  						// getElementById can match elements by name instead of ID
  						if ( newContext && (elem = newContext.getElementById( m )) &&
  							contains( context, elem ) &&
  							elem.id === m ) {

  							results.push( elem );
  							return results;
  						}
  					}

  				// Type selector
  				} else if ( match[2] ) {
  					push.apply( results, context.getElementsByTagName( selector ) );
  					return results;

  				// Class selector
  				} else if ( (m = match[3]) && support.getElementsByClassName &&
  					context.getElementsByClassName ) {

  					push.apply( results, context.getElementsByClassName( m ) );
  					return results;
  				}
  			}

  			// Take advantage of querySelectorAll
  			if ( support.qsa &&
  				!compilerCache[ selector + " " ] &&
  				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

  				if ( nodeType !== 1 ) {
  					newContext = context;
  					newSelector = selector;

  				// qSA looks outside Element context, which is not what we want
  				// Thanks to Andrew Dupont for this workaround technique
  				// Support: IE <=8
  				// Exclude object elements
  				} else if ( context.nodeName.toLowerCase() !== "object" ) {

  					// Capture the context ID, setting it first if necessary
  					if ( (nid = context.getAttribute( "id" )) ) {
  						nid = nid.replace( rcssescape, fcssescape );
  					} else {
  						context.setAttribute( "id", (nid = expando) );
  					}

  					// Prefix every selector in the list
  					groups = tokenize( selector );
  					i = groups.length;
  					while ( i-- ) {
  						groups[i] = "#" + nid + " " + toSelector( groups[i] );
  					}
  					newSelector = groups.join( "," );

  					// Expand context for sibling selectors
  					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
  						context;
  				}

  				if ( newSelector ) {
  					try {
  						push.apply( results,
  							newContext.querySelectorAll( newSelector )
  						);
  						return results;
  					} catch ( qsaError ) {
  					} finally {
  						if ( nid === expando ) {
  							context.removeAttribute( "id" );
  						}
  					}
  				}
  			}
  		}
  	}

  	// All others
  	return select( selector.replace( rtrim, "$1" ), context, results, seed );
  }

  /**
   * Create key-value caches of limited size
   * @returns {function(string, object)} Returns the Object data after storing it on itself with
   *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
   *	deleting the oldest entry
   */
  function createCache() {
  	var keys = [];

  	function cache( key, value ) {
  		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
  		if ( keys.push( key + " " ) > Expr.cacheLength ) {
  			// Only keep the most recent entries
  			delete cache[ keys.shift() ];
  		}
  		return (cache[ key + " " ] = value);
  	}
  	return cache;
  }

  /**
   * Mark a function for special use by Sizzle
   * @param {Function} fn The function to mark
   */
  function markFunction( fn ) {
  	fn[ expando ] = true;
  	return fn;
  }

  /**
   * Support testing using an element
   * @param {Function} fn Passed the created element and returns a boolean result
   */
  function assert( fn ) {
  	var el = document.createElement("fieldset");

  	try {
  		return !!fn( el );
  	} catch (e) {
  		return false;
  	} finally {
  		// Remove from its parent by default
  		if ( el.parentNode ) {
  			el.parentNode.removeChild( el );
  		}
  		// release memory in IE
  		el = null;
  	}
  }

  /**
   * Adds the same handler for all of the specified attrs
   * @param {String} attrs Pipe-separated list of attributes
   * @param {Function} handler The method that will be applied
   */
  function addHandle( attrs, handler ) {
  	var arr = attrs.split("|"),
  		i = arr.length;

  	while ( i-- ) {
  		Expr.attrHandle[ arr[i] ] = handler;
  	}
  }

  /**
   * Checks document order of two siblings
   * @param {Element} a
   * @param {Element} b
   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
   */
  function siblingCheck( a, b ) {
  	var cur = b && a,
  		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
  			a.sourceIndex - b.sourceIndex;

  	// Use IE sourceIndex if available on both nodes
  	if ( diff ) {
  		return diff;
  	}

  	// Check if b follows a
  	if ( cur ) {
  		while ( (cur = cur.nextSibling) ) {
  			if ( cur === b ) {
  				return -1;
  			}
  		}
  	}

  	return a ? 1 : -1;
  }

  /**
   * Returns a function to use in pseudos for input types
   * @param {String} type
   */
  function createInputPseudo( type ) {
  	return function( elem ) {
  		var name = elem.nodeName.toLowerCase();
  		return name === "input" && elem.type === type;
  	};
  }

  /**
   * Returns a function to use in pseudos for buttons
   * @param {String} type
   */
  function createButtonPseudo( type ) {
  	return function( elem ) {
  		var name = elem.nodeName.toLowerCase();
  		return (name === "input" || name === "button") && elem.type === type;
  	};
  }

  /**
   * Returns a function to use in pseudos for :enabled/:disabled
   * @param {Boolean} disabled true for :disabled; false for :enabled
   */
  function createDisabledPseudo( disabled ) {

  	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
  	return function( elem ) {

  		// Only certain elements can match :enabled or :disabled
  		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
  		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
  		if ( "form" in elem ) {

  			// Check for inherited disabledness on relevant non-disabled elements:
  			// * listed form-associated elements in a disabled fieldset
  			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
  			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
  			// * option elements in a disabled optgroup
  			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
  			// All such elements have a "form" property.
  			if ( elem.parentNode && elem.disabled === false ) {

  				// Option elements defer to a parent optgroup if present
  				if ( "label" in elem ) {
  					if ( "label" in elem.parentNode ) {
  						return elem.parentNode.disabled === disabled;
  					} else {
  						return elem.disabled === disabled;
  					}
  				}

  				// Support: IE 6 - 11
  				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
  				return elem.isDisabled === disabled ||

  					// Where there is no isDisabled, check manually
  					/* jshint -W018 */
  					elem.isDisabled !== !disabled &&
  						disabledAncestor( elem ) === disabled;
  			}

  			return elem.disabled === disabled;

  		// Try to winnow out elements that can't be disabled before trusting the disabled property.
  		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
  		// even exist on them, let alone have a boolean value.
  		} else if ( "label" in elem ) {
  			return elem.disabled === disabled;
  		}

  		// Remaining elements are neither :enabled nor :disabled
  		return false;
  	};
  }

  /**
   * Returns a function to use in pseudos for positionals
   * @param {Function} fn
   */
  function createPositionalPseudo( fn ) {
  	return markFunction(function( argument ) {
  		argument = +argument;
  		return markFunction(function( seed, matches ) {
  			var j,
  				matchIndexes = fn( [], seed.length, argument ),
  				i = matchIndexes.length;

  			// Match elements found at the specified indexes
  			while ( i-- ) {
  				if ( seed[ (j = matchIndexes[i]) ] ) {
  					seed[j] = !(matches[j] = seed[j]);
  				}
  			}
  		});
  	});
  }

  /**
   * Checks a node for validity as a Sizzle context
   * @param {Element|Object=} context
   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
   */
  function testContext( context ) {
  	return context && typeof context.getElementsByTagName !== "undefined" && context;
  }

  // Expose support vars for convenience
  support = Sizzle.support = {};

  /**
   * Detects XML nodes
   * @param {Element|Object} elem An element or a document
   * @returns {Boolean} True iff elem is a non-HTML XML node
   */
  isXML = Sizzle.isXML = function( elem ) {
  	// documentElement is verified for cases where it doesn't yet exist
  	// (such as loading iframes in IE - #4833)
  	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
  	return documentElement ? documentElement.nodeName !== "HTML" : false;
  };

  /**
   * Sets document-related variables once based on the current document
   * @param {Element|Object} [doc] An element or document object to use to set the document
   * @returns {Object} Returns the current document
   */
  setDocument = Sizzle.setDocument = function( node ) {
  	var hasCompare, subWindow,
  		doc = node ? node.ownerDocument || node : preferredDoc;

  	// Return early if doc is invalid or already selected
  	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
  		return document;
  	}

  	// Update global variables
  	document = doc;
  	docElem = document.documentElement;
  	documentIsHTML = !isXML( document );

  	// Support: IE 9-11, Edge
  	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
  	if ( preferredDoc !== document &&
  		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

  		// Support: IE 11, Edge
  		if ( subWindow.addEventListener ) {
  			subWindow.addEventListener( "unload", unloadHandler, false );

  		// Support: IE 9 - 10 only
  		} else if ( subWindow.attachEvent ) {
  			subWindow.attachEvent( "onunload", unloadHandler );
  		}
  	}

  	/* Attributes
  	---------------------------------------------------------------------- */

  	// Support: IE<8
  	// Verify that getAttribute really returns attributes and not properties
  	// (excepting IE8 booleans)
  	support.attributes = assert(function( el ) {
  		el.className = "i";
  		return !el.getAttribute("className");
  	});

  	/* getElement(s)By*
  	---------------------------------------------------------------------- */

  	// Check if getElementsByTagName("*") returns only elements
  	support.getElementsByTagName = assert(function( el ) {
  		el.appendChild( document.createComment("") );
  		return !el.getElementsByTagName("*").length;
  	});

  	// Support: IE<9
  	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

  	// Support: IE<10
  	// Check if getElementById returns elements by name
  	// The broken getElementById methods don't pick up programmatically-set names,
  	// so use a roundabout getElementsByName test
  	support.getById = assert(function( el ) {
  		docElem.appendChild( el ).id = expando;
  		return !document.getElementsByName || !document.getElementsByName( expando ).length;
  	});

  	// ID filter and find
  	if ( support.getById ) {
  		Expr.filter["ID"] = function( id ) {
  			var attrId = id.replace( runescape, funescape );
  			return function( elem ) {
  				return elem.getAttribute("id") === attrId;
  			};
  		};
  		Expr.find["ID"] = function( id, context ) {
  			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
  				var elem = context.getElementById( id );
  				return elem ? [ elem ] : [];
  			}
  		};
  	} else {
  		Expr.filter["ID"] =  function( id ) {
  			var attrId = id.replace( runescape, funescape );
  			return function( elem ) {
  				var node = typeof elem.getAttributeNode !== "undefined" &&
  					elem.getAttributeNode("id");
  				return node && node.value === attrId;
  			};
  		};

  		// Support: IE 6 - 7 only
  		// getElementById is not reliable as a find shortcut
  		Expr.find["ID"] = function( id, context ) {
  			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
  				var node, i, elems,
  					elem = context.getElementById( id );

  				if ( elem ) {

  					// Verify the id attribute
  					node = elem.getAttributeNode("id");
  					if ( node && node.value === id ) {
  						return [ elem ];
  					}

  					// Fall back on getElementsByName
  					elems = context.getElementsByName( id );
  					i = 0;
  					while ( (elem = elems[i++]) ) {
  						node = elem.getAttributeNode("id");
  						if ( node && node.value === id ) {
  							return [ elem ];
  						}
  					}
  				}

  				return [];
  			}
  		};
  	}

  	// Tag
  	Expr.find["TAG"] = support.getElementsByTagName ?
  		function( tag, context ) {
  			if ( typeof context.getElementsByTagName !== "undefined" ) {
  				return context.getElementsByTagName( tag );

  			// DocumentFragment nodes don't have gEBTN
  			} else if ( support.qsa ) {
  				return context.querySelectorAll( tag );
  			}
  		} :

  		function( tag, context ) {
  			var elem,
  				tmp = [],
  				i = 0,
  				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
  				results = context.getElementsByTagName( tag );

  			// Filter out possible comments
  			if ( tag === "*" ) {
  				while ( (elem = results[i++]) ) {
  					if ( elem.nodeType === 1 ) {
  						tmp.push( elem );
  					}
  				}

  				return tmp;
  			}
  			return results;
  		};

  	// Class
  	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
  		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
  			return context.getElementsByClassName( className );
  		}
  	};

  	/* QSA/matchesSelector
  	---------------------------------------------------------------------- */

  	// QSA and matchesSelector support

  	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
  	rbuggyMatches = [];

  	// qSa(:focus) reports false when true (Chrome 21)
  	// We allow this because of a bug in IE8/9 that throws an error
  	// whenever `document.activeElement` is accessed on an iframe
  	// So, we allow :focus to pass through QSA all the time to avoid the IE error
  	// See https://bugs.jquery.com/ticket/13378
  	rbuggyQSA = [];

  	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
  		// Build QSA regex
  		// Regex strategy adopted from Diego Perini
  		assert(function( el ) {
  			// Select is set to empty string on purpose
  			// This is to test IE's treatment of not explicitly
  			// setting a boolean content attribute,
  			// since its presence should be enough
  			// https://bugs.jquery.com/ticket/12359
  			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
  				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
  				"<option selected=''></option></select>";

  			// Support: IE8, Opera 11-12.16
  			// Nothing should be selected when empty strings follow ^= or $= or *=
  			// The test attribute must be unknown in Opera but "safe" for WinRT
  			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
  			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
  				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
  			}

  			// Support: IE8
  			// Boolean attributes and "value" are not treated correctly
  			if ( !el.querySelectorAll("[selected]").length ) {
  				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
  			}

  			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
  			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
  				rbuggyQSA.push("~=");
  			}

  			// Webkit/Opera - :checked should return selected option elements
  			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
  			// IE8 throws error here and will not see later tests
  			if ( !el.querySelectorAll(":checked").length ) {
  				rbuggyQSA.push(":checked");
  			}

  			// Support: Safari 8+, iOS 8+
  			// https://bugs.webkit.org/show_bug.cgi?id=136851
  			// In-page `selector#id sibling-combinator selector` fails
  			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
  				rbuggyQSA.push(".#.+[+~]");
  			}
  		});

  		assert(function( el ) {
  			el.innerHTML = "<a href='' disabled='disabled'></a>" +
  				"<select disabled='disabled'><option/></select>";

  			// Support: Windows 8 Native Apps
  			// The type and name attributes are restricted during .innerHTML assignment
  			var input = document.createElement("input");
  			input.setAttribute( "type", "hidden" );
  			el.appendChild( input ).setAttribute( "name", "D" );

  			// Support: IE8
  			// Enforce case-sensitivity of name attribute
  			if ( el.querySelectorAll("[name=d]").length ) {
  				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
  			}

  			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
  			// IE8 throws error here and will not see later tests
  			if ( el.querySelectorAll(":enabled").length !== 2 ) {
  				rbuggyQSA.push( ":enabled", ":disabled" );
  			}

  			// Support: IE9-11+
  			// IE's :disabled selector does not pick up the children of disabled fieldsets
  			docElem.appendChild( el ).disabled = true;
  			if ( el.querySelectorAll(":disabled").length !== 2 ) {
  				rbuggyQSA.push( ":enabled", ":disabled" );
  			}

  			// Opera 10-11 does not throw on post-comma invalid pseudos
  			el.querySelectorAll("*,:x");
  			rbuggyQSA.push(",.*:");
  		});
  	}

  	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
  		docElem.webkitMatchesSelector ||
  		docElem.mozMatchesSelector ||
  		docElem.oMatchesSelector ||
  		docElem.msMatchesSelector) )) ) {

  		assert(function( el ) {
  			// Check to see if it's possible to do matchesSelector
  			// on a disconnected node (IE 9)
  			support.disconnectedMatch = matches.call( el, "*" );

  			// This should fail with an exception
  			// Gecko does not error, returns false instead
  			matches.call( el, "[s!='']:x" );
  			rbuggyMatches.push( "!=", pseudos );
  		});
  	}

  	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
  	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

  	/* Contains
  	---------------------------------------------------------------------- */
  	hasCompare = rnative.test( docElem.compareDocumentPosition );

  	// Element contains another
  	// Purposefully self-exclusive
  	// As in, an element does not contain itself
  	contains = hasCompare || rnative.test( docElem.contains ) ?
  		function( a, b ) {
  			var adown = a.nodeType === 9 ? a.documentElement : a,
  				bup = b && b.parentNode;
  			return a === bup || !!( bup && bup.nodeType === 1 && (
  				adown.contains ?
  					adown.contains( bup ) :
  					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
  			));
  		} :
  		function( a, b ) {
  			if ( b ) {
  				while ( (b = b.parentNode) ) {
  					if ( b === a ) {
  						return true;
  					}
  				}
  			}
  			return false;
  		};

  	/* Sorting
  	---------------------------------------------------------------------- */

  	// Document order sorting
  	sortOrder = hasCompare ?
  	function( a, b ) {

  		// Flag for duplicate removal
  		if ( a === b ) {
  			hasDuplicate = true;
  			return 0;
  		}

  		// Sort on method existence if only one input has compareDocumentPosition
  		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
  		if ( compare ) {
  			return compare;
  		}

  		// Calculate position if both inputs belong to the same document
  		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
  			a.compareDocumentPosition( b ) :

  			// Otherwise we know they are disconnected
  			1;

  		// Disconnected nodes
  		if ( compare & 1 ||
  			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

  			// Choose the first element that is related to our preferred document
  			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
  				return -1;
  			}
  			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
  				return 1;
  			}

  			// Maintain original order
  			return sortInput ?
  				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
  				0;
  		}

  		return compare & 4 ? -1 : 1;
  	} :
  	function( a, b ) {
  		// Exit early if the nodes are identical
  		if ( a === b ) {
  			hasDuplicate = true;
  			return 0;
  		}

  		var cur,
  			i = 0,
  			aup = a.parentNode,
  			bup = b.parentNode,
  			ap = [ a ],
  			bp = [ b ];

  		// Parentless nodes are either documents or disconnected
  		if ( !aup || !bup ) {
  			return a === document ? -1 :
  				b === document ? 1 :
  				aup ? -1 :
  				bup ? 1 :
  				sortInput ?
  				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
  				0;

  		// If the nodes are siblings, we can do a quick check
  		} else if ( aup === bup ) {
  			return siblingCheck( a, b );
  		}

  		// Otherwise we need full lists of their ancestors for comparison
  		cur = a;
  		while ( (cur = cur.parentNode) ) {
  			ap.unshift( cur );
  		}
  		cur = b;
  		while ( (cur = cur.parentNode) ) {
  			bp.unshift( cur );
  		}

  		// Walk down the tree looking for a discrepancy
  		while ( ap[i] === bp[i] ) {
  			i++;
  		}

  		return i ?
  			// Do a sibling check if the nodes have a common ancestor
  			siblingCheck( ap[i], bp[i] ) :

  			// Otherwise nodes in our document sort first
  			ap[i] === preferredDoc ? -1 :
  			bp[i] === preferredDoc ? 1 :
  			0;
  	};

  	return document;
  };

  Sizzle.matches = function( expr, elements ) {
  	return Sizzle( expr, null, null, elements );
  };

  Sizzle.matchesSelector = function( elem, expr ) {
  	// Set document vars if needed
  	if ( ( elem.ownerDocument || elem ) !== document ) {
  		setDocument( elem );
  	}

  	// Make sure that attribute selectors are quoted
  	expr = expr.replace( rattributeQuotes, "='$1']" );

  	if ( support.matchesSelector && documentIsHTML &&
  		!compilerCache[ expr + " " ] &&
  		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
  		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

  		try {
  			var ret = matches.call( elem, expr );

  			// IE 9's matchesSelector returns false on disconnected nodes
  			if ( ret || support.disconnectedMatch ||
  					// As well, disconnected nodes are said to be in a document
  					// fragment in IE 9
  					elem.document && elem.document.nodeType !== 11 ) {
  				return ret;
  			}
  		} catch (e) {}
  	}

  	return Sizzle( expr, document, null, [ elem ] ).length > 0;
  };

  Sizzle.contains = function( context, elem ) {
  	// Set document vars if needed
  	if ( ( context.ownerDocument || context ) !== document ) {
  		setDocument( context );
  	}
  	return contains( context, elem );
  };

  Sizzle.attr = function( elem, name ) {
  	// Set document vars if needed
  	if ( ( elem.ownerDocument || elem ) !== document ) {
  		setDocument( elem );
  	}

  	var fn = Expr.attrHandle[ name.toLowerCase() ],
  		// Don't get fooled by Object.prototype properties (jQuery #13807)
  		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
  			fn( elem, name, !documentIsHTML ) :
  			undefined;

  	return val !== undefined ?
  		val :
  		support.attributes || !documentIsHTML ?
  			elem.getAttribute( name ) :
  			(val = elem.getAttributeNode(name)) && val.specified ?
  				val.value :
  				null;
  };

  Sizzle.escape = function( sel ) {
  	return (sel + "").replace( rcssescape, fcssescape );
  };

  Sizzle.error = function( msg ) {
  	throw new Error( "Syntax error, unrecognized expression: " + msg );
  };

  /**
   * Document sorting and removing duplicates
   * @param {ArrayLike} results
   */
  Sizzle.uniqueSort = function( results ) {
  	var elem,
  		duplicates = [],
  		j = 0,
  		i = 0;

  	// Unless we *know* we can detect duplicates, assume their presence
  	hasDuplicate = !support.detectDuplicates;
  	sortInput = !support.sortStable && results.slice( 0 );
  	results.sort( sortOrder );

  	if ( hasDuplicate ) {
  		while ( (elem = results[i++]) ) {
  			if ( elem === results[ i ] ) {
  				j = duplicates.push( i );
  			}
  		}
  		while ( j-- ) {
  			results.splice( duplicates[ j ], 1 );
  		}
  	}

  	// Clear input after sorting to release objects
  	// See https://github.com/jquery/sizzle/pull/225
  	sortInput = null;

  	return results;
  };

  /**
   * Utility function for retrieving the text value of an array of DOM nodes
   * @param {Array|Element} elem
   */
  getText = Sizzle.getText = function( elem ) {
  	var node,
  		ret = "",
  		i = 0,
  		nodeType = elem.nodeType;

  	if ( !nodeType ) {
  		// If no nodeType, this is expected to be an array
  		while ( (node = elem[i++]) ) {
  			// Do not traverse comment nodes
  			ret += getText( node );
  		}
  	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
  		// Use textContent for elements
  		// innerText usage removed for consistency of new lines (jQuery #11153)
  		if ( typeof elem.textContent === "string" ) {
  			return elem.textContent;
  		} else {
  			// Traverse its children
  			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
  				ret += getText( elem );
  			}
  		}
  	} else if ( nodeType === 3 || nodeType === 4 ) {
  		return elem.nodeValue;
  	}
  	// Do not include comment or processing instruction nodes

  	return ret;
  };

  Expr = Sizzle.selectors = {

  	// Can be adjusted by the user
  	cacheLength: 50,

  	createPseudo: markFunction,

  	match: matchExpr,

  	attrHandle: {},

  	find: {},

  	relative: {
  		">": { dir: "parentNode", first: true },
  		" ": { dir: "parentNode" },
  		"+": { dir: "previousSibling", first: true },
  		"~": { dir: "previousSibling" }
  	},

  	preFilter: {
  		"ATTR": function( match ) {
  			match[1] = match[1].replace( runescape, funescape );

  			// Move the given value to match[3] whether quoted or unquoted
  			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

  			if ( match[2] === "~=" ) {
  				match[3] = " " + match[3] + " ";
  			}

  			return match.slice( 0, 4 );
  		},

  		"CHILD": function( match ) {
  			/* matches from matchExpr["CHILD"]
  				1 type (only|nth|...)
  				2 what (child|of-type)
  				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
  				4 xn-component of xn+y argument ([+-]?\d*n|)
  				5 sign of xn-component
  				6 x of xn-component
  				7 sign of y-component
  				8 y of y-component
  			*/
  			match[1] = match[1].toLowerCase();

  			if ( match[1].slice( 0, 3 ) === "nth" ) {
  				// nth-* requires argument
  				if ( !match[3] ) {
  					Sizzle.error( match[0] );
  				}

  				// numeric x and y parameters for Expr.filter.CHILD
  				// remember that false/true cast respectively to 0/1
  				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
  				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

  			// other types prohibit arguments
  			} else if ( match[3] ) {
  				Sizzle.error( match[0] );
  			}

  			return match;
  		},

  		"PSEUDO": function( match ) {
  			var excess,
  				unquoted = !match[6] && match[2];

  			if ( matchExpr["CHILD"].test( match[0] ) ) {
  				return null;
  			}

  			// Accept quoted arguments as-is
  			if ( match[3] ) {
  				match[2] = match[4] || match[5] || "";

  			// Strip excess characters from unquoted arguments
  			} else if ( unquoted && rpseudo.test( unquoted ) &&
  				// Get excess from tokenize (recursively)
  				(excess = tokenize( unquoted, true )) &&
  				// advance to the next closing parenthesis
  				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

  				// excess is a negative index
  				match[0] = match[0].slice( 0, excess );
  				match[2] = unquoted.slice( 0, excess );
  			}

  			// Return only captures needed by the pseudo filter method (type and argument)
  			return match.slice( 0, 3 );
  		}
  	},

  	filter: {

  		"TAG": function( nodeNameSelector ) {
  			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
  			return nodeNameSelector === "*" ?
  				function() { return true; } :
  				function( elem ) {
  					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
  				};
  		},

  		"CLASS": function( className ) {
  			var pattern = classCache[ className + " " ];

  			return pattern ||
  				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
  				classCache( className, function( elem ) {
  					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
  				});
  		},

  		"ATTR": function( name, operator, check ) {
  			return function( elem ) {
  				var result = Sizzle.attr( elem, name );

  				if ( result == null ) {
  					return operator === "!=";
  				}
  				if ( !operator ) {
  					return true;
  				}

  				result += "";

  				return operator === "=" ? result === check :
  					operator === "!=" ? result !== check :
  					operator === "^=" ? check && result.indexOf( check ) === 0 :
  					operator === "*=" ? check && result.indexOf( check ) > -1 :
  					operator === "$=" ? check && result.slice( -check.length ) === check :
  					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
  					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
  					false;
  			};
  		},

  		"CHILD": function( type, what, argument, first, last ) {
  			var simple = type.slice( 0, 3 ) !== "nth",
  				forward = type.slice( -4 ) !== "last",
  				ofType = what === "of-type";

  			return first === 1 && last === 0 ?

  				// Shortcut for :nth-*(n)
  				function( elem ) {
  					return !!elem.parentNode;
  				} :

  				function( elem, context, xml ) {
  					var cache, uniqueCache, outerCache, node, nodeIndex, start,
  						dir = simple !== forward ? "nextSibling" : "previousSibling",
  						parent = elem.parentNode,
  						name = ofType && elem.nodeName.toLowerCase(),
  						useCache = !xml && !ofType,
  						diff = false;

  					if ( parent ) {

  						// :(first|last|only)-(child|of-type)
  						if ( simple ) {
  							while ( dir ) {
  								node = elem;
  								while ( (node = node[ dir ]) ) {
  									if ( ofType ?
  										node.nodeName.toLowerCase() === name :
  										node.nodeType === 1 ) {

  										return false;
  									}
  								}
  								// Reverse direction for :only-* (if we haven't yet done so)
  								start = dir = type === "only" && !start && "nextSibling";
  							}
  							return true;
  						}

  						start = [ forward ? parent.firstChild : parent.lastChild ];

  						// non-xml :nth-child(...) stores cache data on `parent`
  						if ( forward && useCache ) {

  							// Seek `elem` from a previously-cached index

  							// ...in a gzip-friendly way
  							node = parent;
  							outerCache = node[ expando ] || (node[ expando ] = {});

  							// Support: IE <9 only
  							// Defend against cloned attroperties (jQuery gh-1709)
  							uniqueCache = outerCache[ node.uniqueID ] ||
  								(outerCache[ node.uniqueID ] = {});

  							cache = uniqueCache[ type ] || [];
  							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
  							diff = nodeIndex && cache[ 2 ];
  							node = nodeIndex && parent.childNodes[ nodeIndex ];

  							while ( (node = ++nodeIndex && node && node[ dir ] ||

  								// Fallback to seeking `elem` from the start
  								(diff = nodeIndex = 0) || start.pop()) ) {

  								// When found, cache indexes on `parent` and break
  								if ( node.nodeType === 1 && ++diff && node === elem ) {
  									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
  									break;
  								}
  							}

  						} else {
  							// Use previously-cached element index if available
  							if ( useCache ) {
  								// ...in a gzip-friendly way
  								node = elem;
  								outerCache = node[ expando ] || (node[ expando ] = {});

  								// Support: IE <9 only
  								// Defend against cloned attroperties (jQuery gh-1709)
  								uniqueCache = outerCache[ node.uniqueID ] ||
  									(outerCache[ node.uniqueID ] = {});

  								cache = uniqueCache[ type ] || [];
  								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
  								diff = nodeIndex;
  							}

  							// xml :nth-child(...)
  							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
  							if ( diff === false ) {
  								// Use the same loop as above to seek `elem` from the start
  								while ( (node = ++nodeIndex && node && node[ dir ] ||
  									(diff = nodeIndex = 0) || start.pop()) ) {

  									if ( ( ofType ?
  										node.nodeName.toLowerCase() === name :
  										node.nodeType === 1 ) &&
  										++diff ) {

  										// Cache the index of each encountered element
  										if ( useCache ) {
  											outerCache = node[ expando ] || (node[ expando ] = {});

  											// Support: IE <9 only
  											// Defend against cloned attroperties (jQuery gh-1709)
  											uniqueCache = outerCache[ node.uniqueID ] ||
  												(outerCache[ node.uniqueID ] = {});

  											uniqueCache[ type ] = [ dirruns, diff ];
  										}

  										if ( node === elem ) {
  											break;
  										}
  									}
  								}
  							}
  						}

  						// Incorporate the offset, then check against cycle size
  						diff -= last;
  						return diff === first || ( diff % first === 0 && diff / first >= 0 );
  					}
  				};
  		},

  		"PSEUDO": function( pseudo, argument ) {
  			// pseudo-class names are case-insensitive
  			// http://www.w3.org/TR/selectors/#pseudo-classes
  			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
  			// Remember that setFilters inherits from pseudos
  			var args,
  				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
  					Sizzle.error( "unsupported pseudo: " + pseudo );

  			// The user may use createPseudo to indicate that
  			// arguments are needed to create the filter function
  			// just as Sizzle does
  			if ( fn[ expando ] ) {
  				return fn( argument );
  			}

  			// But maintain support for old signatures
  			if ( fn.length > 1 ) {
  				args = [ pseudo, pseudo, "", argument ];
  				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
  					markFunction(function( seed, matches ) {
  						var idx,
  							matched = fn( seed, argument ),
  							i = matched.length;
  						while ( i-- ) {
  							idx = indexOf( seed, matched[i] );
  							seed[ idx ] = !( matches[ idx ] = matched[i] );
  						}
  					}) :
  					function( elem ) {
  						return fn( elem, 0, args );
  					};
  			}

  			return fn;
  		}
  	},

  	pseudos: {
  		// Potentially complex pseudos
  		"not": markFunction(function( selector ) {
  			// Trim the selector passed to compile
  			// to avoid treating leading and trailing
  			// spaces as combinators
  			var input = [],
  				results = [],
  				matcher = compile( selector.replace( rtrim, "$1" ) );

  			return matcher[ expando ] ?
  				markFunction(function( seed, matches, context, xml ) {
  					var elem,
  						unmatched = matcher( seed, null, xml, [] ),
  						i = seed.length;

  					// Match elements unmatched by `matcher`
  					while ( i-- ) {
  						if ( (elem = unmatched[i]) ) {
  							seed[i] = !(matches[i] = elem);
  						}
  					}
  				}) :
  				function( elem, context, xml ) {
  					input[0] = elem;
  					matcher( input, null, xml, results );
  					// Don't keep the element (issue #299)
  					input[0] = null;
  					return !results.pop();
  				};
  		}),

  		"has": markFunction(function( selector ) {
  			return function( elem ) {
  				return Sizzle( selector, elem ).length > 0;
  			};
  		}),

  		"contains": markFunction(function( text ) {
  			text = text.replace( runescape, funescape );
  			return function( elem ) {
  				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
  			};
  		}),

  		// "Whether an element is represented by a :lang() selector
  		// is based solely on the element's language value
  		// being equal to the identifier C,
  		// or beginning with the identifier C immediately followed by "-".
  		// The matching of C against the element's language value is performed case-insensitively.
  		// The identifier C does not have to be a valid language name."
  		// http://www.w3.org/TR/selectors/#lang-pseudo
  		"lang": markFunction( function( lang ) {
  			// lang value must be a valid identifier
  			if ( !ridentifier.test(lang || "") ) {
  				Sizzle.error( "unsupported lang: " + lang );
  			}
  			lang = lang.replace( runescape, funescape ).toLowerCase();
  			return function( elem ) {
  				var elemLang;
  				do {
  					if ( (elemLang = documentIsHTML ?
  						elem.lang :
  						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

  						elemLang = elemLang.toLowerCase();
  						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
  					}
  				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
  				return false;
  			};
  		}),

  		// Miscellaneous
  		"target": function( elem ) {
  			var hash = window.location && window.location.hash;
  			return hash && hash.slice( 1 ) === elem.id;
  		},

  		"root": function( elem ) {
  			return elem === docElem;
  		},

  		"focus": function( elem ) {
  			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
  		},

  		// Boolean properties
  		"enabled": createDisabledPseudo( false ),
  		"disabled": createDisabledPseudo( true ),

  		"checked": function( elem ) {
  			// In CSS3, :checked should return both checked and selected elements
  			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
  			var nodeName = elem.nodeName.toLowerCase();
  			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
  		},

  		"selected": function( elem ) {
  			// Accessing this property makes selected-by-default
  			// options in Safari work properly
  			if ( elem.parentNode ) {
  				elem.parentNode.selectedIndex;
  			}

  			return elem.selected === true;
  		},

  		// Contents
  		"empty": function( elem ) {
  			// http://www.w3.org/TR/selectors/#empty-pseudo
  			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
  			//   but not by others (comment: 8; processing instruction: 7; etc.)
  			// nodeType < 6 works because attributes (2) do not appear as children
  			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
  				if ( elem.nodeType < 6 ) {
  					return false;
  				}
  			}
  			return true;
  		},

  		"parent": function( elem ) {
  			return !Expr.pseudos["empty"]( elem );
  		},

  		// Element/input types
  		"header": function( elem ) {
  			return rheader.test( elem.nodeName );
  		},

  		"input": function( elem ) {
  			return rinputs.test( elem.nodeName );
  		},

  		"button": function( elem ) {
  			var name = elem.nodeName.toLowerCase();
  			return name === "input" && elem.type === "button" || name === "button";
  		},

  		"text": function( elem ) {
  			var attr;
  			return elem.nodeName.toLowerCase() === "input" &&
  				elem.type === "text" &&

  				// Support: IE<8
  				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
  				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
  		},

  		// Position-in-collection
  		"first": createPositionalPseudo(function() {
  			return [ 0 ];
  		}),

  		"last": createPositionalPseudo(function( matchIndexes, length ) {
  			return [ length - 1 ];
  		}),

  		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
  			return [ argument < 0 ? argument + length : argument ];
  		}),

  		"even": createPositionalPseudo(function( matchIndexes, length ) {
  			var i = 0;
  			for ( ; i < length; i += 2 ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		}),

  		"odd": createPositionalPseudo(function( matchIndexes, length ) {
  			var i = 1;
  			for ( ; i < length; i += 2 ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		}),

  		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
  			var i = argument < 0 ? argument + length : argument;
  			for ( ; --i >= 0; ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		}),

  		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
  			var i = argument < 0 ? argument + length : argument;
  			for ( ; ++i < length; ) {
  				matchIndexes.push( i );
  			}
  			return matchIndexes;
  		})
  	}
  };

  Expr.pseudos["nth"] = Expr.pseudos["eq"];

  // Add button/input type pseudos
  for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
  	Expr.pseudos[ i ] = createInputPseudo( i );
  }
  for ( i in { submit: true, reset: true } ) {
  	Expr.pseudos[ i ] = createButtonPseudo( i );
  }

  // Easy API for creating new setFilters
  function setFilters() {}
  setFilters.prototype = Expr.filters = Expr.pseudos;
  Expr.setFilters = new setFilters();

  tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
  	var matched, match, tokens, type,
  		soFar, groups, preFilters,
  		cached = tokenCache[ selector + " " ];

  	if ( cached ) {
  		return parseOnly ? 0 : cached.slice( 0 );
  	}

  	soFar = selector;
  	groups = [];
  	preFilters = Expr.preFilter;

  	while ( soFar ) {

  		// Comma and first run
  		if ( !matched || (match = rcomma.exec( soFar )) ) {
  			if ( match ) {
  				// Don't consume trailing commas as valid
  				soFar = soFar.slice( match[0].length ) || soFar;
  			}
  			groups.push( (tokens = []) );
  		}

  		matched = false;

  		// Combinators
  		if ( (match = rcombinators.exec( soFar )) ) {
  			matched = match.shift();
  			tokens.push({
  				value: matched,
  				// Cast descendant combinators to space
  				type: match[0].replace( rtrim, " " )
  			});
  			soFar = soFar.slice( matched.length );
  		}

  		// Filters
  		for ( type in Expr.filter ) {
  			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
  				(match = preFilters[ type ]( match ))) ) {
  				matched = match.shift();
  				tokens.push({
  					value: matched,
  					type: type,
  					matches: match
  				});
  				soFar = soFar.slice( matched.length );
  			}
  		}

  		if ( !matched ) {
  			break;
  		}
  	}

  	// Return the length of the invalid excess
  	// if we're just parsing
  	// Otherwise, throw an error or return tokens
  	return parseOnly ?
  		soFar.length :
  		soFar ?
  			Sizzle.error( selector ) :
  			// Cache the tokens
  			tokenCache( selector, groups ).slice( 0 );
  };

  function toSelector( tokens ) {
  	var i = 0,
  		len = tokens.length,
  		selector = "";
  	for ( ; i < len; i++ ) {
  		selector += tokens[i].value;
  	}
  	return selector;
  }

  function addCombinator( matcher, combinator, base ) {
  	var dir = combinator.dir,
  		skip = combinator.next,
  		key = skip || dir,
  		checkNonElements = base && key === "parentNode",
  		doneName = done++;

  	return combinator.first ?
  		// Check against closest ancestor/preceding element
  		function( elem, context, xml ) {
  			while ( (elem = elem[ dir ]) ) {
  				if ( elem.nodeType === 1 || checkNonElements ) {
  					return matcher( elem, context, xml );
  				}
  			}
  			return false;
  		} :

  		// Check against all ancestor/preceding elements
  		function( elem, context, xml ) {
  			var oldCache, uniqueCache, outerCache,
  				newCache = [ dirruns, doneName ];

  			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
  			if ( xml ) {
  				while ( (elem = elem[ dir ]) ) {
  					if ( elem.nodeType === 1 || checkNonElements ) {
  						if ( matcher( elem, context, xml ) ) {
  							return true;
  						}
  					}
  				}
  			} else {
  				while ( (elem = elem[ dir ]) ) {
  					if ( elem.nodeType === 1 || checkNonElements ) {
  						outerCache = elem[ expando ] || (elem[ expando ] = {});

  						// Support: IE <9 only
  						// Defend against cloned attroperties (jQuery gh-1709)
  						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

  						if ( skip && skip === elem.nodeName.toLowerCase() ) {
  							elem = elem[ dir ] || elem;
  						} else if ( (oldCache = uniqueCache[ key ]) &&
  							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

  							// Assign to newCache so results back-propagate to previous elements
  							return (newCache[ 2 ] = oldCache[ 2 ]);
  						} else {
  							// Reuse newcache so results back-propagate to previous elements
  							uniqueCache[ key ] = newCache;

  							// A match means we're done; a fail means we have to keep checking
  							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
  								return true;
  							}
  						}
  					}
  				}
  			}
  			return false;
  		};
  }

  function elementMatcher( matchers ) {
  	return matchers.length > 1 ?
  		function( elem, context, xml ) {
  			var i = matchers.length;
  			while ( i-- ) {
  				if ( !matchers[i]( elem, context, xml ) ) {
  					return false;
  				}
  			}
  			return true;
  		} :
  		matchers[0];
  }

  function multipleContexts( selector, contexts, results ) {
  	var i = 0,
  		len = contexts.length;
  	for ( ; i < len; i++ ) {
  		Sizzle( selector, contexts[i], results );
  	}
  	return results;
  }

  function condense( unmatched, map, filter, context, xml ) {
  	var elem,
  		newUnmatched = [],
  		i = 0,
  		len = unmatched.length,
  		mapped = map != null;

  	for ( ; i < len; i++ ) {
  		if ( (elem = unmatched[i]) ) {
  			if ( !filter || filter( elem, context, xml ) ) {
  				newUnmatched.push( elem );
  				if ( mapped ) {
  					map.push( i );
  				}
  			}
  		}
  	}

  	return newUnmatched;
  }

  function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
  	if ( postFilter && !postFilter[ expando ] ) {
  		postFilter = setMatcher( postFilter );
  	}
  	if ( postFinder && !postFinder[ expando ] ) {
  		postFinder = setMatcher( postFinder, postSelector );
  	}
  	return markFunction(function( seed, results, context, xml ) {
  		var temp, i, elem,
  			preMap = [],
  			postMap = [],
  			preexisting = results.length,

  			// Get initial elements from seed or context
  			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

  			// Prefilter to get matcher input, preserving a map for seed-results synchronization
  			matcherIn = preFilter && ( seed || !selector ) ?
  				condense( elems, preMap, preFilter, context, xml ) :
  				elems,

  			matcherOut = matcher ?
  				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
  				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

  					// ...intermediate processing is necessary
  					[] :

  					// ...otherwise use results directly
  					results :
  				matcherIn;

  		// Find primary matches
  		if ( matcher ) {
  			matcher( matcherIn, matcherOut, context, xml );
  		}

  		// Apply postFilter
  		if ( postFilter ) {
  			temp = condense( matcherOut, postMap );
  			postFilter( temp, [], context, xml );

  			// Un-match failing elements by moving them back to matcherIn
  			i = temp.length;
  			while ( i-- ) {
  				if ( (elem = temp[i]) ) {
  					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
  				}
  			}
  		}

  		if ( seed ) {
  			if ( postFinder || preFilter ) {
  				if ( postFinder ) {
  					// Get the final matcherOut by condensing this intermediate into postFinder contexts
  					temp = [];
  					i = matcherOut.length;
  					while ( i-- ) {
  						if ( (elem = matcherOut[i]) ) {
  							// Restore matcherIn since elem is not yet a final match
  							temp.push( (matcherIn[i] = elem) );
  						}
  					}
  					postFinder( null, (matcherOut = []), temp, xml );
  				}

  				// Move matched elements from seed to results to keep them synchronized
  				i = matcherOut.length;
  				while ( i-- ) {
  					if ( (elem = matcherOut[i]) &&
  						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

  						seed[temp] = !(results[temp] = elem);
  					}
  				}
  			}

  		// Add elements to results, through postFinder if defined
  		} else {
  			matcherOut = condense(
  				matcherOut === results ?
  					matcherOut.splice( preexisting, matcherOut.length ) :
  					matcherOut
  			);
  			if ( postFinder ) {
  				postFinder( null, results, matcherOut, xml );
  			} else {
  				push.apply( results, matcherOut );
  			}
  		}
  	});
  }

  function matcherFromTokens( tokens ) {
  	var checkContext, matcher, j,
  		len = tokens.length,
  		leadingRelative = Expr.relative[ tokens[0].type ],
  		implicitRelative = leadingRelative || Expr.relative[" "],
  		i = leadingRelative ? 1 : 0,

  		// The foundational matcher ensures that elements are reachable from top-level context(s)
  		matchContext = addCombinator( function( elem ) {
  			return elem === checkContext;
  		}, implicitRelative, true ),
  		matchAnyContext = addCombinator( function( elem ) {
  			return indexOf( checkContext, elem ) > -1;
  		}, implicitRelative, true ),
  		matchers = [ function( elem, context, xml ) {
  			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
  				(checkContext = context).nodeType ?
  					matchContext( elem, context, xml ) :
  					matchAnyContext( elem, context, xml ) );
  			// Avoid hanging onto element (issue #299)
  			checkContext = null;
  			return ret;
  		} ];

  	for ( ; i < len; i++ ) {
  		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
  			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
  		} else {
  			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

  			// Return special upon seeing a positional matcher
  			if ( matcher[ expando ] ) {
  				// Find the next relative operator (if any) for proper handling
  				j = ++i;
  				for ( ; j < len; j++ ) {
  					if ( Expr.relative[ tokens[j].type ] ) {
  						break;
  					}
  				}
  				return setMatcher(
  					i > 1 && elementMatcher( matchers ),
  					i > 1 && toSelector(
  						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
  						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
  					).replace( rtrim, "$1" ),
  					matcher,
  					i < j && matcherFromTokens( tokens.slice( i, j ) ),
  					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
  					j < len && toSelector( tokens )
  				);
  			}
  			matchers.push( matcher );
  		}
  	}

  	return elementMatcher( matchers );
  }

  function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
  	var bySet = setMatchers.length > 0,
  		byElement = elementMatchers.length > 0,
  		superMatcher = function( seed, context, xml, results, outermost ) {
  			var elem, j, matcher,
  				matchedCount = 0,
  				i = "0",
  				unmatched = seed && [],
  				setMatched = [],
  				contextBackup = outermostContext,
  				// We must always have either seed elements or outermost context
  				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
  				// Use integer dirruns iff this is the outermost matcher
  				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
  				len = elems.length;

  			if ( outermost ) {
  				outermostContext = context === document || context || outermost;
  			}

  			// Add elements passing elementMatchers directly to results
  			// Support: IE<9, Safari
  			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
  			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
  				if ( byElement && elem ) {
  					j = 0;
  					if ( !context && elem.ownerDocument !== document ) {
  						setDocument( elem );
  						xml = !documentIsHTML;
  					}
  					while ( (matcher = elementMatchers[j++]) ) {
  						if ( matcher( elem, context || document, xml) ) {
  							results.push( elem );
  							break;
  						}
  					}
  					if ( outermost ) {
  						dirruns = dirrunsUnique;
  					}
  				}

  				// Track unmatched elements for set filters
  				if ( bySet ) {
  					// They will have gone through all possible matchers
  					if ( (elem = !matcher && elem) ) {
  						matchedCount--;
  					}

  					// Lengthen the array for every element, matched or not
  					if ( seed ) {
  						unmatched.push( elem );
  					}
  				}
  			}

  			// `i` is now the count of elements visited above, and adding it to `matchedCount`
  			// makes the latter nonnegative.
  			matchedCount += i;

  			// Apply set filters to unmatched elements
  			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
  			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
  			// no element matchers and no seed.
  			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
  			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
  			// numerically zero.
  			if ( bySet && i !== matchedCount ) {
  				j = 0;
  				while ( (matcher = setMatchers[j++]) ) {
  					matcher( unmatched, setMatched, context, xml );
  				}

  				if ( seed ) {
  					// Reintegrate element matches to eliminate the need for sorting
  					if ( matchedCount > 0 ) {
  						while ( i-- ) {
  							if ( !(unmatched[i] || setMatched[i]) ) {
  								setMatched[i] = pop.call( results );
  							}
  						}
  					}

  					// Discard index placeholder values to get only actual matches
  					setMatched = condense( setMatched );
  				}

  				// Add matches to results
  				push.apply( results, setMatched );

  				// Seedless set matches succeeding multiple successful matchers stipulate sorting
  				if ( outermost && !seed && setMatched.length > 0 &&
  					( matchedCount + setMatchers.length ) > 1 ) {

  					Sizzle.uniqueSort( results );
  				}
  			}

  			// Override manipulation of globals by nested matchers
  			if ( outermost ) {
  				dirruns = dirrunsUnique;
  				outermostContext = contextBackup;
  			}

  			return unmatched;
  		};

  	return bySet ?
  		markFunction( superMatcher ) :
  		superMatcher;
  }

  compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
  	var i,
  		setMatchers = [],
  		elementMatchers = [],
  		cached = compilerCache[ selector + " " ];

  	if ( !cached ) {
  		// Generate a function of recursive functions that can be used to check each element
  		if ( !match ) {
  			match = tokenize( selector );
  		}
  		i = match.length;
  		while ( i-- ) {
  			cached = matcherFromTokens( match[i] );
  			if ( cached[ expando ] ) {
  				setMatchers.push( cached );
  			} else {
  				elementMatchers.push( cached );
  			}
  		}

  		// Cache the compiled function
  		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

  		// Save selector and tokenization
  		cached.selector = selector;
  	}
  	return cached;
  };

  /**
   * A low-level selection function that works with Sizzle's compiled
   *  selector functions
   * @param {String|Function} selector A selector or a pre-compiled
   *  selector function built with Sizzle.compile
   * @param {Element} context
   * @param {Array} [results]
   * @param {Array} [seed] A set of elements to match against
   */
  select = Sizzle.select = function( selector, context, results, seed ) {
  	var i, tokens, token, type, find,
  		compiled = typeof selector === "function" && selector,
  		match = !seed && tokenize( (selector = compiled.selector || selector) );

  	results = results || [];

  	// Try to minimize operations if there is only one selector in the list and no seed
  	// (the latter of which guarantees us context)
  	if ( match.length === 1 ) {

  		// Reduce context if the leading compound selector is an ID
  		tokens = match[0] = match[0].slice( 0 );
  		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
  				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

  			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
  			if ( !context ) {
  				return results;

  			// Precompiled matchers will still verify ancestry, so step up a level
  			} else if ( compiled ) {
  				context = context.parentNode;
  			}

  			selector = selector.slice( tokens.shift().value.length );
  		}

  		// Fetch a seed set for right-to-left matching
  		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
  		while ( i-- ) {
  			token = tokens[i];

  			// Abort if we hit a combinator
  			if ( Expr.relative[ (type = token.type) ] ) {
  				break;
  			}
  			if ( (find = Expr.find[ type ]) ) {
  				// Search, expanding context for leading sibling combinators
  				if ( (seed = find(
  					token.matches[0].replace( runescape, funescape ),
  					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
  				)) ) {

  					// If seed is empty or no tokens remain, we can return early
  					tokens.splice( i, 1 );
  					selector = seed.length && toSelector( tokens );
  					if ( !selector ) {
  						push.apply( results, seed );
  						return results;
  					}

  					break;
  				}
  			}
  		}
  	}

  	// Compile and execute a filtering function if one is not provided
  	// Provide `match` to avoid retokenization if we modified the selector above
  	( compiled || compile( selector, match ) )(
  		seed,
  		context,
  		!documentIsHTML,
  		results,
  		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
  	);
  	return results;
  };

  // One-time assignments

  // Sort stability
  support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

  // Support: Chrome 14-35+
  // Always assume duplicates if they aren't passed to the comparison function
  support.detectDuplicates = !!hasDuplicate;

  // Initialize against the default document
  setDocument();

  // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
  // Detached nodes confoundingly follow *each other*
  support.sortDetached = assert(function( el ) {
  	// Should return 1, but returns 4 (following)
  	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
  });

  // Support: IE<8
  // Prevent attribute/property "interpolation"
  // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
  if ( !assert(function( el ) {
  	el.innerHTML = "<a href='#'></a>";
  	return el.firstChild.getAttribute("href") === "#" ;
  }) ) {
  	addHandle( "type|href|height|width", function( elem, name, isXML ) {
  		if ( !isXML ) {
  			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
  		}
  	});
  }

  // Support: IE<9
  // Use defaultValue in place of getAttribute("value")
  if ( !support.attributes || !assert(function( el ) {
  	el.innerHTML = "<input/>";
  	el.firstChild.setAttribute( "value", "" );
  	return el.firstChild.getAttribute( "value" ) === "";
  }) ) {
  	addHandle( "value", function( elem, name, isXML ) {
  		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
  			return elem.defaultValue;
  		}
  	});
  }

  // Support: IE<9
  // Use getAttributeNode to fetch booleans when getAttribute lies
  if ( !assert(function( el ) {
  	return el.getAttribute("disabled") == null;
  }) ) {
  	addHandle( booleans, function( elem, name, isXML ) {
  		var val;
  		if ( !isXML ) {
  			return elem[ name ] === true ? name.toLowerCase() :
  					(val = elem.getAttributeNode( name )) && val.specified ?
  					val.value :
  				null;
  		}
  	});
  }

  return Sizzle;

  })( window );



  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;

  // Deprecated
  jQuery.expr[ ":" ] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  jQuery.escapeSelector = Sizzle.escape;




  var dir = function( elem, dir, until ) {
  	var matched = [],
  		truncate = until !== undefined;

  	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
  		if ( elem.nodeType === 1 ) {
  			if ( truncate && jQuery( elem ).is( until ) ) {
  				break;
  			}
  			matched.push( elem );
  		}
  	}
  	return matched;
  };


  var siblings = function( n, elem ) {
  	var matched = [];

  	for ( ; n; n = n.nextSibling ) {
  		if ( n.nodeType === 1 && n !== elem ) {
  			matched.push( n );
  		}
  	}

  	return matched;
  };


  var rneedsContext = jQuery.expr.match.needsContext;



  function nodeName( elem, name ) {

    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

  }var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



  // Implement the identical functionality for filter and not
  function winnow( elements, qualifier, not ) {
  	if ( isFunction( qualifier ) ) {
  		return jQuery.grep( elements, function( elem, i ) {
  			return !!qualifier.call( elem, i, elem ) !== not;
  		} );
  	}

  	// Single element
  	if ( qualifier.nodeType ) {
  		return jQuery.grep( elements, function( elem ) {
  			return ( elem === qualifier ) !== not;
  		} );
  	}

  	// Arraylike of elements (jQuery, arguments, Array)
  	if ( typeof qualifier !== "string" ) {
  		return jQuery.grep( elements, function( elem ) {
  			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
  		} );
  	}

  	// Filtered directly for both simple and complex selectors
  	return jQuery.filter( qualifier, elements, not );
  }

  jQuery.filter = function( expr, elems, not ) {
  	var elem = elems[ 0 ];

  	if ( not ) {
  		expr = ":not(" + expr + ")";
  	}

  	if ( elems.length === 1 && elem.nodeType === 1 ) {
  		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
  	}

  	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
  		return elem.nodeType === 1;
  	} ) );
  };

  jQuery.fn.extend( {
  	find: function( selector ) {
  		var i, ret,
  			len = this.length,
  			self = this;

  		if ( typeof selector !== "string" ) {
  			return this.pushStack( jQuery( selector ).filter( function() {
  				for ( i = 0; i < len; i++ ) {
  					if ( jQuery.contains( self[ i ], this ) ) {
  						return true;
  					}
  				}
  			} ) );
  		}

  		ret = this.pushStack( [] );

  		for ( i = 0; i < len; i++ ) {
  			jQuery.find( selector, self[ i ], ret );
  		}

  		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
  	},
  	filter: function( selector ) {
  		return this.pushStack( winnow( this, selector || [], false ) );
  	},
  	not: function( selector ) {
  		return this.pushStack( winnow( this, selector || [], true ) );
  	},
  	is: function( selector ) {
  		return !!winnow(
  			this,

  			// If this is a positional/relative selector, check membership in the returned set
  			// so $("p:first").is("p:last") won't return true for a doc with two "p".
  			typeof selector === "string" && rneedsContext.test( selector ) ?
  				jQuery( selector ) :
  				selector || [],
  			false
  		).length;
  	}
  } );


  // Initialize a jQuery object


  // A central reference to the root jQuery(document)
  var rootjQuery,

  	// A simple way to check for HTML strings
  	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  	// Strict HTML recognition (#11290: must start with <)
  	// Shortcut simple #id case for speed
  	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

  	init = jQuery.fn.init = function( selector, context, root ) {
  		var match, elem;

  		// HANDLE: $(""), $(null), $(undefined), $(false)
  		if ( !selector ) {
  			return this;
  		}

  		// Method init() accepts an alternate rootjQuery
  		// so migrate can support jQuery.sub (gh-2101)
  		root = root || rootjQuery;

  		// Handle HTML strings
  		if ( typeof selector === "string" ) {
  			if ( selector[ 0 ] === "<" &&
  				selector[ selector.length - 1 ] === ">" &&
  				selector.length >= 3 ) {

  				// Assume that strings that start and end with <> are HTML and skip the regex check
  				match = [ null, selector, null ];

  			} else {
  				match = rquickExpr.exec( selector );
  			}

  			// Match html or make sure no context is specified for #id
  			if ( match && ( match[ 1 ] || !context ) ) {

  				// HANDLE: $(html) -> $(array)
  				if ( match[ 1 ] ) {
  					context = context instanceof jQuery ? context[ 0 ] : context;

  					// Option to run scripts is true for back-compat
  					// Intentionally let the error be thrown if parseHTML is not present
  					jQuery.merge( this, jQuery.parseHTML(
  						match[ 1 ],
  						context && context.nodeType ? context.ownerDocument || context : document,
  						true
  					) );

  					// HANDLE: $(html, props)
  					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
  						for ( match in context ) {

  							// Properties of context are called as methods if possible
  							if ( isFunction( this[ match ] ) ) {
  								this[ match ]( context[ match ] );

  							// ...and otherwise set as attributes
  							} else {
  								this.attr( match, context[ match ] );
  							}
  						}
  					}

  					return this;

  				// HANDLE: $(#id)
  				} else {
  					elem = document.getElementById( match[ 2 ] );

  					if ( elem ) {

  						// Inject the element directly into the jQuery object
  						this[ 0 ] = elem;
  						this.length = 1;
  					}
  					return this;
  				}

  			// HANDLE: $(expr, $(...))
  			} else if ( !context || context.jquery ) {
  				return ( context || root ).find( selector );

  			// HANDLE: $(expr, context)
  			// (which is just equivalent to: $(context).find(expr)
  			} else {
  				return this.constructor( context ).find( selector );
  			}

  		// HANDLE: $(DOMElement)
  		} else if ( selector.nodeType ) {
  			this[ 0 ] = selector;
  			this.length = 1;
  			return this;

  		// HANDLE: $(function)
  		// Shortcut for document ready
  		} else if ( isFunction( selector ) ) {
  			return root.ready !== undefined ?
  				root.ready( selector ) :

  				// Execute immediately if ready is not present
  				selector( jQuery );
  		}

  		return jQuery.makeArray( selector, this );
  	};

  // Give the init function the jQuery prototype for later instantiation
  init.prototype = jQuery.fn;

  // Initialize central reference
  rootjQuery = jQuery( document );


  var rparentsprev = /^(?:parents|prev(?:Until|All))/,

  	// Methods guaranteed to produce a unique set when starting from a unique set
  	guaranteedUnique = {
  		children: true,
  		contents: true,
  		next: true,
  		prev: true
  	};

  jQuery.fn.extend( {
  	has: function( target ) {
  		var targets = jQuery( target, this ),
  			l = targets.length;

  		return this.filter( function() {
  			var i = 0;
  			for ( ; i < l; i++ ) {
  				if ( jQuery.contains( this, targets[ i ] ) ) {
  					return true;
  				}
  			}
  		} );
  	},

  	closest: function( selectors, context ) {
  		var cur,
  			i = 0,
  			l = this.length,
  			matched = [],
  			targets = typeof selectors !== "string" && jQuery( selectors );

  		// Positional selectors never match, since there's no _selection_ context
  		if ( !rneedsContext.test( selectors ) ) {
  			for ( ; i < l; i++ ) {
  				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

  					// Always skip document fragments
  					if ( cur.nodeType < 11 && ( targets ?
  						targets.index( cur ) > -1 :

  						// Don't pass non-elements to Sizzle
  						cur.nodeType === 1 &&
  							jQuery.find.matchesSelector( cur, selectors ) ) ) {

  						matched.push( cur );
  						break;
  					}
  				}
  			}
  		}

  		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
  	},

  	// Determine the position of an element within the set
  	index: function( elem ) {

  		// No argument, return index in parent
  		if ( !elem ) {
  			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
  		}

  		// Index in selector
  		if ( typeof elem === "string" ) {
  			return indexOf.call( jQuery( elem ), this[ 0 ] );
  		}

  		// Locate the position of the desired element
  		return indexOf.call( this,

  			// If it receives a jQuery object, the first element is used
  			elem.jquery ? elem[ 0 ] : elem
  		);
  	},

  	add: function( selector, context ) {
  		return this.pushStack(
  			jQuery.uniqueSort(
  				jQuery.merge( this.get(), jQuery( selector, context ) )
  			)
  		);
  	},

  	addBack: function( selector ) {
  		return this.add( selector == null ?
  			this.prevObject : this.prevObject.filter( selector )
  		);
  	}
  } );

  function sibling( cur, dir ) {
  	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
  	return cur;
  }

  jQuery.each( {
  	parent: function( elem ) {
  		var parent = elem.parentNode;
  		return parent && parent.nodeType !== 11 ? parent : null;
  	},
  	parents: function( elem ) {
  		return dir( elem, "parentNode" );
  	},
  	parentsUntil: function( elem, i, until ) {
  		return dir( elem, "parentNode", until );
  	},
  	next: function( elem ) {
  		return sibling( elem, "nextSibling" );
  	},
  	prev: function( elem ) {
  		return sibling( elem, "previousSibling" );
  	},
  	nextAll: function( elem ) {
  		return dir( elem, "nextSibling" );
  	},
  	prevAll: function( elem ) {
  		return dir( elem, "previousSibling" );
  	},
  	nextUntil: function( elem, i, until ) {
  		return dir( elem, "nextSibling", until );
  	},
  	prevUntil: function( elem, i, until ) {
  		return dir( elem, "previousSibling", until );
  	},
  	siblings: function( elem ) {
  		return siblings( ( elem.parentNode || {} ).firstChild, elem );
  	},
  	children: function( elem ) {
  		return siblings( elem.firstChild );
  	},
  	contents: function( elem ) {
          if ( nodeName( elem, "iframe" ) ) {
              return elem.contentDocument;
          }

          // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
          // Treat the template element as a regular one in browsers that
          // don't support it.
          if ( nodeName( elem, "template" ) ) {
              elem = elem.content || elem;
          }

          return jQuery.merge( [], elem.childNodes );
  	}
  }, function( name, fn ) {
  	jQuery.fn[ name ] = function( until, selector ) {
  		var matched = jQuery.map( this, fn, until );

  		if ( name.slice( -5 ) !== "Until" ) {
  			selector = until;
  		}

  		if ( selector && typeof selector === "string" ) {
  			matched = jQuery.filter( selector, matched );
  		}

  		if ( this.length > 1 ) {

  			// Remove duplicates
  			if ( !guaranteedUnique[ name ] ) {
  				jQuery.uniqueSort( matched );
  			}

  			// Reverse order for parents* and prev-derivatives
  			if ( rparentsprev.test( name ) ) {
  				matched.reverse();
  			}
  		}

  		return this.pushStack( matched );
  	};
  } );
  var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



  // Convert String-formatted options into Object-formatted ones
  function createOptions( options ) {
  	var object = {};
  	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
  		object[ flag ] = true;
  	} );
  	return object;
  }

  /*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */
  jQuery.Callbacks = function( options ) {

  	// Convert options from String-formatted to Object-formatted if needed
  	// (we check in cache first)
  	options = typeof options === "string" ?
  		createOptions( options ) :
  		jQuery.extend( {}, options );

  	var // Flag to know if list is currently firing
  		firing,

  		// Last fire value for non-forgettable lists
  		memory,

  		// Flag to know if list was already fired
  		fired,

  		// Flag to prevent firing
  		locked,

  		// Actual callback list
  		list = [],

  		// Queue of execution data for repeatable lists
  		queue = [],

  		// Index of currently firing callback (modified by add/remove as needed)
  		firingIndex = -1,

  		// Fire callbacks
  		fire = function() {

  			// Enforce single-firing
  			locked = locked || options.once;

  			// Execute callbacks for all pending executions,
  			// respecting firingIndex overrides and runtime changes
  			fired = firing = true;
  			for ( ; queue.length; firingIndex = -1 ) {
  				memory = queue.shift();
  				while ( ++firingIndex < list.length ) {

  					// Run callback and check for early termination
  					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
  						options.stopOnFalse ) {

  						// Jump to end and forget the data so .add doesn't re-fire
  						firingIndex = list.length;
  						memory = false;
  					}
  				}
  			}

  			// Forget the data if we're done with it
  			if ( !options.memory ) {
  				memory = false;
  			}

  			firing = false;

  			// Clean up if we're done firing for good
  			if ( locked ) {

  				// Keep an empty list if we have data for future add calls
  				if ( memory ) {
  					list = [];

  				// Otherwise, this object is spent
  				} else {
  					list = "";
  				}
  			}
  		},

  		// Actual Callbacks object
  		self = {

  			// Add a callback or a collection of callbacks to the list
  			add: function() {
  				if ( list ) {

  					// If we have memory from a past run, we should fire after adding
  					if ( memory && !firing ) {
  						firingIndex = list.length - 1;
  						queue.push( memory );
  					}

  					( function add( args ) {
  						jQuery.each( args, function( _, arg ) {
  							if ( isFunction( arg ) ) {
  								if ( !options.unique || !self.has( arg ) ) {
  									list.push( arg );
  								}
  							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

  								// Inspect recursively
  								add( arg );
  							}
  						} );
  					} )( arguments );

  					if ( memory && !firing ) {
  						fire();
  					}
  				}
  				return this;
  			},

  			// Remove a callback from the list
  			remove: function() {
  				jQuery.each( arguments, function( _, arg ) {
  					var index;
  					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
  						list.splice( index, 1 );

  						// Handle firing indexes
  						if ( index <= firingIndex ) {
  							firingIndex--;
  						}
  					}
  				} );
  				return this;
  			},

  			// Check if a given callback is in the list.
  			// If no argument is given, return whether or not list has callbacks attached.
  			has: function( fn ) {
  				return fn ?
  					jQuery.inArray( fn, list ) > -1 :
  					list.length > 0;
  			},

  			// Remove all callbacks from the list
  			empty: function() {
  				if ( list ) {
  					list = [];
  				}
  				return this;
  			},

  			// Disable .fire and .add
  			// Abort any current/pending executions
  			// Clear all callbacks and values
  			disable: function() {
  				locked = queue = [];
  				list = memory = "";
  				return this;
  			},
  			disabled: function() {
  				return !list;
  			},

  			// Disable .fire
  			// Also disable .add unless we have memory (since it would have no effect)
  			// Abort any pending executions
  			lock: function() {
  				locked = queue = [];
  				if ( !memory && !firing ) {
  					list = memory = "";
  				}
  				return this;
  			},
  			locked: function() {
  				return !!locked;
  			},

  			// Call all callbacks with the given context and arguments
  			fireWith: function( context, args ) {
  				if ( !locked ) {
  					args = args || [];
  					args = [ context, args.slice ? args.slice() : args ];
  					queue.push( args );
  					if ( !firing ) {
  						fire();
  					}
  				}
  				return this;
  			},

  			// Call all the callbacks with the given arguments
  			fire: function() {
  				self.fireWith( this, arguments );
  				return this;
  			},

  			// To know if the callbacks have already been called at least once
  			fired: function() {
  				return !!fired;
  			}
  		};

  	return self;
  };


  function Identity( v ) {
  	return v;
  }
  function Thrower( ex ) {
  	throw ex;
  }

  function adoptValue( value, resolve, reject, noValue ) {
  	var method;

  	try {

  		// Check for promise aspect first to privilege synchronous behavior
  		if ( value && isFunction( ( method = value.promise ) ) ) {
  			method.call( value ).done( resolve ).fail( reject );

  		// Other thenables
  		} else if ( value && isFunction( ( method = value.then ) ) ) {
  			method.call( value, resolve, reject );

  		// Other non-thenables
  		} else {

  			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
  			// * false: [ value ].slice( 0 ) => resolve( value )
  			// * true: [ value ].slice( 1 ) => resolve()
  			resolve.apply( undefined, [ value ].slice( noValue ) );
  		}

  	// For Promises/A+, convert exceptions into rejections
  	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
  	// Deferred#then to conditionally suppress rejection.
  	} catch ( value ) {

  		// Support: Android 4.0 only
  		// Strict mode functions invoked without .call/.apply get global-object context
  		reject.apply( undefined, [ value ] );
  	}
  }

  jQuery.extend( {

  	Deferred: function( func ) {
  		var tuples = [

  				// action, add listener, callbacks,
  				// ... .then handlers, argument index, [final state]
  				[ "notify", "progress", jQuery.Callbacks( "memory" ),
  					jQuery.Callbacks( "memory" ), 2 ],
  				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
  					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
  				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
  					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
  			],
  			state = "pending",
  			promise = {
  				state: function() {
  					return state;
  				},
  				always: function() {
  					deferred.done( arguments ).fail( arguments );
  					return this;
  				},
  				"catch": function( fn ) {
  					return promise.then( null, fn );
  				},

  				// Keep pipe for back-compat
  				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
  					var fns = arguments;

  					return jQuery.Deferred( function( newDefer ) {
  						jQuery.each( tuples, function( i, tuple ) {

  							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
  							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

  							// deferred.progress(function() { bind to newDefer or newDefer.notify })
  							// deferred.done(function() { bind to newDefer or newDefer.resolve })
  							// deferred.fail(function() { bind to newDefer or newDefer.reject })
  							deferred[ tuple[ 1 ] ]( function() {
  								var returned = fn && fn.apply( this, arguments );
  								if ( returned && isFunction( returned.promise ) ) {
  									returned.promise()
  										.progress( newDefer.notify )
  										.done( newDefer.resolve )
  										.fail( newDefer.reject );
  								} else {
  									newDefer[ tuple[ 0 ] + "With" ](
  										this,
  										fn ? [ returned ] : arguments
  									);
  								}
  							} );
  						} );
  						fns = null;
  					} ).promise();
  				},
  				then: function( onFulfilled, onRejected, onProgress ) {
  					var maxDepth = 0;
  					function resolve( depth, deferred, handler, special ) {
  						return function() {
  							var that = this,
  								args = arguments,
  								mightThrow = function() {
  									var returned, then;

  									// Support: Promises/A+ section 2.3.3.3.3
  									// https://promisesaplus.com/#point-59
  									// Ignore double-resolution attempts
  									if ( depth < maxDepth ) {
  										return;
  									}

  									returned = handler.apply( that, args );

  									// Support: Promises/A+ section 2.3.1
  									// https://promisesaplus.com/#point-48
  									if ( returned === deferred.promise() ) {
  										throw new TypeError( "Thenable self-resolution" );
  									}

  									// Support: Promises/A+ sections 2.3.3.1, 3.5
  									// https://promisesaplus.com/#point-54
  									// https://promisesaplus.com/#point-75
  									// Retrieve `then` only once
  									then = returned &&

  										// Support: Promises/A+ section 2.3.4
  										// https://promisesaplus.com/#point-64
  										// Only check objects and functions for thenability
  										( typeof returned === "object" ||
  											typeof returned === "function" ) &&
  										returned.then;

  									// Handle a returned thenable
  									if ( isFunction( then ) ) {

  										// Special processors (notify) just wait for resolution
  										if ( special ) {
  											then.call(
  												returned,
  												resolve( maxDepth, deferred, Identity, special ),
  												resolve( maxDepth, deferred, Thrower, special )
  											);

  										// Normal processors (resolve) also hook into progress
  										} else {

  											// ...and disregard older resolution values
  											maxDepth++;

  											then.call(
  												returned,
  												resolve( maxDepth, deferred, Identity, special ),
  												resolve( maxDepth, deferred, Thrower, special ),
  												resolve( maxDepth, deferred, Identity,
  													deferred.notifyWith )
  											);
  										}

  									// Handle all other returned values
  									} else {

  										// Only substitute handlers pass on context
  										// and multiple values (non-spec behavior)
  										if ( handler !== Identity ) {
  											that = undefined;
  											args = [ returned ];
  										}

  										// Process the value(s)
  										// Default process is resolve
  										( special || deferred.resolveWith )( that, args );
  									}
  								},

  								// Only normal processors (resolve) catch and reject exceptions
  								process = special ?
  									mightThrow :
  									function() {
  										try {
  											mightThrow();
  										} catch ( e ) {

  											if ( jQuery.Deferred.exceptionHook ) {
  												jQuery.Deferred.exceptionHook( e,
  													process.stackTrace );
  											}

  											// Support: Promises/A+ section 2.3.3.3.4.1
  											// https://promisesaplus.com/#point-61
  											// Ignore post-resolution exceptions
  											if ( depth + 1 >= maxDepth ) {

  												// Only substitute handlers pass on context
  												// and multiple values (non-spec behavior)
  												if ( handler !== Thrower ) {
  													that = undefined;
  													args = [ e ];
  												}

  												deferred.rejectWith( that, args );
  											}
  										}
  									};

  							// Support: Promises/A+ section 2.3.3.3.1
  							// https://promisesaplus.com/#point-57
  							// Re-resolve promises immediately to dodge false rejection from
  							// subsequent errors
  							if ( depth ) {
  								process();
  							} else {

  								// Call an optional hook to record the stack, in case of exception
  								// since it's otherwise lost when execution goes async
  								if ( jQuery.Deferred.getStackHook ) {
  									process.stackTrace = jQuery.Deferred.getStackHook();
  								}
  								window.setTimeout( process );
  							}
  						};
  					}

  					return jQuery.Deferred( function( newDefer ) {

  						// progress_handlers.add( ... )
  						tuples[ 0 ][ 3 ].add(
  							resolve(
  								0,
  								newDefer,
  								isFunction( onProgress ) ?
  									onProgress :
  									Identity,
  								newDefer.notifyWith
  							)
  						);

  						// fulfilled_handlers.add( ... )
  						tuples[ 1 ][ 3 ].add(
  							resolve(
  								0,
  								newDefer,
  								isFunction( onFulfilled ) ?
  									onFulfilled :
  									Identity
  							)
  						);

  						// rejected_handlers.add( ... )
  						tuples[ 2 ][ 3 ].add(
  							resolve(
  								0,
  								newDefer,
  								isFunction( onRejected ) ?
  									onRejected :
  									Thrower
  							)
  						);
  					} ).promise();
  				},

  				// Get a promise for this deferred
  				// If obj is provided, the promise aspect is added to the object
  				promise: function( obj ) {
  					return obj != null ? jQuery.extend( obj, promise ) : promise;
  				}
  			},
  			deferred = {};

  		// Add list-specific methods
  		jQuery.each( tuples, function( i, tuple ) {
  			var list = tuple[ 2 ],
  				stateString = tuple[ 5 ];

  			// promise.progress = list.add
  			// promise.done = list.add
  			// promise.fail = list.add
  			promise[ tuple[ 1 ] ] = list.add;

  			// Handle state
  			if ( stateString ) {
  				list.add(
  					function() {

  						// state = "resolved" (i.e., fulfilled)
  						// state = "rejected"
  						state = stateString;
  					},

  					// rejected_callbacks.disable
  					// fulfilled_callbacks.disable
  					tuples[ 3 - i ][ 2 ].disable,

  					// rejected_handlers.disable
  					// fulfilled_handlers.disable
  					tuples[ 3 - i ][ 3 ].disable,

  					// progress_callbacks.lock
  					tuples[ 0 ][ 2 ].lock,

  					// progress_handlers.lock
  					tuples[ 0 ][ 3 ].lock
  				);
  			}

  			// progress_handlers.fire
  			// fulfilled_handlers.fire
  			// rejected_handlers.fire
  			list.add( tuple[ 3 ].fire );

  			// deferred.notify = function() { deferred.notifyWith(...) }
  			// deferred.resolve = function() { deferred.resolveWith(...) }
  			// deferred.reject = function() { deferred.rejectWith(...) }
  			deferred[ tuple[ 0 ] ] = function() {
  				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
  				return this;
  			};

  			// deferred.notifyWith = list.fireWith
  			// deferred.resolveWith = list.fireWith
  			// deferred.rejectWith = list.fireWith
  			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
  		} );

  		// Make the deferred a promise
  		promise.promise( deferred );

  		// Call given func if any
  		if ( func ) {
  			func.call( deferred, deferred );
  		}

  		// All done!
  		return deferred;
  	},

  	// Deferred helper
  	when: function( singleValue ) {
  		var

  			// count of uncompleted subordinates
  			remaining = arguments.length,

  			// count of unprocessed arguments
  			i = remaining,

  			// subordinate fulfillment data
  			resolveContexts = Array( i ),
  			resolveValues = slice.call( arguments ),

  			// the master Deferred
  			master = jQuery.Deferred(),

  			// subordinate callback factory
  			updateFunc = function( i ) {
  				return function( value ) {
  					resolveContexts[ i ] = this;
  					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
  					if ( !( --remaining ) ) {
  						master.resolveWith( resolveContexts, resolveValues );
  					}
  				};
  			};

  		// Single- and empty arguments are adopted like Promise.resolve
  		if ( remaining <= 1 ) {
  			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
  				!remaining );

  			// Use .then() to unwrap secondary thenables (cf. gh-3000)
  			if ( master.state() === "pending" ||
  				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

  				return master.then();
  			}
  		}

  		// Multiple arguments are aggregated like Promise.all array elements
  		while ( i-- ) {
  			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
  		}

  		return master.promise();
  	}
  } );


  // These usually indicate a programmer mistake during development,
  // warn about them ASAP rather than swallowing them by default.
  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

  jQuery.Deferred.exceptionHook = function( error, stack ) {

  	// Support: IE 8 - 9 only
  	// Console exists when dev tools are open, which can happen at any time
  	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
  		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
  	}
  };




  jQuery.readyException = function( error ) {
  	window.setTimeout( function() {
  		throw error;
  	} );
  };




  // The deferred used on DOM ready
  var readyList = jQuery.Deferred();

  jQuery.fn.ready = function( fn ) {

  	readyList
  		.then( fn )

  		// Wrap jQuery.readyException in a function so that the lookup
  		// happens at the time of error handling instead of callback
  		// registration.
  		.catch( function( error ) {
  			jQuery.readyException( error );
  		} );

  	return this;
  };

  jQuery.extend( {

  	// Is the DOM ready to be used? Set to true once it occurs.
  	isReady: false,

  	// A counter to track how many items to wait for before
  	// the ready event fires. See #6781
  	readyWait: 1,

  	// Handle when the DOM is ready
  	ready: function( wait ) {

  		// Abort if there are pending holds or we're already ready
  		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
  			return;
  		}

  		// Remember that the DOM is ready
  		jQuery.isReady = true;

  		// If a normal DOM Ready event fired, decrement, and wait if need be
  		if ( wait !== true && --jQuery.readyWait > 0 ) {
  			return;
  		}

  		// If there are functions bound, to execute
  		readyList.resolveWith( document, [ jQuery ] );
  	}
  } );

  jQuery.ready.then = readyList.then;

  // The ready event handler and self cleanup method
  function completed() {
  	document.removeEventListener( "DOMContentLoaded", completed );
  	window.removeEventListener( "load", completed );
  	jQuery.ready();
  }

  // Catch cases where $(document).ready() is called
  // after the browser event has already occurred.
  // Support: IE <=9 - 10 only
  // Older IE sometimes signals "interactive" too soon
  if ( document.readyState === "complete" ||
  	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

  	// Handle it asynchronously to allow scripts the opportunity to delay ready
  	window.setTimeout( jQuery.ready );

  } else {

  	// Use the handy event callback
  	document.addEventListener( "DOMContentLoaded", completed );

  	// A fallback to window.onload, that will always work
  	window.addEventListener( "load", completed );
  }




  // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function
  var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
  	var i = 0,
  		len = elems.length,
  		bulk = key == null;

  	// Sets many values
  	if ( toType( key ) === "object" ) {
  		chainable = true;
  		for ( i in key ) {
  			access( elems, fn, i, key[ i ], true, emptyGet, raw );
  		}

  	// Sets one value
  	} else if ( value !== undefined ) {
  		chainable = true;

  		if ( !isFunction( value ) ) {
  			raw = true;
  		}

  		if ( bulk ) {

  			// Bulk operations run against the entire set
  			if ( raw ) {
  				fn.call( elems, value );
  				fn = null;

  			// ...except when executing function values
  			} else {
  				bulk = fn;
  				fn = function( elem, key, value ) {
  					return bulk.call( jQuery( elem ), value );
  				};
  			}
  		}

  		if ( fn ) {
  			for ( ; i < len; i++ ) {
  				fn(
  					elems[ i ], key, raw ?
  					value :
  					value.call( elems[ i ], i, fn( elems[ i ], key ) )
  				);
  			}
  		}
  	}

  	if ( chainable ) {
  		return elems;
  	}

  	// Gets
  	if ( bulk ) {
  		return fn.call( elems );
  	}

  	return len ? fn( elems[ 0 ], key ) : emptyGet;
  };


  // Matches dashed string for camelizing
  var rmsPrefix = /^-ms-/,
  	rdashAlpha = /-([a-z])/g;

  // Used by camelCase as callback to replace()
  function fcamelCase( all, letter ) {
  	return letter.toUpperCase();
  }

  // Convert dashed to camelCase; used by the css and data modules
  // Support: IE <=9 - 11, Edge 12 - 15
  // Microsoft forgot to hump their vendor prefix (#9572)
  function camelCase( string ) {
  	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
  }
  var acceptData = function( owner ) {

  	// Accepts only:
  	//  - Node
  	//    - Node.ELEMENT_NODE
  	//    - Node.DOCUMENT_NODE
  	//  - Object
  	//    - Any
  	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
  };




  function Data() {
  	this.expando = jQuery.expando + Data.uid++;
  }

  Data.uid = 1;

  Data.prototype = {

  	cache: function( owner ) {

  		// Check if the owner object already has a cache
  		var value = owner[ this.expando ];

  		// If not, create one
  		if ( !value ) {
  			value = {};

  			// We can accept data for non-element nodes in modern browsers,
  			// but we should not, see #8335.
  			// Always return an empty object.
  			if ( acceptData( owner ) ) {

  				// If it is a node unlikely to be stringify-ed or looped over
  				// use plain assignment
  				if ( owner.nodeType ) {
  					owner[ this.expando ] = value;

  				// Otherwise secure it in a non-enumerable property
  				// configurable must be true to allow the property to be
  				// deleted when data is removed
  				} else {
  					Object.defineProperty( owner, this.expando, {
  						value: value,
  						configurable: true
  					} );
  				}
  			}
  		}

  		return value;
  	},
  	set: function( owner, data, value ) {
  		var prop,
  			cache = this.cache( owner );

  		// Handle: [ owner, key, value ] args
  		// Always use camelCase key (gh-2257)
  		if ( typeof data === "string" ) {
  			cache[ camelCase( data ) ] = value;

  		// Handle: [ owner, { properties } ] args
  		} else {

  			// Copy the properties one-by-one to the cache object
  			for ( prop in data ) {
  				cache[ camelCase( prop ) ] = data[ prop ];
  			}
  		}
  		return cache;
  	},
  	get: function( owner, key ) {
  		return key === undefined ?
  			this.cache( owner ) :

  			// Always use camelCase key (gh-2257)
  			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
  	},
  	access: function( owner, key, value ) {

  		// In cases where either:
  		//
  		//   1. No key was specified
  		//   2. A string key was specified, but no value provided
  		//
  		// Take the "read" path and allow the get method to determine
  		// which value to return, respectively either:
  		//
  		//   1. The entire cache object
  		//   2. The data stored at the key
  		//
  		if ( key === undefined ||
  				( ( key && typeof key === "string" ) && value === undefined ) ) {

  			return this.get( owner, key );
  		}

  		// When the key is not a string, or both a key and value
  		// are specified, set or extend (existing objects) with either:
  		//
  		//   1. An object of properties
  		//   2. A key and value
  		//
  		this.set( owner, key, value );

  		// Since the "set" path can have two possible entry points
  		// return the expected data based on which path was taken[*]
  		return value !== undefined ? value : key;
  	},
  	remove: function( owner, key ) {
  		var i,
  			cache = owner[ this.expando ];

  		if ( cache === undefined ) {
  			return;
  		}

  		if ( key !== undefined ) {

  			// Support array or space separated string of keys
  			if ( Array.isArray( key ) ) {

  				// If key is an array of keys...
  				// We always set camelCase keys, so remove that.
  				key = key.map( camelCase );
  			} else {
  				key = camelCase( key );

  				// If a key with the spaces exists, use it.
  				// Otherwise, create an array by matching non-whitespace
  				key = key in cache ?
  					[ key ] :
  					( key.match( rnothtmlwhite ) || [] );
  			}

  			i = key.length;

  			while ( i-- ) {
  				delete cache[ key[ i ] ];
  			}
  		}

  		// Remove the expando if there's no more data
  		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

  			// Support: Chrome <=35 - 45
  			// Webkit & Blink performance suffers when deleting properties
  			// from DOM nodes, so set to undefined instead
  			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
  			if ( owner.nodeType ) {
  				owner[ this.expando ] = undefined;
  			} else {
  				delete owner[ this.expando ];
  			}
  		}
  	},
  	hasData: function( owner ) {
  		var cache = owner[ this.expando ];
  		return cache !== undefined && !jQuery.isEmptyObject( cache );
  	}
  };
  var dataPriv = new Data();

  var dataUser = new Data();



  //	Implementation Summary
  //
  //	1. Enforce API surface and semantic compatibility with 1.9.x branch
  //	2. Improve the module's maintainability by reducing the storage
  //		paths to a single mechanism.
  //	3. Use the same single mechanism to support "private" and "user" data.
  //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  //	5. Avoid exposing implementation details on user objects (eg. expando properties)
  //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
  	rmultiDash = /[A-Z]/g;

  function getData( data ) {
  	if ( data === "true" ) {
  		return true;
  	}

  	if ( data === "false" ) {
  		return false;
  	}

  	if ( data === "null" ) {
  		return null;
  	}

  	// Only convert to a number if it doesn't change the string
  	if ( data === +data + "" ) {
  		return +data;
  	}

  	if ( rbrace.test( data ) ) {
  		return JSON.parse( data );
  	}

  	return data;
  }

  function dataAttr( elem, key, data ) {
  	var name;

  	// If nothing was found internally, try to fetch any
  	// data from the HTML5 data-* attribute
  	if ( data === undefined && elem.nodeType === 1 ) {
  		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
  		data = elem.getAttribute( name );

  		if ( typeof data === "string" ) {
  			try {
  				data = getData( data );
  			} catch ( e ) {}

  			// Make sure we set the data so it isn't changed later
  			dataUser.set( elem, key, data );
  		} else {
  			data = undefined;
  		}
  	}
  	return data;
  }

  jQuery.extend( {
  	hasData: function( elem ) {
  		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
  	},

  	data: function( elem, name, data ) {
  		return dataUser.access( elem, name, data );
  	},

  	removeData: function( elem, name ) {
  		dataUser.remove( elem, name );
  	},

  	// TODO: Now that all calls to _data and _removeData have been replaced
  	// with direct calls to dataPriv methods, these can be deprecated.
  	_data: function( elem, name, data ) {
  		return dataPriv.access( elem, name, data );
  	},

  	_removeData: function( elem, name ) {
  		dataPriv.remove( elem, name );
  	}
  } );

  jQuery.fn.extend( {
  	data: function( key, value ) {
  		var i, name, data,
  			elem = this[ 0 ],
  			attrs = elem && elem.attributes;

  		// Gets all values
  		if ( key === undefined ) {
  			if ( this.length ) {
  				data = dataUser.get( elem );

  				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
  					i = attrs.length;
  					while ( i-- ) {

  						// Support: IE 11 only
  						// The attrs elements can be null (#14894)
  						if ( attrs[ i ] ) {
  							name = attrs[ i ].name;
  							if ( name.indexOf( "data-" ) === 0 ) {
  								name = camelCase( name.slice( 5 ) );
  								dataAttr( elem, name, data[ name ] );
  							}
  						}
  					}
  					dataPriv.set( elem, "hasDataAttrs", true );
  				}
  			}

  			return data;
  		}

  		// Sets multiple values
  		if ( typeof key === "object" ) {
  			return this.each( function() {
  				dataUser.set( this, key );
  			} );
  		}

  		return access( this, function( value ) {
  			var data;

  			// The calling jQuery object (element matches) is not empty
  			// (and therefore has an element appears at this[ 0 ]) and the
  			// `value` parameter was not undefined. An empty jQuery object
  			// will result in `undefined` for elem = this[ 0 ] which will
  			// throw an exception if an attempt to read a data cache is made.
  			if ( elem && value === undefined ) {

  				// Attempt to get data from the cache
  				// The key will always be camelCased in Data
  				data = dataUser.get( elem, key );
  				if ( data !== undefined ) {
  					return data;
  				}

  				// Attempt to "discover" the data in
  				// HTML5 custom data-* attrs
  				data = dataAttr( elem, key );
  				if ( data !== undefined ) {
  					return data;
  				}

  				// We tried really hard, but the data doesn't exist.
  				return;
  			}

  			// Set the data...
  			this.each( function() {

  				// We always store the camelCased key
  				dataUser.set( this, key, value );
  			} );
  		}, null, value, arguments.length > 1, null, true );
  	},

  	removeData: function( key ) {
  		return this.each( function() {
  			dataUser.remove( this, key );
  		} );
  	}
  } );


  jQuery.extend( {
  	queue: function( elem, type, data ) {
  		var queue;

  		if ( elem ) {
  			type = ( type || "fx" ) + "queue";
  			queue = dataPriv.get( elem, type );

  			// Speed up dequeue by getting out quickly if this is just a lookup
  			if ( data ) {
  				if ( !queue || Array.isArray( data ) ) {
  					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
  				} else {
  					queue.push( data );
  				}
  			}
  			return queue || [];
  		}
  	},

  	dequeue: function( elem, type ) {
  		type = type || "fx";

  		var queue = jQuery.queue( elem, type ),
  			startLength = queue.length,
  			fn = queue.shift(),
  			hooks = jQuery._queueHooks( elem, type ),
  			next = function() {
  				jQuery.dequeue( elem, type );
  			};

  		// If the fx queue is dequeued, always remove the progress sentinel
  		if ( fn === "inprogress" ) {
  			fn = queue.shift();
  			startLength--;
  		}

  		if ( fn ) {

  			// Add a progress sentinel to prevent the fx queue from being
  			// automatically dequeued
  			if ( type === "fx" ) {
  				queue.unshift( "inprogress" );
  			}

  			// Clear up the last queue stop function
  			delete hooks.stop;
  			fn.call( elem, next, hooks );
  		}

  		if ( !startLength && hooks ) {
  			hooks.empty.fire();
  		}
  	},

  	// Not public - generate a queueHooks object, or return the current one
  	_queueHooks: function( elem, type ) {
  		var key = type + "queueHooks";
  		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
  			empty: jQuery.Callbacks( "once memory" ).add( function() {
  				dataPriv.remove( elem, [ type + "queue", key ] );
  			} )
  		} );
  	}
  } );

  jQuery.fn.extend( {
  	queue: function( type, data ) {
  		var setter = 2;

  		if ( typeof type !== "string" ) {
  			data = type;
  			type = "fx";
  			setter--;
  		}

  		if ( arguments.length < setter ) {
  			return jQuery.queue( this[ 0 ], type );
  		}

  		return data === undefined ?
  			this :
  			this.each( function() {
  				var queue = jQuery.queue( this, type, data );

  				// Ensure a hooks for this queue
  				jQuery._queueHooks( this, type );

  				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
  					jQuery.dequeue( this, type );
  				}
  			} );
  	},
  	dequeue: function( type ) {
  		return this.each( function() {
  			jQuery.dequeue( this, type );
  		} );
  	},
  	clearQueue: function( type ) {
  		return this.queue( type || "fx", [] );
  	},

  	// Get a promise resolved when queues of a certain type
  	// are emptied (fx is the type by default)
  	promise: function( type, obj ) {
  		var tmp,
  			count = 1,
  			defer = jQuery.Deferred(),
  			elements = this,
  			i = this.length,
  			resolve = function() {
  				if ( !( --count ) ) {
  					defer.resolveWith( elements, [ elements ] );
  				}
  			};

  		if ( typeof type !== "string" ) {
  			obj = type;
  			type = undefined;
  		}
  		type = type || "fx";

  		while ( i-- ) {
  			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
  			if ( tmp && tmp.empty ) {
  				count++;
  				tmp.empty.add( resolve );
  			}
  		}
  		resolve();
  		return defer.promise( obj );
  	}
  } );
  var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

  var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


  var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

  var isHiddenWithinTree = function( elem, el ) {

  		// isHiddenWithinTree might be called from jQuery#filter function;
  		// in that case, element will be second argument
  		elem = el || elem;

  		// Inline style trumps all
  		return elem.style.display === "none" ||
  			elem.style.display === "" &&

  			// Otherwise, check computed style
  			// Support: Firefox <=43 - 45
  			// Disconnected elements can have computed display: none, so first confirm that elem is
  			// in the document.
  			jQuery.contains( elem.ownerDocument, elem ) &&

  			jQuery.css( elem, "display" ) === "none";
  	};

  var swap = function( elem, options, callback, args ) {
  	var ret, name,
  		old = {};

  	// Remember the old values, and insert the new ones
  	for ( name in options ) {
  		old[ name ] = elem.style[ name ];
  		elem.style[ name ] = options[ name ];
  	}

  	ret = callback.apply( elem, args || [] );

  	// Revert the old values
  	for ( name in options ) {
  		elem.style[ name ] = old[ name ];
  	}

  	return ret;
  };




  function adjustCSS( elem, prop, valueParts, tween ) {
  	var adjusted, scale,
  		maxIterations = 20,
  		currentValue = tween ?
  			function() {
  				return tween.cur();
  			} :
  			function() {
  				return jQuery.css( elem, prop, "" );
  			},
  		initial = currentValue(),
  		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

  		// Starting value computation is required for potential unit mismatches
  		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
  			rcssNum.exec( jQuery.css( elem, prop ) );

  	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

  		// Support: Firefox <=54
  		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
  		initial = initial / 2;

  		// Trust units reported by jQuery.css
  		unit = unit || initialInUnit[ 3 ];

  		// Iteratively approximate from a nonzero starting point
  		initialInUnit = +initial || 1;

  		while ( maxIterations-- ) {

  			// Evaluate and update our best guess (doubling guesses that zero out).
  			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
  			jQuery.style( elem, prop, initialInUnit + unit );
  			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
  				maxIterations = 0;
  			}
  			initialInUnit = initialInUnit / scale;

  		}

  		initialInUnit = initialInUnit * 2;
  		jQuery.style( elem, prop, initialInUnit + unit );

  		// Make sure we update the tween properties later on
  		valueParts = valueParts || [];
  	}

  	if ( valueParts ) {
  		initialInUnit = +initialInUnit || +initial || 0;

  		// Apply relative offset (+=/-=) if specified
  		adjusted = valueParts[ 1 ] ?
  			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
  			+valueParts[ 2 ];
  		if ( tween ) {
  			tween.unit = unit;
  			tween.start = initialInUnit;
  			tween.end = adjusted;
  		}
  	}
  	return adjusted;
  }


  var defaultDisplayMap = {};

  function getDefaultDisplay( elem ) {
  	var temp,
  		doc = elem.ownerDocument,
  		nodeName = elem.nodeName,
  		display = defaultDisplayMap[ nodeName ];

  	if ( display ) {
  		return display;
  	}

  	temp = doc.body.appendChild( doc.createElement( nodeName ) );
  	display = jQuery.css( temp, "display" );

  	temp.parentNode.removeChild( temp );

  	if ( display === "none" ) {
  		display = "block";
  	}
  	defaultDisplayMap[ nodeName ] = display;

  	return display;
  }

  function showHide( elements, show ) {
  	var display, elem,
  		values = [],
  		index = 0,
  		length = elements.length;

  	// Determine new display value for elements that need to change
  	for ( ; index < length; index++ ) {
  		elem = elements[ index ];
  		if ( !elem.style ) {
  			continue;
  		}

  		display = elem.style.display;
  		if ( show ) {

  			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
  			// check is required in this first loop unless we have a nonempty display value (either
  			// inline or about-to-be-restored)
  			if ( display === "none" ) {
  				values[ index ] = dataPriv.get( elem, "display" ) || null;
  				if ( !values[ index ] ) {
  					elem.style.display = "";
  				}
  			}
  			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
  				values[ index ] = getDefaultDisplay( elem );
  			}
  		} else {
  			if ( display !== "none" ) {
  				values[ index ] = "none";

  				// Remember what we're overwriting
  				dataPriv.set( elem, "display", display );
  			}
  		}
  	}

  	// Set the display of the elements in a second loop to avoid constant reflow
  	for ( index = 0; index < length; index++ ) {
  		if ( values[ index ] != null ) {
  			elements[ index ].style.display = values[ index ];
  		}
  	}

  	return elements;
  }

  jQuery.fn.extend( {
  	show: function() {
  		return showHide( this, true );
  	},
  	hide: function() {
  		return showHide( this );
  	},
  	toggle: function( state ) {
  		if ( typeof state === "boolean" ) {
  			return state ? this.show() : this.hide();
  		}

  		return this.each( function() {
  			if ( isHiddenWithinTree( this ) ) {
  				jQuery( this ).show();
  			} else {
  				jQuery( this ).hide();
  			}
  		} );
  	}
  } );
  var rcheckableType = ( /^(?:checkbox|radio)$/i );

  var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

  var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



  // We have to close these tags to support XHTML (#13200)
  var wrapMap = {

  	// Support: IE <=9 only
  	option: [ 1, "<select multiple='multiple'>", "</select>" ],

  	// XHTML parsers do not magically insert elements in the
  	// same way that tag soup parsers do. So we cannot shorten
  	// this by omitting <tbody> or other required elements.
  	thead: [ 1, "<table>", "</table>" ],
  	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
  	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
  	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

  	_default: [ 0, "", "" ]
  };

  // Support: IE <=9 only
  wrapMap.optgroup = wrapMap.option;

  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;


  function getAll( context, tag ) {

  	// Support: IE <=9 - 11 only
  	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
  	var ret;

  	if ( typeof context.getElementsByTagName !== "undefined" ) {
  		ret = context.getElementsByTagName( tag || "*" );

  	} else if ( typeof context.querySelectorAll !== "undefined" ) {
  		ret = context.querySelectorAll( tag || "*" );

  	} else {
  		ret = [];
  	}

  	if ( tag === undefined || tag && nodeName( context, tag ) ) {
  		return jQuery.merge( [ context ], ret );
  	}

  	return ret;
  }


  // Mark scripts as having already been evaluated
  function setGlobalEval( elems, refElements ) {
  	var i = 0,
  		l = elems.length;

  	for ( ; i < l; i++ ) {
  		dataPriv.set(
  			elems[ i ],
  			"globalEval",
  			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
  		);
  	}
  }


  var rhtml = /<|&#?\w+;/;

  function buildFragment( elems, context, scripts, selection, ignored ) {
  	var elem, tmp, tag, wrap, contains, j,
  		fragment = context.createDocumentFragment(),
  		nodes = [],
  		i = 0,
  		l = elems.length;

  	for ( ; i < l; i++ ) {
  		elem = elems[ i ];

  		if ( elem || elem === 0 ) {

  			// Add nodes directly
  			if ( toType( elem ) === "object" ) {

  				// Support: Android <=4.0 only, PhantomJS 1 only
  				// push.apply(_, arraylike) throws on ancient WebKit
  				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

  			// Convert non-html into a text node
  			} else if ( !rhtml.test( elem ) ) {
  				nodes.push( context.createTextNode( elem ) );

  			// Convert html into DOM nodes
  			} else {
  				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

  				// Deserialize a standard representation
  				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
  				wrap = wrapMap[ tag ] || wrapMap._default;
  				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

  				// Descend through wrappers to the right content
  				j = wrap[ 0 ];
  				while ( j-- ) {
  					tmp = tmp.lastChild;
  				}

  				// Support: Android <=4.0 only, PhantomJS 1 only
  				// push.apply(_, arraylike) throws on ancient WebKit
  				jQuery.merge( nodes, tmp.childNodes );

  				// Remember the top-level container
  				tmp = fragment.firstChild;

  				// Ensure the created nodes are orphaned (#12392)
  				tmp.textContent = "";
  			}
  		}
  	}

  	// Remove wrapper from fragment
  	fragment.textContent = "";

  	i = 0;
  	while ( ( elem = nodes[ i++ ] ) ) {

  		// Skip elements already in the context collection (trac-4087)
  		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
  			if ( ignored ) {
  				ignored.push( elem );
  			}
  			continue;
  		}

  		contains = jQuery.contains( elem.ownerDocument, elem );

  		// Append to fragment
  		tmp = getAll( fragment.appendChild( elem ), "script" );

  		// Preserve script evaluation history
  		if ( contains ) {
  			setGlobalEval( tmp );
  		}

  		// Capture executables
  		if ( scripts ) {
  			j = 0;
  			while ( ( elem = tmp[ j++ ] ) ) {
  				if ( rscriptType.test( elem.type || "" ) ) {
  					scripts.push( elem );
  				}
  			}
  		}
  	}

  	return fragment;
  }


  ( function() {
  	var fragment = document.createDocumentFragment(),
  		div = fragment.appendChild( document.createElement( "div" ) ),
  		input = document.createElement( "input" );

  	// Support: Android 4.0 - 4.3 only
  	// Check state lost if the name is set (#11217)
  	// Support: Windows Web Apps (WWA)
  	// `name` and `type` must use .setAttribute for WWA (#14901)
  	input.setAttribute( "type", "radio" );
  	input.setAttribute( "checked", "checked" );
  	input.setAttribute( "name", "t" );

  	div.appendChild( input );

  	// Support: Android <=4.1 only
  	// Older WebKit doesn't clone checked state correctly in fragments
  	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

  	// Support: IE <=11 only
  	// Make sure textarea (and checkbox) defaultValue is properly cloned
  	div.innerHTML = "<textarea>x</textarea>";
  	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
  } )();
  var documentElement = document.documentElement;



  var
  	rkeyEvent = /^key/,
  	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
  	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

  function returnTrue() {
  	return true;
  }

  function returnFalse() {
  	return false;
  }

  // Support: IE <=9 only
  // See #13393 for more info
  function safeActiveElement() {
  	try {
  		return document.activeElement;
  	} catch ( err ) { }
  }

  function on( elem, types, selector, data, fn, one ) {
  	var origFn, type;

  	// Types can be a map of types/handlers
  	if ( typeof types === "object" ) {

  		// ( types-Object, selector, data )
  		if ( typeof selector !== "string" ) {

  			// ( types-Object, data )
  			data = data || selector;
  			selector = undefined;
  		}
  		for ( type in types ) {
  			on( elem, type, selector, data, types[ type ], one );
  		}
  		return elem;
  	}

  	if ( data == null && fn == null ) {

  		// ( types, fn )
  		fn = selector;
  		data = selector = undefined;
  	} else if ( fn == null ) {
  		if ( typeof selector === "string" ) {

  			// ( types, selector, fn )
  			fn = data;
  			data = undefined;
  		} else {

  			// ( types, data, fn )
  			fn = data;
  			data = selector;
  			selector = undefined;
  		}
  	}
  	if ( fn === false ) {
  		fn = returnFalse;
  	} else if ( !fn ) {
  		return elem;
  	}

  	if ( one === 1 ) {
  		origFn = fn;
  		fn = function( event ) {

  			// Can use an empty set, since event contains the info
  			jQuery().off( event );
  			return origFn.apply( this, arguments );
  		};

  		// Use same guid so caller can remove using origFn
  		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
  	}
  	return elem.each( function() {
  		jQuery.event.add( this, types, fn, data, selector );
  	} );
  }

  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */
  jQuery.event = {

  	global: {},

  	add: function( elem, types, handler, data, selector ) {

  		var handleObjIn, eventHandle, tmp,
  			events, t, handleObj,
  			special, handlers, type, namespaces, origType,
  			elemData = dataPriv.get( elem );

  		// Don't attach events to noData or text/comment nodes (but allow plain objects)
  		if ( !elemData ) {
  			return;
  		}

  		// Caller can pass in an object of custom data in lieu of the handler
  		if ( handler.handler ) {
  			handleObjIn = handler;
  			handler = handleObjIn.handler;
  			selector = handleObjIn.selector;
  		}

  		// Ensure that invalid selectors throw exceptions at attach time
  		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
  		if ( selector ) {
  			jQuery.find.matchesSelector( documentElement, selector );
  		}

  		// Make sure that the handler has a unique ID, used to find/remove it later
  		if ( !handler.guid ) {
  			handler.guid = jQuery.guid++;
  		}

  		// Init the element's event structure and main handler, if this is the first
  		if ( !( events = elemData.events ) ) {
  			events = elemData.events = {};
  		}
  		if ( !( eventHandle = elemData.handle ) ) {
  			eventHandle = elemData.handle = function( e ) {

  				// Discard the second event of a jQuery.event.trigger() and
  				// when an event is called after a page has unloaded
  				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
  					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
  			};
  		}

  		// Handle multiple events separated by a space
  		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
  		t = types.length;
  		while ( t-- ) {
  			tmp = rtypenamespace.exec( types[ t ] ) || [];
  			type = origType = tmp[ 1 ];
  			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

  			// There *must* be a type, no attaching namespace-only handlers
  			if ( !type ) {
  				continue;
  			}

  			// If event changes its type, use the special event handlers for the changed type
  			special = jQuery.event.special[ type ] || {};

  			// If selector defined, determine special event api type, otherwise given type
  			type = ( selector ? special.delegateType : special.bindType ) || type;

  			// Update special based on newly reset type
  			special = jQuery.event.special[ type ] || {};

  			// handleObj is passed to all event handlers
  			handleObj = jQuery.extend( {
  				type: type,
  				origType: origType,
  				data: data,
  				handler: handler,
  				guid: handler.guid,
  				selector: selector,
  				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
  				namespace: namespaces.join( "." )
  			}, handleObjIn );

  			// Init the event handler queue if we're the first
  			if ( !( handlers = events[ type ] ) ) {
  				handlers = events[ type ] = [];
  				handlers.delegateCount = 0;

  				// Only use addEventListener if the special events handler returns false
  				if ( !special.setup ||
  					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

  					if ( elem.addEventListener ) {
  						elem.addEventListener( type, eventHandle );
  					}
  				}
  			}

  			if ( special.add ) {
  				special.add.call( elem, handleObj );

  				if ( !handleObj.handler.guid ) {
  					handleObj.handler.guid = handler.guid;
  				}
  			}

  			// Add to the element's handler list, delegates in front
  			if ( selector ) {
  				handlers.splice( handlers.delegateCount++, 0, handleObj );
  			} else {
  				handlers.push( handleObj );
  			}

  			// Keep track of which events have ever been used, for event optimization
  			jQuery.event.global[ type ] = true;
  		}

  	},

  	// Detach an event or set of events from an element
  	remove: function( elem, types, handler, selector, mappedTypes ) {

  		var j, origCount, tmp,
  			events, t, handleObj,
  			special, handlers, type, namespaces, origType,
  			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

  		if ( !elemData || !( events = elemData.events ) ) {
  			return;
  		}

  		// Once for each type.namespace in types; type may be omitted
  		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
  		t = types.length;
  		while ( t-- ) {
  			tmp = rtypenamespace.exec( types[ t ] ) || [];
  			type = origType = tmp[ 1 ];
  			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

  			// Unbind all events (on this namespace, if provided) for the element
  			if ( !type ) {
  				for ( type in events ) {
  					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
  				}
  				continue;
  			}

  			special = jQuery.event.special[ type ] || {};
  			type = ( selector ? special.delegateType : special.bindType ) || type;
  			handlers = events[ type ] || [];
  			tmp = tmp[ 2 ] &&
  				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

  			// Remove matching events
  			origCount = j = handlers.length;
  			while ( j-- ) {
  				handleObj = handlers[ j ];

  				if ( ( mappedTypes || origType === handleObj.origType ) &&
  					( !handler || handler.guid === handleObj.guid ) &&
  					( !tmp || tmp.test( handleObj.namespace ) ) &&
  					( !selector || selector === handleObj.selector ||
  						selector === "**" && handleObj.selector ) ) {
  					handlers.splice( j, 1 );

  					if ( handleObj.selector ) {
  						handlers.delegateCount--;
  					}
  					if ( special.remove ) {
  						special.remove.call( elem, handleObj );
  					}
  				}
  			}

  			// Remove generic event handler if we removed something and no more handlers exist
  			// (avoids potential for endless recursion during removal of special event handlers)
  			if ( origCount && !handlers.length ) {
  				if ( !special.teardown ||
  					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

  					jQuery.removeEvent( elem, type, elemData.handle );
  				}

  				delete events[ type ];
  			}
  		}

  		// Remove data and the expando if it's no longer used
  		if ( jQuery.isEmptyObject( events ) ) {
  			dataPriv.remove( elem, "handle events" );
  		}
  	},

  	dispatch: function( nativeEvent ) {

  		// Make a writable jQuery.Event from the native event object
  		var event = jQuery.event.fix( nativeEvent );

  		var i, j, ret, matched, handleObj, handlerQueue,
  			args = new Array( arguments.length ),
  			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
  			special = jQuery.event.special[ event.type ] || {};

  		// Use the fix-ed jQuery.Event rather than the (read-only) native event
  		args[ 0 ] = event;

  		for ( i = 1; i < arguments.length; i++ ) {
  			args[ i ] = arguments[ i ];
  		}

  		event.delegateTarget = this;

  		// Call the preDispatch hook for the mapped type, and let it bail if desired
  		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
  			return;
  		}

  		// Determine handlers
  		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

  		// Run delegates first; they may want to stop propagation beneath us
  		i = 0;
  		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
  			event.currentTarget = matched.elem;

  			j = 0;
  			while ( ( handleObj = matched.handlers[ j++ ] ) &&
  				!event.isImmediatePropagationStopped() ) {

  				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
  				// a subset or equal to those in the bound event (both can have no namespace).
  				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

  					event.handleObj = handleObj;
  					event.data = handleObj.data;

  					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
  						handleObj.handler ).apply( matched.elem, args );

  					if ( ret !== undefined ) {
  						if ( ( event.result = ret ) === false ) {
  							event.preventDefault();
  							event.stopPropagation();
  						}
  					}
  				}
  			}
  		}

  		// Call the postDispatch hook for the mapped type
  		if ( special.postDispatch ) {
  			special.postDispatch.call( this, event );
  		}

  		return event.result;
  	},

  	handlers: function( event, handlers ) {
  		var i, handleObj, sel, matchedHandlers, matchedSelectors,
  			handlerQueue = [],
  			delegateCount = handlers.delegateCount,
  			cur = event.target;

  		// Find delegate handlers
  		if ( delegateCount &&

  			// Support: IE <=9
  			// Black-hole SVG <use> instance trees (trac-13180)
  			cur.nodeType &&

  			// Support: Firefox <=42
  			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
  			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
  			// Support: IE 11 only
  			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
  			!( event.type === "click" && event.button >= 1 ) ) {

  			for ( ; cur !== this; cur = cur.parentNode || this ) {

  				// Don't check non-elements (#13208)
  				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
  				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
  					matchedHandlers = [];
  					matchedSelectors = {};
  					for ( i = 0; i < delegateCount; i++ ) {
  						handleObj = handlers[ i ];

  						// Don't conflict with Object.prototype properties (#13203)
  						sel = handleObj.selector + " ";

  						if ( matchedSelectors[ sel ] === undefined ) {
  							matchedSelectors[ sel ] = handleObj.needsContext ?
  								jQuery( sel, this ).index( cur ) > -1 :
  								jQuery.find( sel, this, null, [ cur ] ).length;
  						}
  						if ( matchedSelectors[ sel ] ) {
  							matchedHandlers.push( handleObj );
  						}
  					}
  					if ( matchedHandlers.length ) {
  						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
  					}
  				}
  			}
  		}

  		// Add the remaining (directly-bound) handlers
  		cur = this;
  		if ( delegateCount < handlers.length ) {
  			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
  		}

  		return handlerQueue;
  	},

  	addProp: function( name, hook ) {
  		Object.defineProperty( jQuery.Event.prototype, name, {
  			enumerable: true,
  			configurable: true,

  			get: isFunction( hook ) ?
  				function() {
  					if ( this.originalEvent ) {
  							return hook( this.originalEvent );
  					}
  				} :
  				function() {
  					if ( this.originalEvent ) {
  							return this.originalEvent[ name ];
  					}
  				},

  			set: function( value ) {
  				Object.defineProperty( this, name, {
  					enumerable: true,
  					configurable: true,
  					writable: true,
  					value: value
  				} );
  			}
  		} );
  	},

  	fix: function( originalEvent ) {
  		return originalEvent[ jQuery.expando ] ?
  			originalEvent :
  			new jQuery.Event( originalEvent );
  	},

  	special: {
  		load: {

  			// Prevent triggered image.load events from bubbling to window.load
  			noBubble: true
  		},
  		focus: {

  			// Fire native event if possible so blur/focus sequence is correct
  			trigger: function() {
  				if ( this !== safeActiveElement() && this.focus ) {
  					this.focus();
  					return false;
  				}
  			},
  			delegateType: "focusin"
  		},
  		blur: {
  			trigger: function() {
  				if ( this === safeActiveElement() && this.blur ) {
  					this.blur();
  					return false;
  				}
  			},
  			delegateType: "focusout"
  		},
  		click: {

  			// For checkbox, fire native event so checked state will be right
  			trigger: function() {
  				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
  					this.click();
  					return false;
  				}
  			},

  			// For cross-browser consistency, don't fire native .click() on links
  			_default: function( event ) {
  				return nodeName( event.target, "a" );
  			}
  		},

  		beforeunload: {
  			postDispatch: function( event ) {

  				// Support: Firefox 20+
  				// Firefox doesn't alert if the returnValue field is not set.
  				if ( event.result !== undefined && event.originalEvent ) {
  					event.originalEvent.returnValue = event.result;
  				}
  			}
  		}
  	}
  };

  jQuery.removeEvent = function( elem, type, handle ) {

  	// This "if" is needed for plain objects
  	if ( elem.removeEventListener ) {
  		elem.removeEventListener( type, handle );
  	}
  };

  jQuery.Event = function( src, props ) {

  	// Allow instantiation without the 'new' keyword
  	if ( !( this instanceof jQuery.Event ) ) {
  		return new jQuery.Event( src, props );
  	}

  	// Event object
  	if ( src && src.type ) {
  		this.originalEvent = src;
  		this.type = src.type;

  		// Events bubbling up the document may have been marked as prevented
  		// by a handler lower down the tree; reflect the correct value.
  		this.isDefaultPrevented = src.defaultPrevented ||
  				src.defaultPrevented === undefined &&

  				// Support: Android <=2.3 only
  				src.returnValue === false ?
  			returnTrue :
  			returnFalse;

  		// Create target properties
  		// Support: Safari <=6 - 7 only
  		// Target should not be a text node (#504, #13143)
  		this.target = ( src.target && src.target.nodeType === 3 ) ?
  			src.target.parentNode :
  			src.target;

  		this.currentTarget = src.currentTarget;
  		this.relatedTarget = src.relatedTarget;

  	// Event type
  	} else {
  		this.type = src;
  	}

  	// Put explicitly provided properties onto the event object
  	if ( props ) {
  		jQuery.extend( this, props );
  	}

  	// Create a timestamp if incoming event doesn't have one
  	this.timeStamp = src && src.timeStamp || Date.now();

  	// Mark it as fixed
  	this[ jQuery.expando ] = true;
  };

  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  jQuery.Event.prototype = {
  	constructor: jQuery.Event,
  	isDefaultPrevented: returnFalse,
  	isPropagationStopped: returnFalse,
  	isImmediatePropagationStopped: returnFalse,
  	isSimulated: false,

  	preventDefault: function() {
  		var e = this.originalEvent;

  		this.isDefaultPrevented = returnTrue;

  		if ( e && !this.isSimulated ) {
  			e.preventDefault();
  		}
  	},
  	stopPropagation: function() {
  		var e = this.originalEvent;

  		this.isPropagationStopped = returnTrue;

  		if ( e && !this.isSimulated ) {
  			e.stopPropagation();
  		}
  	},
  	stopImmediatePropagation: function() {
  		var e = this.originalEvent;

  		this.isImmediatePropagationStopped = returnTrue;

  		if ( e && !this.isSimulated ) {
  			e.stopImmediatePropagation();
  		}

  		this.stopPropagation();
  	}
  };

  // Includes all common event props including KeyEvent and MouseEvent specific props
  jQuery.each( {
  	altKey: true,
  	bubbles: true,
  	cancelable: true,
  	changedTouches: true,
  	ctrlKey: true,
  	detail: true,
  	eventPhase: true,
  	metaKey: true,
  	pageX: true,
  	pageY: true,
  	shiftKey: true,
  	view: true,
  	"char": true,
  	charCode: true,
  	key: true,
  	keyCode: true,
  	button: true,
  	buttons: true,
  	clientX: true,
  	clientY: true,
  	offsetX: true,
  	offsetY: true,
  	pointerId: true,
  	pointerType: true,
  	screenX: true,
  	screenY: true,
  	targetTouches: true,
  	toElement: true,
  	touches: true,

  	which: function( event ) {
  		var button = event.button;

  		// Add which for key events
  		if ( event.which == null && rkeyEvent.test( event.type ) ) {
  			return event.charCode != null ? event.charCode : event.keyCode;
  		}

  		// Add which for click: 1 === left; 2 === middle; 3 === right
  		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
  			if ( button & 1 ) {
  				return 1;
  			}

  			if ( button & 2 ) {
  				return 3;
  			}

  			if ( button & 4 ) {
  				return 2;
  			}

  			return 0;
  		}

  		return event.which;
  	}
  }, jQuery.event.addProp );

  // Create mouseenter/leave events using mouseover/out and event-time checks
  // so that event delegation works in jQuery.
  // Do the same for pointerenter/pointerleave and pointerover/pointerout
  //
  // Support: Safari 7 only
  // Safari sends mouseenter too often; see:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
  // for the description of the bug (it existed in older Chrome versions as well).
  jQuery.each( {
  	mouseenter: "mouseover",
  	mouseleave: "mouseout",
  	pointerenter: "pointerover",
  	pointerleave: "pointerout"
  }, function( orig, fix ) {
  	jQuery.event.special[ orig ] = {
  		delegateType: fix,
  		bindType: fix,

  		handle: function( event ) {
  			var ret,
  				target = this,
  				related = event.relatedTarget,
  				handleObj = event.handleObj;

  			// For mouseenter/leave call the handler if related is outside the target.
  			// NB: No relatedTarget if the mouse left/entered the browser window
  			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
  				event.type = handleObj.origType;
  				ret = handleObj.handler.apply( this, arguments );
  				event.type = fix;
  			}
  			return ret;
  		}
  	};
  } );

  jQuery.fn.extend( {

  	on: function( types, selector, data, fn ) {
  		return on( this, types, selector, data, fn );
  	},
  	one: function( types, selector, data, fn ) {
  		return on( this, types, selector, data, fn, 1 );
  	},
  	off: function( types, selector, fn ) {
  		var handleObj, type;
  		if ( types && types.preventDefault && types.handleObj ) {

  			// ( event )  dispatched jQuery.Event
  			handleObj = types.handleObj;
  			jQuery( types.delegateTarget ).off(
  				handleObj.namespace ?
  					handleObj.origType + "." + handleObj.namespace :
  					handleObj.origType,
  				handleObj.selector,
  				handleObj.handler
  			);
  			return this;
  		}
  		if ( typeof types === "object" ) {

  			// ( types-object [, selector] )
  			for ( type in types ) {
  				this.off( type, selector, types[ type ] );
  			}
  			return this;
  		}
  		if ( selector === false || typeof selector === "function" ) {

  			// ( types [, fn] )
  			fn = selector;
  			selector = undefined;
  		}
  		if ( fn === false ) {
  			fn = returnFalse;
  		}
  		return this.each( function() {
  			jQuery.event.remove( this, types, fn, selector );
  		} );
  	}
  } );


  var

  	/* eslint-disable max-len */

  	// See https://github.com/eslint/eslint/issues/3229
  	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

  	/* eslint-enable */

  	// Support: IE <=10 - 11, Edge 12 - 13 only
  	// In IE/Edge using regex groups here causes severe slowdowns.
  	// See https://connect.microsoft.com/IE/feedback/details/1736512/
  	rnoInnerhtml = /<script|<style|<link/i,

  	// checked="checked" or checked
  	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
  	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

  // Prefer a tbody over its parent table for containing new rows
  function manipulationTarget( elem, content ) {
  	if ( nodeName( elem, "table" ) &&
  		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

  		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
  	}

  	return elem;
  }

  // Replace/restore the type attribute of script elements for safe DOM manipulation
  function disableScript( elem ) {
  	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
  	return elem;
  }
  function restoreScript( elem ) {
  	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
  		elem.type = elem.type.slice( 5 );
  	} else {
  		elem.removeAttribute( "type" );
  	}

  	return elem;
  }

  function cloneCopyEvent( src, dest ) {
  	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

  	if ( dest.nodeType !== 1 ) {
  		return;
  	}

  	// 1. Copy private data: events, handlers, etc.
  	if ( dataPriv.hasData( src ) ) {
  		pdataOld = dataPriv.access( src );
  		pdataCur = dataPriv.set( dest, pdataOld );
  		events = pdataOld.events;

  		if ( events ) {
  			delete pdataCur.handle;
  			pdataCur.events = {};

  			for ( type in events ) {
  				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
  					jQuery.event.add( dest, type, events[ type ][ i ] );
  				}
  			}
  		}
  	}

  	// 2. Copy user data
  	if ( dataUser.hasData( src ) ) {
  		udataOld = dataUser.access( src );
  		udataCur = jQuery.extend( {}, udataOld );

  		dataUser.set( dest, udataCur );
  	}
  }

  // Fix IE bugs, see support tests
  function fixInput( src, dest ) {
  	var nodeName = dest.nodeName.toLowerCase();

  	// Fails to persist the checked state of a cloned checkbox or radio button.
  	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
  		dest.checked = src.checked;

  	// Fails to return the selected option to the default selected state when cloning options
  	} else if ( nodeName === "input" || nodeName === "textarea" ) {
  		dest.defaultValue = src.defaultValue;
  	}
  }

  function domManip( collection, args, callback, ignored ) {

  	// Flatten any nested arrays
  	args = concat.apply( [], args );

  	var fragment, first, scripts, hasScripts, node, doc,
  		i = 0,
  		l = collection.length,
  		iNoClone = l - 1,
  		value = args[ 0 ],
  		valueIsFunction = isFunction( value );

  	// We can't cloneNode fragments that contain checked, in WebKit
  	if ( valueIsFunction ||
  			( l > 1 && typeof value === "string" &&
  				!support.checkClone && rchecked.test( value ) ) ) {
  		return collection.each( function( index ) {
  			var self = collection.eq( index );
  			if ( valueIsFunction ) {
  				args[ 0 ] = value.call( this, index, self.html() );
  			}
  			domManip( self, args, callback, ignored );
  		} );
  	}

  	if ( l ) {
  		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
  		first = fragment.firstChild;

  		if ( fragment.childNodes.length === 1 ) {
  			fragment = first;
  		}

  		// Require either new content or an interest in ignored elements to invoke the callback
  		if ( first || ignored ) {
  			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
  			hasScripts = scripts.length;

  			// Use the original fragment for the last item
  			// instead of the first because it can end up
  			// being emptied incorrectly in certain situations (#8070).
  			for ( ; i < l; i++ ) {
  				node = fragment;

  				if ( i !== iNoClone ) {
  					node = jQuery.clone( node, true, true );

  					// Keep references to cloned scripts for later restoration
  					if ( hasScripts ) {

  						// Support: Android <=4.0 only, PhantomJS 1 only
  						// push.apply(_, arraylike) throws on ancient WebKit
  						jQuery.merge( scripts, getAll( node, "script" ) );
  					}
  				}

  				callback.call( collection[ i ], node, i );
  			}

  			if ( hasScripts ) {
  				doc = scripts[ scripts.length - 1 ].ownerDocument;

  				// Reenable scripts
  				jQuery.map( scripts, restoreScript );

  				// Evaluate executable scripts on first document insertion
  				for ( i = 0; i < hasScripts; i++ ) {
  					node = scripts[ i ];
  					if ( rscriptType.test( node.type || "" ) &&
  						!dataPriv.access( node, "globalEval" ) &&
  						jQuery.contains( doc, node ) ) {

  						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

  							// Optional AJAX dependency, but won't run scripts if not present
  							if ( jQuery._evalUrl ) {
  								jQuery._evalUrl( node.src );
  							}
  						} else {
  							DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
  						}
  					}
  				}
  			}
  		}
  	}

  	return collection;
  }

  function remove( elem, selector, keepData ) {
  	var node,
  		nodes = selector ? jQuery.filter( selector, elem ) : elem,
  		i = 0;

  	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
  		if ( !keepData && node.nodeType === 1 ) {
  			jQuery.cleanData( getAll( node ) );
  		}

  		if ( node.parentNode ) {
  			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
  				setGlobalEval( getAll( node, "script" ) );
  			}
  			node.parentNode.removeChild( node );
  		}
  	}

  	return elem;
  }

  jQuery.extend( {
  	htmlPrefilter: function( html ) {
  		return html.replace( rxhtmlTag, "<$1></$2>" );
  	},

  	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
  		var i, l, srcElements, destElements,
  			clone = elem.cloneNode( true ),
  			inPage = jQuery.contains( elem.ownerDocument, elem );

  		// Fix IE cloning issues
  		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
  				!jQuery.isXMLDoc( elem ) ) {

  			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
  			destElements = getAll( clone );
  			srcElements = getAll( elem );

  			for ( i = 0, l = srcElements.length; i < l; i++ ) {
  				fixInput( srcElements[ i ], destElements[ i ] );
  			}
  		}

  		// Copy the events from the original to the clone
  		if ( dataAndEvents ) {
  			if ( deepDataAndEvents ) {
  				srcElements = srcElements || getAll( elem );
  				destElements = destElements || getAll( clone );

  				for ( i = 0, l = srcElements.length; i < l; i++ ) {
  					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
  				}
  			} else {
  				cloneCopyEvent( elem, clone );
  			}
  		}

  		// Preserve script evaluation history
  		destElements = getAll( clone, "script" );
  		if ( destElements.length > 0 ) {
  			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
  		}

  		// Return the cloned set
  		return clone;
  	},

  	cleanData: function( elems ) {
  		var data, elem, type,
  			special = jQuery.event.special,
  			i = 0;

  		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
  			if ( acceptData( elem ) ) {
  				if ( ( data = elem[ dataPriv.expando ] ) ) {
  					if ( data.events ) {
  						for ( type in data.events ) {
  							if ( special[ type ] ) {
  								jQuery.event.remove( elem, type );

  							// This is a shortcut to avoid jQuery.event.remove's overhead
  							} else {
  								jQuery.removeEvent( elem, type, data.handle );
  							}
  						}
  					}

  					// Support: Chrome <=35 - 45+
  					// Assign undefined instead of using delete, see Data#remove
  					elem[ dataPriv.expando ] = undefined;
  				}
  				if ( elem[ dataUser.expando ] ) {

  					// Support: Chrome <=35 - 45+
  					// Assign undefined instead of using delete, see Data#remove
  					elem[ dataUser.expando ] = undefined;
  				}
  			}
  		}
  	}
  } );

  jQuery.fn.extend( {
  	detach: function( selector ) {
  		return remove( this, selector, true );
  	},

  	remove: function( selector ) {
  		return remove( this, selector );
  	},

  	text: function( value ) {
  		return access( this, function( value ) {
  			return value === undefined ?
  				jQuery.text( this ) :
  				this.empty().each( function() {
  					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  						this.textContent = value;
  					}
  				} );
  		}, null, value, arguments.length );
  	},

  	append: function() {
  		return domManip( this, arguments, function( elem ) {
  			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  				var target = manipulationTarget( this, elem );
  				target.appendChild( elem );
  			}
  		} );
  	},

  	prepend: function() {
  		return domManip( this, arguments, function( elem ) {
  			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
  				var target = manipulationTarget( this, elem );
  				target.insertBefore( elem, target.firstChild );
  			}
  		} );
  	},

  	before: function() {
  		return domManip( this, arguments, function( elem ) {
  			if ( this.parentNode ) {
  				this.parentNode.insertBefore( elem, this );
  			}
  		} );
  	},

  	after: function() {
  		return domManip( this, arguments, function( elem ) {
  			if ( this.parentNode ) {
  				this.parentNode.insertBefore( elem, this.nextSibling );
  			}
  		} );
  	},

  	empty: function() {
  		var elem,
  			i = 0;

  		for ( ; ( elem = this[ i ] ) != null; i++ ) {
  			if ( elem.nodeType === 1 ) {

  				// Prevent memory leaks
  				jQuery.cleanData( getAll( elem, false ) );

  				// Remove any remaining nodes
  				elem.textContent = "";
  			}
  		}

  		return this;
  	},

  	clone: function( dataAndEvents, deepDataAndEvents ) {
  		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
  		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

  		return this.map( function() {
  			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
  		} );
  	},

  	html: function( value ) {
  		return access( this, function( value ) {
  			var elem = this[ 0 ] || {},
  				i = 0,
  				l = this.length;

  			if ( value === undefined && elem.nodeType === 1 ) {
  				return elem.innerHTML;
  			}

  			// See if we can take a shortcut and just use innerHTML
  			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
  				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

  				value = jQuery.htmlPrefilter( value );

  				try {
  					for ( ; i < l; i++ ) {
  						elem = this[ i ] || {};

  						// Remove element nodes and prevent memory leaks
  						if ( elem.nodeType === 1 ) {
  							jQuery.cleanData( getAll( elem, false ) );
  							elem.innerHTML = value;
  						}
  					}

  					elem = 0;

  				// If using innerHTML throws an exception, use the fallback method
  				} catch ( e ) {}
  			}

  			if ( elem ) {
  				this.empty().append( value );
  			}
  		}, null, value, arguments.length );
  	},

  	replaceWith: function() {
  		var ignored = [];

  		// Make the changes, replacing each non-ignored context element with the new content
  		return domManip( this, arguments, function( elem ) {
  			var parent = this.parentNode;

  			if ( jQuery.inArray( this, ignored ) < 0 ) {
  				jQuery.cleanData( getAll( this ) );
  				if ( parent ) {
  					parent.replaceChild( elem, this );
  				}
  			}

  		// Force callback invocation
  		}, ignored );
  	}
  } );

  jQuery.each( {
  	appendTo: "append",
  	prependTo: "prepend",
  	insertBefore: "before",
  	insertAfter: "after",
  	replaceAll: "replaceWith"
  }, function( name, original ) {
  	jQuery.fn[ name ] = function( selector ) {
  		var elems,
  			ret = [],
  			insert = jQuery( selector ),
  			last = insert.length - 1,
  			i = 0;

  		for ( ; i <= last; i++ ) {
  			elems = i === last ? this : this.clone( true );
  			jQuery( insert[ i ] )[ original ]( elems );

  			// Support: Android <=4.0 only, PhantomJS 1 only
  			// .get() because push.apply(_, arraylike) throws on ancient WebKit
  			push.apply( ret, elems.get() );
  		}

  		return this.pushStack( ret );
  	};
  } );
  var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

  var getStyles = function( elem ) {

  		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
  		// IE throws on elements created in popups
  		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
  		var view = elem.ownerDocument.defaultView;

  		if ( !view || !view.opener ) {
  			view = window;
  		}

  		return view.getComputedStyle( elem );
  	};

  var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



  ( function() {

  	// Executing both pixelPosition & boxSizingReliable tests require only one layout
  	// so they're executed at the same time to save the second computation.
  	function computeStyleTests() {

  		// This is a singleton, we need to execute it only once
  		if ( !div ) {
  			return;
  		}

  		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
  			"margin-top:1px;padding:0;border:0";
  		div.style.cssText =
  			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
  			"margin:auto;border:1px;padding:1px;" +
  			"width:60%;top:1%";
  		documentElement.appendChild( container ).appendChild( div );

  		var divStyle = window.getComputedStyle( div );
  		pixelPositionVal = divStyle.top !== "1%";

  		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
  		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

  		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
  		// Some styles come back with percentage values, even though they shouldn't
  		div.style.right = "60%";
  		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

  		// Support: IE 9 - 11 only
  		// Detect misreporting of content dimensions for box-sizing:border-box elements
  		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

  		// Support: IE 9 only
  		// Detect overflow:scroll screwiness (gh-3699)
  		div.style.position = "absolute";
  		scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

  		documentElement.removeChild( container );

  		// Nullify the div so it wouldn't be stored in the memory and
  		// it will also be a sign that checks already performed
  		div = null;
  	}

  	function roundPixelMeasures( measure ) {
  		return Math.round( parseFloat( measure ) );
  	}

  	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
  		reliableMarginLeftVal,
  		container = document.createElement( "div" ),
  		div = document.createElement( "div" );

  	// Finish early in limited (non-browser) environments
  	if ( !div.style ) {
  		return;
  	}

  	// Support: IE <=9 - 11 only
  	// Style of cloned element affects source element cloned (#8908)
  	div.style.backgroundClip = "content-box";
  	div.cloneNode( true ).style.backgroundClip = "";
  	support.clearCloneStyle = div.style.backgroundClip === "content-box";

  	jQuery.extend( support, {
  		boxSizingReliable: function() {
  			computeStyleTests();
  			return boxSizingReliableVal;
  		},
  		pixelBoxStyles: function() {
  			computeStyleTests();
  			return pixelBoxStylesVal;
  		},
  		pixelPosition: function() {
  			computeStyleTests();
  			return pixelPositionVal;
  		},
  		reliableMarginLeft: function() {
  			computeStyleTests();
  			return reliableMarginLeftVal;
  		},
  		scrollboxSize: function() {
  			computeStyleTests();
  			return scrollboxSizeVal;
  		}
  	} );
  } )();


  function curCSS( elem, name, computed ) {
  	var width, minWidth, maxWidth, ret,

  		// Support: Firefox 51+
  		// Retrieving style before computed somehow
  		// fixes an issue with getting wrong values
  		// on detached elements
  		style = elem.style;

  	computed = computed || getStyles( elem );

  	// getPropertyValue is needed for:
  	//   .css('filter') (IE 9 only, #12537)
  	//   .css('--customProperty) (#3144)
  	if ( computed ) {
  		ret = computed.getPropertyValue( name ) || computed[ name ];

  		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
  			ret = jQuery.style( elem, name );
  		}

  		// A tribute to the "awesome hack by Dean Edwards"
  		// Android Browser returns percentage for some values,
  		// but width seems to be reliably pixels.
  		// This is against the CSSOM draft spec:
  		// https://drafts.csswg.org/cssom/#resolved-values
  		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

  			// Remember the original values
  			width = style.width;
  			minWidth = style.minWidth;
  			maxWidth = style.maxWidth;

  			// Put in the new values to get a computed value out
  			style.minWidth = style.maxWidth = style.width = ret;
  			ret = computed.width;

  			// Revert the changed values
  			style.width = width;
  			style.minWidth = minWidth;
  			style.maxWidth = maxWidth;
  		}
  	}

  	return ret !== undefined ?

  		// Support: IE <=9 - 11 only
  		// IE returns zIndex value as an integer.
  		ret + "" :
  		ret;
  }


  function addGetHookIf( conditionFn, hookFn ) {

  	// Define the hook, we'll check on the first run if it's really needed.
  	return {
  		get: function() {
  			if ( conditionFn() ) {

  				// Hook not needed (or it's not possible to use it due
  				// to missing dependency), remove it.
  				delete this.get;
  				return;
  			}

  			// Hook needed; redefine it so that the support test is not executed again.
  			return ( this.get = hookFn ).apply( this, arguments );
  		}
  	};
  }


  var

  	// Swappable if display is none or starts with table
  	// except "table", "table-cell", or "table-caption"
  	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
  	rcustomProp = /^--/,
  	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
  	cssNormalTransform = {
  		letterSpacing: "0",
  		fontWeight: "400"
  	},

  	cssPrefixes = [ "Webkit", "Moz", "ms" ],
  	emptyStyle = document.createElement( "div" ).style;

  // Return a css property mapped to a potentially vendor prefixed property
  function vendorPropName( name ) {

  	// Shortcut for names that are not vendor prefixed
  	if ( name in emptyStyle ) {
  		return name;
  	}

  	// Check for vendor prefixed names
  	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
  		i = cssPrefixes.length;

  	while ( i-- ) {
  		name = cssPrefixes[ i ] + capName;
  		if ( name in emptyStyle ) {
  			return name;
  		}
  	}
  }

  // Return a property mapped along what jQuery.cssProps suggests or to
  // a vendor prefixed property.
  function finalPropName( name ) {
  	var ret = jQuery.cssProps[ name ];
  	if ( !ret ) {
  		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
  	}
  	return ret;
  }

  function setPositiveNumber( elem, value, subtract ) {

  	// Any relative (+/-) values have already been
  	// normalized at this point
  	var matches = rcssNum.exec( value );
  	return matches ?

  		// Guard against undefined "subtract", e.g., when used as in cssHooks
  		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
  		value;
  }

  function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
  	var i = dimension === "width" ? 1 : 0,
  		extra = 0,
  		delta = 0;

  	// Adjustment may not be necessary
  	if ( box === ( isBorderBox ? "border" : "content" ) ) {
  		return 0;
  	}

  	for ( ; i < 4; i += 2 ) {

  		// Both box models exclude margin
  		if ( box === "margin" ) {
  			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
  		}

  		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
  		if ( !isBorderBox ) {

  			// Add padding
  			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

  			// For "border" or "margin", add border
  			if ( box !== "padding" ) {
  				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

  			// But still keep track of it otherwise
  			} else {
  				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
  			}

  		// If we get here with a border-box (content + padding + border), we're seeking "content" or
  		// "padding" or "margin"
  		} else {

  			// For "content", subtract padding
  			if ( box === "content" ) {
  				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
  			}

  			// For "content" or "padding", subtract border
  			if ( box !== "margin" ) {
  				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
  			}
  		}
  	}

  	// Account for positive content-box scroll gutter when requested by providing computedVal
  	if ( !isBorderBox && computedVal >= 0 ) {

  		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
  		// Assuming integer scroll gutter, subtract the rest and round down
  		delta += Math.max( 0, Math.ceil(
  			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
  			computedVal -
  			delta -
  			extra -
  			0.5
  		) );
  	}

  	return delta;
  }

  function getWidthOrHeight( elem, dimension, extra ) {

  	// Start with computed style
  	var styles = getStyles( elem ),
  		val = curCSS( elem, dimension, styles ),
  		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
  		valueIsBorderBox = isBorderBox;

  	// Support: Firefox <=54
  	// Return a confounding non-pixel value or feign ignorance, as appropriate.
  	if ( rnumnonpx.test( val ) ) {
  		if ( !extra ) {
  			return val;
  		}
  		val = "auto";
  	}

  	// Check for style in case a browser which returns unreliable values
  	// for getComputedStyle silently falls back to the reliable elem.style
  	valueIsBorderBox = valueIsBorderBox &&
  		( support.boxSizingReliable() || val === elem.style[ dimension ] );

  	// Fall back to offsetWidth/offsetHeight when value is "auto"
  	// This happens for inline elements with no explicit setting (gh-3571)
  	// Support: Android <=4.1 - 4.3 only
  	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
  	if ( val === "auto" ||
  		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

  		val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

  		// offsetWidth/offsetHeight provide border-box values
  		valueIsBorderBox = true;
  	}

  	// Normalize "" and auto
  	val = parseFloat( val ) || 0;

  	// Adjust for the element's box model
  	return ( val +
  		boxModelAdjustment(
  			elem,
  			dimension,
  			extra || ( isBorderBox ? "border" : "content" ),
  			valueIsBorderBox,
  			styles,

  			// Provide the current computed size to request scroll gutter calculation (gh-3589)
  			val
  		)
  	) + "px";
  }

  jQuery.extend( {

  	// Add in style property hooks for overriding the default
  	// behavior of getting and setting a style property
  	cssHooks: {
  		opacity: {
  			get: function( elem, computed ) {
  				if ( computed ) {

  					// We should always get a number back from opacity
  					var ret = curCSS( elem, "opacity" );
  					return ret === "" ? "1" : ret;
  				}
  			}
  		}
  	},

  	// Don't automatically add "px" to these possibly-unitless properties
  	cssNumber: {
  		"animationIterationCount": true,
  		"columnCount": true,
  		"fillOpacity": true,
  		"flexGrow": true,
  		"flexShrink": true,
  		"fontWeight": true,
  		"lineHeight": true,
  		"opacity": true,
  		"order": true,
  		"orphans": true,
  		"widows": true,
  		"zIndex": true,
  		"zoom": true
  	},

  	// Add in properties whose names you wish to fix before
  	// setting or getting the value
  	cssProps: {},

  	// Get and set the style property on a DOM Node
  	style: function( elem, name, value, extra ) {

  		// Don't set styles on text and comment nodes
  		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
  			return;
  		}

  		// Make sure that we're working with the right name
  		var ret, type, hooks,
  			origName = camelCase( name ),
  			isCustomProp = rcustomProp.test( name ),
  			style = elem.style;

  		// Make sure that we're working with the right name. We don't
  		// want to query the value if it is a CSS custom property
  		// since they are user-defined.
  		if ( !isCustomProp ) {
  			name = finalPropName( origName );
  		}

  		// Gets hook for the prefixed version, then unprefixed version
  		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

  		// Check if we're setting a value
  		if ( value !== undefined ) {
  			type = typeof value;

  			// Convert "+=" or "-=" to relative numbers (#7345)
  			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
  				value = adjustCSS( elem, name, ret );

  				// Fixes bug #9237
  				type = "number";
  			}

  			// Make sure that null and NaN values aren't set (#7116)
  			if ( value == null || value !== value ) {
  				return;
  			}

  			// If a number was passed in, add the unit (except for certain CSS properties)
  			if ( type === "number" ) {
  				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
  			}

  			// background-* props affect original clone's values
  			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
  				style[ name ] = "inherit";
  			}

  			// If a hook was provided, use that value, otherwise just set the specified value
  			if ( !hooks || !( "set" in hooks ) ||
  				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

  				if ( isCustomProp ) {
  					style.setProperty( name, value );
  				} else {
  					style[ name ] = value;
  				}
  			}

  		} else {

  			// If a hook was provided get the non-computed value from there
  			if ( hooks && "get" in hooks &&
  				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

  				return ret;
  			}

  			// Otherwise just get the value from the style object
  			return style[ name ];
  		}
  	},

  	css: function( elem, name, extra, styles ) {
  		var val, num, hooks,
  			origName = camelCase( name ),
  			isCustomProp = rcustomProp.test( name );

  		// Make sure that we're working with the right name. We don't
  		// want to modify the value if it is a CSS custom property
  		// since they are user-defined.
  		if ( !isCustomProp ) {
  			name = finalPropName( origName );
  		}

  		// Try prefixed name followed by the unprefixed name
  		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

  		// If a hook was provided get the computed value from there
  		if ( hooks && "get" in hooks ) {
  			val = hooks.get( elem, true, extra );
  		}

  		// Otherwise, if a way to get the computed value exists, use that
  		if ( val === undefined ) {
  			val = curCSS( elem, name, styles );
  		}

  		// Convert "normal" to computed value
  		if ( val === "normal" && name in cssNormalTransform ) {
  			val = cssNormalTransform[ name ];
  		}

  		// Make numeric if forced or a qualifier was provided and val looks numeric
  		if ( extra === "" || extra ) {
  			num = parseFloat( val );
  			return extra === true || isFinite( num ) ? num || 0 : val;
  		}

  		return val;
  	}
  } );

  jQuery.each( [ "height", "width" ], function( i, dimension ) {
  	jQuery.cssHooks[ dimension ] = {
  		get: function( elem, computed, extra ) {
  			if ( computed ) {

  				// Certain elements can have dimension info if we invisibly show them
  				// but it must have a current display style that would benefit
  				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

  					// Support: Safari 8+
  					// Table columns in Safari have non-zero offsetWidth & zero
  					// getBoundingClientRect().width unless display is changed.
  					// Support: IE <=11 only
  					// Running getBoundingClientRect on a disconnected node
  					// in IE throws an error.
  					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
  						swap( elem, cssShow, function() {
  							return getWidthOrHeight( elem, dimension, extra );
  						} ) :
  						getWidthOrHeight( elem, dimension, extra );
  			}
  		},

  		set: function( elem, value, extra ) {
  			var matches,
  				styles = getStyles( elem ),
  				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
  				subtract = extra && boxModelAdjustment(
  					elem,
  					dimension,
  					extra,
  					isBorderBox,
  					styles
  				);

  			// Account for unreliable border-box dimensions by comparing offset* to computed and
  			// faking a content-box to get border and padding (gh-3699)
  			if ( isBorderBox && support.scrollboxSize() === styles.position ) {
  				subtract -= Math.ceil(
  					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
  					parseFloat( styles[ dimension ] ) -
  					boxModelAdjustment( elem, dimension, "border", false, styles ) -
  					0.5
  				);
  			}

  			// Convert to pixels if value adjustment is needed
  			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
  				( matches[ 3 ] || "px" ) !== "px" ) {

  				elem.style[ dimension ] = value;
  				value = jQuery.css( elem, dimension );
  			}

  			return setPositiveNumber( elem, value, subtract );
  		}
  	};
  } );

  jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
  	function( elem, computed ) {
  		if ( computed ) {
  			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
  				elem.getBoundingClientRect().left -
  					swap( elem, { marginLeft: 0 }, function() {
  						return elem.getBoundingClientRect().left;
  					} )
  				) + "px";
  		}
  	}
  );

  // These hooks are used by animate to expand properties
  jQuery.each( {
  	margin: "",
  	padding: "",
  	border: "Width"
  }, function( prefix, suffix ) {
  	jQuery.cssHooks[ prefix + suffix ] = {
  		expand: function( value ) {
  			var i = 0,
  				expanded = {},

  				// Assumes a single number if not a string
  				parts = typeof value === "string" ? value.split( " " ) : [ value ];

  			for ( ; i < 4; i++ ) {
  				expanded[ prefix + cssExpand[ i ] + suffix ] =
  					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
  			}

  			return expanded;
  		}
  	};

  	if ( prefix !== "margin" ) {
  		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
  	}
  } );

  jQuery.fn.extend( {
  	css: function( name, value ) {
  		return access( this, function( elem, name, value ) {
  			var styles, len,
  				map = {},
  				i = 0;

  			if ( Array.isArray( name ) ) {
  				styles = getStyles( elem );
  				len = name.length;

  				for ( ; i < len; i++ ) {
  					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
  				}

  				return map;
  			}

  			return value !== undefined ?
  				jQuery.style( elem, name, value ) :
  				jQuery.css( elem, name );
  		}, name, value, arguments.length > 1 );
  	}
  } );


  function Tween( elem, options, prop, end, easing ) {
  	return new Tween.prototype.init( elem, options, prop, end, easing );
  }
  jQuery.Tween = Tween;

  Tween.prototype = {
  	constructor: Tween,
  	init: function( elem, options, prop, end, easing, unit ) {
  		this.elem = elem;
  		this.prop = prop;
  		this.easing = easing || jQuery.easing._default;
  		this.options = options;
  		this.start = this.now = this.cur();
  		this.end = end;
  		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
  	},
  	cur: function() {
  		var hooks = Tween.propHooks[ this.prop ];

  		return hooks && hooks.get ?
  			hooks.get( this ) :
  			Tween.propHooks._default.get( this );
  	},
  	run: function( percent ) {
  		var eased,
  			hooks = Tween.propHooks[ this.prop ];

  		if ( this.options.duration ) {
  			this.pos = eased = jQuery.easing[ this.easing ](
  				percent, this.options.duration * percent, 0, 1, this.options.duration
  			);
  		} else {
  			this.pos = eased = percent;
  		}
  		this.now = ( this.end - this.start ) * eased + this.start;

  		if ( this.options.step ) {
  			this.options.step.call( this.elem, this.now, this );
  		}

  		if ( hooks && hooks.set ) {
  			hooks.set( this );
  		} else {
  			Tween.propHooks._default.set( this );
  		}
  		return this;
  	}
  };

  Tween.prototype.init.prototype = Tween.prototype;

  Tween.propHooks = {
  	_default: {
  		get: function( tween ) {
  			var result;

  			// Use a property on the element directly when it is not a DOM element,
  			// or when there is no matching style property that exists.
  			if ( tween.elem.nodeType !== 1 ||
  				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
  				return tween.elem[ tween.prop ];
  			}

  			// Passing an empty string as a 3rd parameter to .css will automatically
  			// attempt a parseFloat and fallback to a string if the parse fails.
  			// Simple values such as "10px" are parsed to Float;
  			// complex values such as "rotate(1rad)" are returned as-is.
  			result = jQuery.css( tween.elem, tween.prop, "" );

  			// Empty strings, null, undefined and "auto" are converted to 0.
  			return !result || result === "auto" ? 0 : result;
  		},
  		set: function( tween ) {

  			// Use step hook for back compat.
  			// Use cssHook if its there.
  			// Use .style if available and use plain properties where available.
  			if ( jQuery.fx.step[ tween.prop ] ) {
  				jQuery.fx.step[ tween.prop ]( tween );
  			} else if ( tween.elem.nodeType === 1 &&
  				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
  					jQuery.cssHooks[ tween.prop ] ) ) {
  				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
  			} else {
  				tween.elem[ tween.prop ] = tween.now;
  			}
  		}
  	}
  };

  // Support: IE <=9 only
  // Panic based approach to setting things on disconnected nodes
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
  	set: function( tween ) {
  		if ( tween.elem.nodeType && tween.elem.parentNode ) {
  			tween.elem[ tween.prop ] = tween.now;
  		}
  	}
  };

  jQuery.easing = {
  	linear: function( p ) {
  		return p;
  	},
  	swing: function( p ) {
  		return 0.5 - Math.cos( p * Math.PI ) / 2;
  	},
  	_default: "swing"
  };

  jQuery.fx = Tween.prototype.init;

  // Back compat <1.8 extension point
  jQuery.fx.step = {};




  var
  	fxNow, inProgress,
  	rfxtypes = /^(?:toggle|show|hide)$/,
  	rrun = /queueHooks$/;

  function schedule() {
  	if ( inProgress ) {
  		if ( document.hidden === false && window.requestAnimationFrame ) {
  			window.requestAnimationFrame( schedule );
  		} else {
  			window.setTimeout( schedule, jQuery.fx.interval );
  		}

  		jQuery.fx.tick();
  	}
  }

  // Animations created synchronously will run synchronously
  function createFxNow() {
  	window.setTimeout( function() {
  		fxNow = undefined;
  	} );
  	return ( fxNow = Date.now() );
  }

  // Generate parameters to create a standard animation
  function genFx( type, includeWidth ) {
  	var which,
  		i = 0,
  		attrs = { height: type };

  	// If we include width, step value is 1 to do all cssExpand values,
  	// otherwise step value is 2 to skip over Left and Right
  	includeWidth = includeWidth ? 1 : 0;
  	for ( ; i < 4; i += 2 - includeWidth ) {
  		which = cssExpand[ i ];
  		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
  	}

  	if ( includeWidth ) {
  		attrs.opacity = attrs.width = type;
  	}

  	return attrs;
  }

  function createTween( value, prop, animation ) {
  	var tween,
  		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
  		index = 0,
  		length = collection.length;
  	for ( ; index < length; index++ ) {
  		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

  			// We're done with this property
  			return tween;
  		}
  	}
  }

  function defaultPrefilter( elem, props, opts ) {
  	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
  		isBox = "width" in props || "height" in props,
  		anim = this,
  		orig = {},
  		style = elem.style,
  		hidden = elem.nodeType && isHiddenWithinTree( elem ),
  		dataShow = dataPriv.get( elem, "fxshow" );

  	// Queue-skipping animations hijack the fx hooks
  	if ( !opts.queue ) {
  		hooks = jQuery._queueHooks( elem, "fx" );
  		if ( hooks.unqueued == null ) {
  			hooks.unqueued = 0;
  			oldfire = hooks.empty.fire;
  			hooks.empty.fire = function() {
  				if ( !hooks.unqueued ) {
  					oldfire();
  				}
  			};
  		}
  		hooks.unqueued++;

  		anim.always( function() {

  			// Ensure the complete handler is called before this completes
  			anim.always( function() {
  				hooks.unqueued--;
  				if ( !jQuery.queue( elem, "fx" ).length ) {
  					hooks.empty.fire();
  				}
  			} );
  		} );
  	}

  	// Detect show/hide animations
  	for ( prop in props ) {
  		value = props[ prop ];
  		if ( rfxtypes.test( value ) ) {
  			delete props[ prop ];
  			toggle = toggle || value === "toggle";
  			if ( value === ( hidden ? "hide" : "show" ) ) {

  				// Pretend to be hidden if this is a "show" and
  				// there is still data from a stopped show/hide
  				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
  					hidden = true;

  				// Ignore all other no-op show/hide data
  				} else {
  					continue;
  				}
  			}
  			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
  		}
  	}

  	// Bail out if this is a no-op like .hide().hide()
  	propTween = !jQuery.isEmptyObject( props );
  	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
  		return;
  	}

  	// Restrict "overflow" and "display" styles during box animations
  	if ( isBox && elem.nodeType === 1 ) {

  		// Support: IE <=9 - 11, Edge 12 - 15
  		// Record all 3 overflow attributes because IE does not infer the shorthand
  		// from identically-valued overflowX and overflowY and Edge just mirrors
  		// the overflowX value there.
  		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

  		// Identify a display type, preferring old show/hide data over the CSS cascade
  		restoreDisplay = dataShow && dataShow.display;
  		if ( restoreDisplay == null ) {
  			restoreDisplay = dataPriv.get( elem, "display" );
  		}
  		display = jQuery.css( elem, "display" );
  		if ( display === "none" ) {
  			if ( restoreDisplay ) {
  				display = restoreDisplay;
  			} else {

  				// Get nonempty value(s) by temporarily forcing visibility
  				showHide( [ elem ], true );
  				restoreDisplay = elem.style.display || restoreDisplay;
  				display = jQuery.css( elem, "display" );
  				showHide( [ elem ] );
  			}
  		}

  		// Animate inline elements as inline-block
  		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
  			if ( jQuery.css( elem, "float" ) === "none" ) {

  				// Restore the original display value at the end of pure show/hide animations
  				if ( !propTween ) {
  					anim.done( function() {
  						style.display = restoreDisplay;
  					} );
  					if ( restoreDisplay == null ) {
  						display = style.display;
  						restoreDisplay = display === "none" ? "" : display;
  					}
  				}
  				style.display = "inline-block";
  			}
  		}
  	}

  	if ( opts.overflow ) {
  		style.overflow = "hidden";
  		anim.always( function() {
  			style.overflow = opts.overflow[ 0 ];
  			style.overflowX = opts.overflow[ 1 ];
  			style.overflowY = opts.overflow[ 2 ];
  		} );
  	}

  	// Implement show/hide animations
  	propTween = false;
  	for ( prop in orig ) {

  		// General show/hide setup for this element animation
  		if ( !propTween ) {
  			if ( dataShow ) {
  				if ( "hidden" in dataShow ) {
  					hidden = dataShow.hidden;
  				}
  			} else {
  				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
  			}

  			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
  			if ( toggle ) {
  				dataShow.hidden = !hidden;
  			}

  			// Show elements before animating them
  			if ( hidden ) {
  				showHide( [ elem ], true );
  			}

  			/* eslint-disable no-loop-func */

  			anim.done( function() {

  			/* eslint-enable no-loop-func */

  				// The final step of a "hide" animation is actually hiding the element
  				if ( !hidden ) {
  					showHide( [ elem ] );
  				}
  				dataPriv.remove( elem, "fxshow" );
  				for ( prop in orig ) {
  					jQuery.style( elem, prop, orig[ prop ] );
  				}
  			} );
  		}

  		// Per-property setup
  		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
  		if ( !( prop in dataShow ) ) {
  			dataShow[ prop ] = propTween.start;
  			if ( hidden ) {
  				propTween.end = propTween.start;
  				propTween.start = 0;
  			}
  		}
  	}
  }

  function propFilter( props, specialEasing ) {
  	var index, name, easing, value, hooks;

  	// camelCase, specialEasing and expand cssHook pass
  	for ( index in props ) {
  		name = camelCase( index );
  		easing = specialEasing[ name ];
  		value = props[ index ];
  		if ( Array.isArray( value ) ) {
  			easing = value[ 1 ];
  			value = props[ index ] = value[ 0 ];
  		}

  		if ( index !== name ) {
  			props[ name ] = value;
  			delete props[ index ];
  		}

  		hooks = jQuery.cssHooks[ name ];
  		if ( hooks && "expand" in hooks ) {
  			value = hooks.expand( value );
  			delete props[ name ];

  			// Not quite $.extend, this won't overwrite existing keys.
  			// Reusing 'index' because we have the correct "name"
  			for ( index in value ) {
  				if ( !( index in props ) ) {
  					props[ index ] = value[ index ];
  					specialEasing[ index ] = easing;
  				}
  			}
  		} else {
  			specialEasing[ name ] = easing;
  		}
  	}
  }

  function Animation( elem, properties, options ) {
  	var result,
  		stopped,
  		index = 0,
  		length = Animation.prefilters.length,
  		deferred = jQuery.Deferred().always( function() {

  			// Don't match elem in the :animated selector
  			delete tick.elem;
  		} ),
  		tick = function() {
  			if ( stopped ) {
  				return false;
  			}
  			var currentTime = fxNow || createFxNow(),
  				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

  				// Support: Android 2.3 only
  				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
  				temp = remaining / animation.duration || 0,
  				percent = 1 - temp,
  				index = 0,
  				length = animation.tweens.length;

  			for ( ; index < length; index++ ) {
  				animation.tweens[ index ].run( percent );
  			}

  			deferred.notifyWith( elem, [ animation, percent, remaining ] );

  			// If there's more to do, yield
  			if ( percent < 1 && length ) {
  				return remaining;
  			}

  			// If this was an empty animation, synthesize a final progress notification
  			if ( !length ) {
  				deferred.notifyWith( elem, [ animation, 1, 0 ] );
  			}

  			// Resolve the animation and report its conclusion
  			deferred.resolveWith( elem, [ animation ] );
  			return false;
  		},
  		animation = deferred.promise( {
  			elem: elem,
  			props: jQuery.extend( {}, properties ),
  			opts: jQuery.extend( true, {
  				specialEasing: {},
  				easing: jQuery.easing._default
  			}, options ),
  			originalProperties: properties,
  			originalOptions: options,
  			startTime: fxNow || createFxNow(),
  			duration: options.duration,
  			tweens: [],
  			createTween: function( prop, end ) {
  				var tween = jQuery.Tween( elem, animation.opts, prop, end,
  						animation.opts.specialEasing[ prop ] || animation.opts.easing );
  				animation.tweens.push( tween );
  				return tween;
  			},
  			stop: function( gotoEnd ) {
  				var index = 0,

  					// If we are going to the end, we want to run all the tweens
  					// otherwise we skip this part
  					length = gotoEnd ? animation.tweens.length : 0;
  				if ( stopped ) {
  					return this;
  				}
  				stopped = true;
  				for ( ; index < length; index++ ) {
  					animation.tweens[ index ].run( 1 );
  				}

  				// Resolve when we played the last frame; otherwise, reject
  				if ( gotoEnd ) {
  					deferred.notifyWith( elem, [ animation, 1, 0 ] );
  					deferred.resolveWith( elem, [ animation, gotoEnd ] );
  				} else {
  					deferred.rejectWith( elem, [ animation, gotoEnd ] );
  				}
  				return this;
  			}
  		} ),
  		props = animation.props;

  	propFilter( props, animation.opts.specialEasing );

  	for ( ; index < length; index++ ) {
  		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
  		if ( result ) {
  			if ( isFunction( result.stop ) ) {
  				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
  					result.stop.bind( result );
  			}
  			return result;
  		}
  	}

  	jQuery.map( props, createTween, animation );

  	if ( isFunction( animation.opts.start ) ) {
  		animation.opts.start.call( elem, animation );
  	}

  	// Attach callbacks from options
  	animation
  		.progress( animation.opts.progress )
  		.done( animation.opts.done, animation.opts.complete )
  		.fail( animation.opts.fail )
  		.always( animation.opts.always );

  	jQuery.fx.timer(
  		jQuery.extend( tick, {
  			elem: elem,
  			anim: animation,
  			queue: animation.opts.queue
  		} )
  	);

  	return animation;
  }

  jQuery.Animation = jQuery.extend( Animation, {

  	tweeners: {
  		"*": [ function( prop, value ) {
  			var tween = this.createTween( prop, value );
  			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
  			return tween;
  		} ]
  	},

  	tweener: function( props, callback ) {
  		if ( isFunction( props ) ) {
  			callback = props;
  			props = [ "*" ];
  		} else {
  			props = props.match( rnothtmlwhite );
  		}

  		var prop,
  			index = 0,
  			length = props.length;

  		for ( ; index < length; index++ ) {
  			prop = props[ index ];
  			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
  			Animation.tweeners[ prop ].unshift( callback );
  		}
  	},

  	prefilters: [ defaultPrefilter ],

  	prefilter: function( callback, prepend ) {
  		if ( prepend ) {
  			Animation.prefilters.unshift( callback );
  		} else {
  			Animation.prefilters.push( callback );
  		}
  	}
  } );

  jQuery.speed = function( speed, easing, fn ) {
  	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
  		complete: fn || !fn && easing ||
  			isFunction( speed ) && speed,
  		duration: speed,
  		easing: fn && easing || easing && !isFunction( easing ) && easing
  	};

  	// Go to the end state if fx are off
  	if ( jQuery.fx.off ) {
  		opt.duration = 0;

  	} else {
  		if ( typeof opt.duration !== "number" ) {
  			if ( opt.duration in jQuery.fx.speeds ) {
  				opt.duration = jQuery.fx.speeds[ opt.duration ];

  			} else {
  				opt.duration = jQuery.fx.speeds._default;
  			}
  		}
  	}

  	// Normalize opt.queue - true/undefined/null -> "fx"
  	if ( opt.queue == null || opt.queue === true ) {
  		opt.queue = "fx";
  	}

  	// Queueing
  	opt.old = opt.complete;

  	opt.complete = function() {
  		if ( isFunction( opt.old ) ) {
  			opt.old.call( this );
  		}

  		if ( opt.queue ) {
  			jQuery.dequeue( this, opt.queue );
  		}
  	};

  	return opt;
  };

  jQuery.fn.extend( {
  	fadeTo: function( speed, to, easing, callback ) {

  		// Show any hidden elements after setting opacity to 0
  		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

  			// Animate to the value specified
  			.end().animate( { opacity: to }, speed, easing, callback );
  	},
  	animate: function( prop, speed, easing, callback ) {
  		var empty = jQuery.isEmptyObject( prop ),
  			optall = jQuery.speed( speed, easing, callback ),
  			doAnimation = function() {

  				// Operate on a copy of prop so per-property easing won't be lost
  				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

  				// Empty animations, or finishing resolves immediately
  				if ( empty || dataPriv.get( this, "finish" ) ) {
  					anim.stop( true );
  				}
  			};
  			doAnimation.finish = doAnimation;

  		return empty || optall.queue === false ?
  			this.each( doAnimation ) :
  			this.queue( optall.queue, doAnimation );
  	},
  	stop: function( type, clearQueue, gotoEnd ) {
  		var stopQueue = function( hooks ) {
  			var stop = hooks.stop;
  			delete hooks.stop;
  			stop( gotoEnd );
  		};

  		if ( typeof type !== "string" ) {
  			gotoEnd = clearQueue;
  			clearQueue = type;
  			type = undefined;
  		}
  		if ( clearQueue && type !== false ) {
  			this.queue( type || "fx", [] );
  		}

  		return this.each( function() {
  			var dequeue = true,
  				index = type != null && type + "queueHooks",
  				timers = jQuery.timers,
  				data = dataPriv.get( this );

  			if ( index ) {
  				if ( data[ index ] && data[ index ].stop ) {
  					stopQueue( data[ index ] );
  				}
  			} else {
  				for ( index in data ) {
  					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
  						stopQueue( data[ index ] );
  					}
  				}
  			}

  			for ( index = timers.length; index--; ) {
  				if ( timers[ index ].elem === this &&
  					( type == null || timers[ index ].queue === type ) ) {

  					timers[ index ].anim.stop( gotoEnd );
  					dequeue = false;
  					timers.splice( index, 1 );
  				}
  			}

  			// Start the next in the queue if the last step wasn't forced.
  			// Timers currently will call their complete callbacks, which
  			// will dequeue but only if they were gotoEnd.
  			if ( dequeue || !gotoEnd ) {
  				jQuery.dequeue( this, type );
  			}
  		} );
  	},
  	finish: function( type ) {
  		if ( type !== false ) {
  			type = type || "fx";
  		}
  		return this.each( function() {
  			var index,
  				data = dataPriv.get( this ),
  				queue = data[ type + "queue" ],
  				hooks = data[ type + "queueHooks" ],
  				timers = jQuery.timers,
  				length = queue ? queue.length : 0;

  			// Enable finishing flag on private data
  			data.finish = true;

  			// Empty the queue first
  			jQuery.queue( this, type, [] );

  			if ( hooks && hooks.stop ) {
  				hooks.stop.call( this, true );
  			}

  			// Look for any active animations, and finish them
  			for ( index = timers.length; index--; ) {
  				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
  					timers[ index ].anim.stop( true );
  					timers.splice( index, 1 );
  				}
  			}

  			// Look for any animations in the old queue and finish them
  			for ( index = 0; index < length; index++ ) {
  				if ( queue[ index ] && queue[ index ].finish ) {
  					queue[ index ].finish.call( this );
  				}
  			}

  			// Turn off finishing flag
  			delete data.finish;
  		} );
  	}
  } );

  jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
  	var cssFn = jQuery.fn[ name ];
  	jQuery.fn[ name ] = function( speed, easing, callback ) {
  		return speed == null || typeof speed === "boolean" ?
  			cssFn.apply( this, arguments ) :
  			this.animate( genFx( name, true ), speed, easing, callback );
  	};
  } );

  // Generate shortcuts for custom animations
  jQuery.each( {
  	slideDown: genFx( "show" ),
  	slideUp: genFx( "hide" ),
  	slideToggle: genFx( "toggle" ),
  	fadeIn: { opacity: "show" },
  	fadeOut: { opacity: "hide" },
  	fadeToggle: { opacity: "toggle" }
  }, function( name, props ) {
  	jQuery.fn[ name ] = function( speed, easing, callback ) {
  		return this.animate( props, speed, easing, callback );
  	};
  } );

  jQuery.timers = [];
  jQuery.fx.tick = function() {
  	var timer,
  		i = 0,
  		timers = jQuery.timers;

  	fxNow = Date.now();

  	for ( ; i < timers.length; i++ ) {
  		timer = timers[ i ];

  		// Run the timer and safely remove it when done (allowing for external removal)
  		if ( !timer() && timers[ i ] === timer ) {
  			timers.splice( i--, 1 );
  		}
  	}

  	if ( !timers.length ) {
  		jQuery.fx.stop();
  	}
  	fxNow = undefined;
  };

  jQuery.fx.timer = function( timer ) {
  	jQuery.timers.push( timer );
  	jQuery.fx.start();
  };

  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
  	if ( inProgress ) {
  		return;
  	}

  	inProgress = true;
  	schedule();
  };

  jQuery.fx.stop = function() {
  	inProgress = null;
  };

  jQuery.fx.speeds = {
  	slow: 600,
  	fast: 200,

  	// Default speed
  	_default: 400
  };


  // Based off of the plugin by Clint Helfers, with permission.
  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
  jQuery.fn.delay = function( time, type ) {
  	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
  	type = type || "fx";

  	return this.queue( type, function( next, hooks ) {
  		var timeout = window.setTimeout( next, time );
  		hooks.stop = function() {
  			window.clearTimeout( timeout );
  		};
  	} );
  };


  ( function() {
  	var input = document.createElement( "input" ),
  		select = document.createElement( "select" ),
  		opt = select.appendChild( document.createElement( "option" ) );

  	input.type = "checkbox";

  	// Support: Android <=4.3 only
  	// Default value for a checkbox should be "on"
  	support.checkOn = input.value !== "";

  	// Support: IE <=11 only
  	// Must access selectedIndex to make default options select
  	support.optSelected = opt.selected;

  	// Support: IE <=11 only
  	// An input loses its value after becoming a radio
  	input = document.createElement( "input" );
  	input.value = "t";
  	input.type = "radio";
  	support.radioValue = input.value === "t";
  } )();


  var boolHook,
  	attrHandle = jQuery.expr.attrHandle;

  jQuery.fn.extend( {
  	attr: function( name, value ) {
  		return access( this, jQuery.attr, name, value, arguments.length > 1 );
  	},

  	removeAttr: function( name ) {
  		return this.each( function() {
  			jQuery.removeAttr( this, name );
  		} );
  	}
  } );

  jQuery.extend( {
  	attr: function( elem, name, value ) {
  		var ret, hooks,
  			nType = elem.nodeType;

  		// Don't get/set attributes on text, comment and attribute nodes
  		if ( nType === 3 || nType === 8 || nType === 2 ) {
  			return;
  		}

  		// Fallback to prop when attributes are not supported
  		if ( typeof elem.getAttribute === "undefined" ) {
  			return jQuery.prop( elem, name, value );
  		}

  		// Attribute hooks are determined by the lowercase version
  		// Grab necessary hook if one is defined
  		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
  			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
  				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
  		}

  		if ( value !== undefined ) {
  			if ( value === null ) {
  				jQuery.removeAttr( elem, name );
  				return;
  			}

  			if ( hooks && "set" in hooks &&
  				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
  				return ret;
  			}

  			elem.setAttribute( name, value + "" );
  			return value;
  		}

  		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
  			return ret;
  		}

  		ret = jQuery.find.attr( elem, name );

  		// Non-existent attributes return null, we normalize to undefined
  		return ret == null ? undefined : ret;
  	},

  	attrHooks: {
  		type: {
  			set: function( elem, value ) {
  				if ( !support.radioValue && value === "radio" &&
  					nodeName( elem, "input" ) ) {
  					var val = elem.value;
  					elem.setAttribute( "type", value );
  					if ( val ) {
  						elem.value = val;
  					}
  					return value;
  				}
  			}
  		}
  	},

  	removeAttr: function( elem, value ) {
  		var name,
  			i = 0,

  			// Attribute names can contain non-HTML whitespace characters
  			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
  			attrNames = value && value.match( rnothtmlwhite );

  		if ( attrNames && elem.nodeType === 1 ) {
  			while ( ( name = attrNames[ i++ ] ) ) {
  				elem.removeAttribute( name );
  			}
  		}
  	}
  } );

  // Hooks for boolean attributes
  boolHook = {
  	set: function( elem, value, name ) {
  		if ( value === false ) {

  			// Remove boolean attributes when set to false
  			jQuery.removeAttr( elem, name );
  		} else {
  			elem.setAttribute( name, name );
  		}
  		return name;
  	}
  };

  jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
  	var getter = attrHandle[ name ] || jQuery.find.attr;

  	attrHandle[ name ] = function( elem, name, isXML ) {
  		var ret, handle,
  			lowercaseName = name.toLowerCase();

  		if ( !isXML ) {

  			// Avoid an infinite loop by temporarily removing this function from the getter
  			handle = attrHandle[ lowercaseName ];
  			attrHandle[ lowercaseName ] = ret;
  			ret = getter( elem, name, isXML ) != null ?
  				lowercaseName :
  				null;
  			attrHandle[ lowercaseName ] = handle;
  		}
  		return ret;
  	};
  } );




  var rfocusable = /^(?:input|select|textarea|button)$/i,
  	rclickable = /^(?:a|area)$/i;

  jQuery.fn.extend( {
  	prop: function( name, value ) {
  		return access( this, jQuery.prop, name, value, arguments.length > 1 );
  	},

  	removeProp: function( name ) {
  		return this.each( function() {
  			delete this[ jQuery.propFix[ name ] || name ];
  		} );
  	}
  } );

  jQuery.extend( {
  	prop: function( elem, name, value ) {
  		var ret, hooks,
  			nType = elem.nodeType;

  		// Don't get/set properties on text, comment and attribute nodes
  		if ( nType === 3 || nType === 8 || nType === 2 ) {
  			return;
  		}

  		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

  			// Fix name and attach hooks
  			name = jQuery.propFix[ name ] || name;
  			hooks = jQuery.propHooks[ name ];
  		}

  		if ( value !== undefined ) {
  			if ( hooks && "set" in hooks &&
  				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
  				return ret;
  			}

  			return ( elem[ name ] = value );
  		}

  		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
  			return ret;
  		}

  		return elem[ name ];
  	},

  	propHooks: {
  		tabIndex: {
  			get: function( elem ) {

  				// Support: IE <=9 - 11 only
  				// elem.tabIndex doesn't always return the
  				// correct value when it hasn't been explicitly set
  				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
  				// Use proper attribute retrieval(#12072)
  				var tabindex = jQuery.find.attr( elem, "tabindex" );

  				if ( tabindex ) {
  					return parseInt( tabindex, 10 );
  				}

  				if (
  					rfocusable.test( elem.nodeName ) ||
  					rclickable.test( elem.nodeName ) &&
  					elem.href
  				) {
  					return 0;
  				}

  				return -1;
  			}
  		}
  	},

  	propFix: {
  		"for": "htmlFor",
  		"class": "className"
  	}
  } );

  // Support: IE <=11 only
  // Accessing the selectedIndex property
  // forces the browser to respect setting selected
  // on the option
  // The getter ensures a default option is selected
  // when in an optgroup
  // eslint rule "no-unused-expressions" is disabled for this code
  // since it considers such accessions noop
  if ( !support.optSelected ) {
  	jQuery.propHooks.selected = {
  		get: function( elem ) {

  			/* eslint no-unused-expressions: "off" */

  			var parent = elem.parentNode;
  			if ( parent && parent.parentNode ) {
  				parent.parentNode.selectedIndex;
  			}
  			return null;
  		},
  		set: function( elem ) {

  			/* eslint no-unused-expressions: "off" */

  			var parent = elem.parentNode;
  			if ( parent ) {
  				parent.selectedIndex;

  				if ( parent.parentNode ) {
  					parent.parentNode.selectedIndex;
  				}
  			}
  		}
  	};
  }

  jQuery.each( [
  	"tabIndex",
  	"readOnly",
  	"maxLength",
  	"cellSpacing",
  	"cellPadding",
  	"rowSpan",
  	"colSpan",
  	"useMap",
  	"frameBorder",
  	"contentEditable"
  ], function() {
  	jQuery.propFix[ this.toLowerCase() ] = this;
  } );




  	// Strip and collapse whitespace according to HTML spec
  	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
  	function stripAndCollapse( value ) {
  		var tokens = value.match( rnothtmlwhite ) || [];
  		return tokens.join( " " );
  	}


  function getClass( elem ) {
  	return elem.getAttribute && elem.getAttribute( "class" ) || "";
  }

  function classesToArray( value ) {
  	if ( Array.isArray( value ) ) {
  		return value;
  	}
  	if ( typeof value === "string" ) {
  		return value.match( rnothtmlwhite ) || [];
  	}
  	return [];
  }

  jQuery.fn.extend( {
  	addClass: function( value ) {
  		var classes, elem, cur, curValue, clazz, j, finalValue,
  			i = 0;

  		if ( isFunction( value ) ) {
  			return this.each( function( j ) {
  				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
  			} );
  		}

  		classes = classesToArray( value );

  		if ( classes.length ) {
  			while ( ( elem = this[ i++ ] ) ) {
  				curValue = getClass( elem );
  				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

  				if ( cur ) {
  					j = 0;
  					while ( ( clazz = classes[ j++ ] ) ) {
  						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
  							cur += clazz + " ";
  						}
  					}

  					// Only assign if different to avoid unneeded rendering.
  					finalValue = stripAndCollapse( cur );
  					if ( curValue !== finalValue ) {
  						elem.setAttribute( "class", finalValue );
  					}
  				}
  			}
  		}

  		return this;
  	},

  	removeClass: function( value ) {
  		var classes, elem, cur, curValue, clazz, j, finalValue,
  			i = 0;

  		if ( isFunction( value ) ) {
  			return this.each( function( j ) {
  				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
  			} );
  		}

  		if ( !arguments.length ) {
  			return this.attr( "class", "" );
  		}

  		classes = classesToArray( value );

  		if ( classes.length ) {
  			while ( ( elem = this[ i++ ] ) ) {
  				curValue = getClass( elem );

  				// This expression is here for better compressibility (see addClass)
  				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

  				if ( cur ) {
  					j = 0;
  					while ( ( clazz = classes[ j++ ] ) ) {

  						// Remove *all* instances
  						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
  							cur = cur.replace( " " + clazz + " ", " " );
  						}
  					}

  					// Only assign if different to avoid unneeded rendering.
  					finalValue = stripAndCollapse( cur );
  					if ( curValue !== finalValue ) {
  						elem.setAttribute( "class", finalValue );
  					}
  				}
  			}
  		}

  		return this;
  	},

  	toggleClass: function( value, stateVal ) {
  		var type = typeof value,
  			isValidValue = type === "string" || Array.isArray( value );

  		if ( typeof stateVal === "boolean" && isValidValue ) {
  			return stateVal ? this.addClass( value ) : this.removeClass( value );
  		}

  		if ( isFunction( value ) ) {
  			return this.each( function( i ) {
  				jQuery( this ).toggleClass(
  					value.call( this, i, getClass( this ), stateVal ),
  					stateVal
  				);
  			} );
  		}

  		return this.each( function() {
  			var className, i, self, classNames;

  			if ( isValidValue ) {

  				// Toggle individual class names
  				i = 0;
  				self = jQuery( this );
  				classNames = classesToArray( value );

  				while ( ( className = classNames[ i++ ] ) ) {

  					// Check each className given, space separated list
  					if ( self.hasClass( className ) ) {
  						self.removeClass( className );
  					} else {
  						self.addClass( className );
  					}
  				}

  			// Toggle whole class name
  			} else if ( value === undefined || type === "boolean" ) {
  				className = getClass( this );
  				if ( className ) {

  					// Store className if set
  					dataPriv.set( this, "__className__", className );
  				}

  				// If the element has a class name or if we're passed `false`,
  				// then remove the whole classname (if there was one, the above saved it).
  				// Otherwise bring back whatever was previously saved (if anything),
  				// falling back to the empty string if nothing was stored.
  				if ( this.setAttribute ) {
  					this.setAttribute( "class",
  						className || value === false ?
  						"" :
  						dataPriv.get( this, "__className__" ) || ""
  					);
  				}
  			}
  		} );
  	},

  	hasClass: function( selector ) {
  		var className, elem,
  			i = 0;

  		className = " " + selector + " ";
  		while ( ( elem = this[ i++ ] ) ) {
  			if ( elem.nodeType === 1 &&
  				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
  					return true;
  			}
  		}

  		return false;
  	}
  } );




  var rreturn = /\r/g;

  jQuery.fn.extend( {
  	val: function( value ) {
  		var hooks, ret, valueIsFunction,
  			elem = this[ 0 ];

  		if ( !arguments.length ) {
  			if ( elem ) {
  				hooks = jQuery.valHooks[ elem.type ] ||
  					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

  				if ( hooks &&
  					"get" in hooks &&
  					( ret = hooks.get( elem, "value" ) ) !== undefined
  				) {
  					return ret;
  				}

  				ret = elem.value;

  				// Handle most common string cases
  				if ( typeof ret === "string" ) {
  					return ret.replace( rreturn, "" );
  				}

  				// Handle cases where value is null/undef or number
  				return ret == null ? "" : ret;
  			}

  			return;
  		}

  		valueIsFunction = isFunction( value );

  		return this.each( function( i ) {
  			var val;

  			if ( this.nodeType !== 1 ) {
  				return;
  			}

  			if ( valueIsFunction ) {
  				val = value.call( this, i, jQuery( this ).val() );
  			} else {
  				val = value;
  			}

  			// Treat null/undefined as ""; convert numbers to string
  			if ( val == null ) {
  				val = "";

  			} else if ( typeof val === "number" ) {
  				val += "";

  			} else if ( Array.isArray( val ) ) {
  				val = jQuery.map( val, function( value ) {
  					return value == null ? "" : value + "";
  				} );
  			}

  			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

  			// If set returns undefined, fall back to normal setting
  			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
  				this.value = val;
  			}
  		} );
  	}
  } );

  jQuery.extend( {
  	valHooks: {
  		option: {
  			get: function( elem ) {

  				var val = jQuery.find.attr( elem, "value" );
  				return val != null ?
  					val :

  					// Support: IE <=10 - 11 only
  					// option.text throws exceptions (#14686, #14858)
  					// Strip and collapse whitespace
  					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
  					stripAndCollapse( jQuery.text( elem ) );
  			}
  		},
  		select: {
  			get: function( elem ) {
  				var value, option, i,
  					options = elem.options,
  					index = elem.selectedIndex,
  					one = elem.type === "select-one",
  					values = one ? null : [],
  					max = one ? index + 1 : options.length;

  				if ( index < 0 ) {
  					i = max;

  				} else {
  					i = one ? index : 0;
  				}

  				// Loop through all the selected options
  				for ( ; i < max; i++ ) {
  					option = options[ i ];

  					// Support: IE <=9 only
  					// IE8-9 doesn't update selected after form reset (#2551)
  					if ( ( option.selected || i === index ) &&

  							// Don't return options that are disabled or in a disabled optgroup
  							!option.disabled &&
  							( !option.parentNode.disabled ||
  								!nodeName( option.parentNode, "optgroup" ) ) ) {

  						// Get the specific value for the option
  						value = jQuery( option ).val();

  						// We don't need an array for one selects
  						if ( one ) {
  							return value;
  						}

  						// Multi-Selects return an array
  						values.push( value );
  					}
  				}

  				return values;
  			},

  			set: function( elem, value ) {
  				var optionSet, option,
  					options = elem.options,
  					values = jQuery.makeArray( value ),
  					i = options.length;

  				while ( i-- ) {
  					option = options[ i ];

  					/* eslint-disable no-cond-assign */

  					if ( option.selected =
  						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
  					) {
  						optionSet = true;
  					}

  					/* eslint-enable no-cond-assign */
  				}

  				// Force browsers to behave consistently when non-matching value is set
  				if ( !optionSet ) {
  					elem.selectedIndex = -1;
  				}
  				return values;
  			}
  		}
  	}
  } );

  // Radios and checkboxes getter/setter
  jQuery.each( [ "radio", "checkbox" ], function() {
  	jQuery.valHooks[ this ] = {
  		set: function( elem, value ) {
  			if ( Array.isArray( value ) ) {
  				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
  			}
  		}
  	};
  	if ( !support.checkOn ) {
  		jQuery.valHooks[ this ].get = function( elem ) {
  			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
  		};
  	}
  } );




  // Return jQuery for attributes-only inclusion


  support.focusin = "onfocusin" in window;


  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
  	stopPropagationCallback = function( e ) {
  		e.stopPropagation();
  	};

  jQuery.extend( jQuery.event, {

  	trigger: function( event, data, elem, onlyHandlers ) {

  		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
  			eventPath = [ elem || document ],
  			type = hasOwn.call( event, "type" ) ? event.type : event,
  			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

  		cur = lastElement = tmp = elem = elem || document;

  		// Don't do events on text and comment nodes
  		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
  			return;
  		}

  		// focus/blur morphs to focusin/out; ensure we're not firing them right now
  		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
  			return;
  		}

  		if ( type.indexOf( "." ) > -1 ) {

  			// Namespaced trigger; create a regexp to match event type in handle()
  			namespaces = type.split( "." );
  			type = namespaces.shift();
  			namespaces.sort();
  		}
  		ontype = type.indexOf( ":" ) < 0 && "on" + type;

  		// Caller can pass in a jQuery.Event object, Object, or just an event type string
  		event = event[ jQuery.expando ] ?
  			event :
  			new jQuery.Event( type, typeof event === "object" && event );

  		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
  		event.isTrigger = onlyHandlers ? 2 : 3;
  		event.namespace = namespaces.join( "." );
  		event.rnamespace = event.namespace ?
  			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
  			null;

  		// Clean up the event in case it is being reused
  		event.result = undefined;
  		if ( !event.target ) {
  			event.target = elem;
  		}

  		// Clone any incoming data and prepend the event, creating the handler arg list
  		data = data == null ?
  			[ event ] :
  			jQuery.makeArray( data, [ event ] );

  		// Allow special events to draw outside the lines
  		special = jQuery.event.special[ type ] || {};
  		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
  			return;
  		}

  		// Determine event propagation path in advance, per W3C events spec (#9951)
  		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
  		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

  			bubbleType = special.delegateType || type;
  			if ( !rfocusMorph.test( bubbleType + type ) ) {
  				cur = cur.parentNode;
  			}
  			for ( ; cur; cur = cur.parentNode ) {
  				eventPath.push( cur );
  				tmp = cur;
  			}

  			// Only add window if we got to document (e.g., not plain obj or detached DOM)
  			if ( tmp === ( elem.ownerDocument || document ) ) {
  				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
  			}
  		}

  		// Fire handlers on the event path
  		i = 0;
  		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
  			lastElement = cur;
  			event.type = i > 1 ?
  				bubbleType :
  				special.bindType || type;

  			// jQuery handler
  			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
  				dataPriv.get( cur, "handle" );
  			if ( handle ) {
  				handle.apply( cur, data );
  			}

  			// Native handler
  			handle = ontype && cur[ ontype ];
  			if ( handle && handle.apply && acceptData( cur ) ) {
  				event.result = handle.apply( cur, data );
  				if ( event.result === false ) {
  					event.preventDefault();
  				}
  			}
  		}
  		event.type = type;

  		// If nobody prevented the default action, do it now
  		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

  			if ( ( !special._default ||
  				special._default.apply( eventPath.pop(), data ) === false ) &&
  				acceptData( elem ) ) {

  				// Call a native DOM method on the target with the same name as the event.
  				// Don't do default actions on window, that's where global variables be (#6170)
  				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

  					// Don't re-trigger an onFOO event when we call its FOO() method
  					tmp = elem[ ontype ];

  					if ( tmp ) {
  						elem[ ontype ] = null;
  					}

  					// Prevent re-triggering of the same event, since we already bubbled it above
  					jQuery.event.triggered = type;

  					if ( event.isPropagationStopped() ) {
  						lastElement.addEventListener( type, stopPropagationCallback );
  					}

  					elem[ type ]();

  					if ( event.isPropagationStopped() ) {
  						lastElement.removeEventListener( type, stopPropagationCallback );
  					}

  					jQuery.event.triggered = undefined;

  					if ( tmp ) {
  						elem[ ontype ] = tmp;
  					}
  				}
  			}
  		}

  		return event.result;
  	},

  	// Piggyback on a donor event to simulate a different one
  	// Used only for `focus(in | out)` events
  	simulate: function( type, elem, event ) {
  		var e = jQuery.extend(
  			new jQuery.Event(),
  			event,
  			{
  				type: type,
  				isSimulated: true
  			}
  		);

  		jQuery.event.trigger( e, null, elem );
  	}

  } );

  jQuery.fn.extend( {

  	trigger: function( type, data ) {
  		return this.each( function() {
  			jQuery.event.trigger( type, data, this );
  		} );
  	},
  	triggerHandler: function( type, data ) {
  		var elem = this[ 0 ];
  		if ( elem ) {
  			return jQuery.event.trigger( type, data, elem, true );
  		}
  	}
  } );


  // Support: Firefox <=44
  // Firefox doesn't have focus(in | out) events
  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  //
  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
  // focus(in | out) events fire after focus & blur events,
  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
  if ( !support.focusin ) {
  	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

  		// Attach a single capturing handler on the document while someone wants focusin/focusout
  		var handler = function( event ) {
  			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
  		};

  		jQuery.event.special[ fix ] = {
  			setup: function() {
  				var doc = this.ownerDocument || this,
  					attaches = dataPriv.access( doc, fix );

  				if ( !attaches ) {
  					doc.addEventListener( orig, handler, true );
  				}
  				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
  			},
  			teardown: function() {
  				var doc = this.ownerDocument || this,
  					attaches = dataPriv.access( doc, fix ) - 1;

  				if ( !attaches ) {
  					doc.removeEventListener( orig, handler, true );
  					dataPriv.remove( doc, fix );

  				} else {
  					dataPriv.access( doc, fix, attaches );
  				}
  			}
  		};
  	} );
  }
  var location = window.location;

  var nonce = Date.now();

  var rquery = ( /\?/ );



  // Cross-browser xml parsing
  jQuery.parseXML = function( data ) {
  	var xml;
  	if ( !data || typeof data !== "string" ) {
  		return null;
  	}

  	// Support: IE 9 - 11 only
  	// IE throws on parseFromString with invalid input.
  	try {
  		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
  	} catch ( e ) {
  		xml = undefined;
  	}

  	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
  		jQuery.error( "Invalid XML: " + data );
  	}
  	return xml;
  };


  var
  	rbracket = /\[\]$/,
  	rCRLF = /\r?\n/g,
  	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
  	rsubmittable = /^(?:input|select|textarea|keygen)/i;

  function buildParams( prefix, obj, traditional, add ) {
  	var name;

  	if ( Array.isArray( obj ) ) {

  		// Serialize array item.
  		jQuery.each( obj, function( i, v ) {
  			if ( traditional || rbracket.test( prefix ) ) {

  				// Treat each array item as a scalar.
  				add( prefix, v );

  			} else {

  				// Item is non-scalar (array or object), encode its numeric index.
  				buildParams(
  					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
  					v,
  					traditional,
  					add
  				);
  			}
  		} );

  	} else if ( !traditional && toType( obj ) === "object" ) {

  		// Serialize object item.
  		for ( name in obj ) {
  			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
  		}

  	} else {

  		// Serialize scalar item.
  		add( prefix, obj );
  	}
  }

  // Serialize an array of form elements or a set of
  // key/values into a query string
  jQuery.param = function( a, traditional ) {
  	var prefix,
  		s = [],
  		add = function( key, valueOrFunction ) {

  			// If value is a function, invoke it and use its return value
  			var value = isFunction( valueOrFunction ) ?
  				valueOrFunction() :
  				valueOrFunction;

  			s[ s.length ] = encodeURIComponent( key ) + "=" +
  				encodeURIComponent( value == null ? "" : value );
  		};

  	// If an array was passed in, assume that it is an array of form elements.
  	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

  		// Serialize the form elements
  		jQuery.each( a, function() {
  			add( this.name, this.value );
  		} );

  	} else {

  		// If traditional, encode the "old" way (the way 1.3.2 or older
  		// did it), otherwise encode params recursively.
  		for ( prefix in a ) {
  			buildParams( prefix, a[ prefix ], traditional, add );
  		}
  	}

  	// Return the resulting serialization
  	return s.join( "&" );
  };

  jQuery.fn.extend( {
  	serialize: function() {
  		return jQuery.param( this.serializeArray() );
  	},
  	serializeArray: function() {
  		return this.map( function() {

  			// Can add propHook for "elements" to filter or add form elements
  			var elements = jQuery.prop( this, "elements" );
  			return elements ? jQuery.makeArray( elements ) : this;
  		} )
  		.filter( function() {
  			var type = this.type;

  			// Use .is( ":disabled" ) so that fieldset[disabled] works
  			return this.name && !jQuery( this ).is( ":disabled" ) &&
  				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
  				( this.checked || !rcheckableType.test( type ) );
  		} )
  		.map( function( i, elem ) {
  			var val = jQuery( this ).val();

  			if ( val == null ) {
  				return null;
  			}

  			if ( Array.isArray( val ) ) {
  				return jQuery.map( val, function( val ) {
  					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
  				} );
  			}

  			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
  		} ).get();
  	}
  } );


  var
  	r20 = /%20/g,
  	rhash = /#.*$/,
  	rantiCache = /([?&])_=[^&]*/,
  	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

  	// #7653, #8125, #8152: local protocol detection
  	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
  	rnoContent = /^(?:GET|HEAD)$/,
  	rprotocol = /^\/\//,

  	/* Prefilters
  	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
  	 * 2) These are called:
  	 *    - BEFORE asking for a transport
  	 *    - AFTER param serialization (s.data is a string if s.processData is true)
  	 * 3) key is the dataType
  	 * 4) the catchall symbol "*" can be used
  	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
  	 */
  	prefilters = {},

  	/* Transports bindings
  	 * 1) key is the dataType
  	 * 2) the catchall symbol "*" can be used
  	 * 3) selection will start with transport dataType and THEN go to "*" if needed
  	 */
  	transports = {},

  	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
  	allTypes = "*/".concat( "*" ),

  	// Anchor tag for parsing the document origin
  	originAnchor = document.createElement( "a" );
  	originAnchor.href = location.href;

  // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
  function addToPrefiltersOrTransports( structure ) {

  	// dataTypeExpression is optional and defaults to "*"
  	return function( dataTypeExpression, func ) {

  		if ( typeof dataTypeExpression !== "string" ) {
  			func = dataTypeExpression;
  			dataTypeExpression = "*";
  		}

  		var dataType,
  			i = 0,
  			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

  		if ( isFunction( func ) ) {

  			// For each dataType in the dataTypeExpression
  			while ( ( dataType = dataTypes[ i++ ] ) ) {

  				// Prepend if requested
  				if ( dataType[ 0 ] === "+" ) {
  					dataType = dataType.slice( 1 ) || "*";
  					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

  				// Otherwise append
  				} else {
  					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
  				}
  			}
  		}
  	};
  }

  // Base inspection function for prefilters and transports
  function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

  	var inspected = {},
  		seekingTransport = ( structure === transports );

  	function inspect( dataType ) {
  		var selected;
  		inspected[ dataType ] = true;
  		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
  			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
  			if ( typeof dataTypeOrTransport === "string" &&
  				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

  				options.dataTypes.unshift( dataTypeOrTransport );
  				inspect( dataTypeOrTransport );
  				return false;
  			} else if ( seekingTransport ) {
  				return !( selected = dataTypeOrTransport );
  			}
  		} );
  		return selected;
  	}

  	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
  }

  // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887
  function ajaxExtend( target, src ) {
  	var key, deep,
  		flatOptions = jQuery.ajaxSettings.flatOptions || {};

  	for ( key in src ) {
  		if ( src[ key ] !== undefined ) {
  			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
  		}
  	}
  	if ( deep ) {
  		jQuery.extend( true, target, deep );
  	}

  	return target;
  }

  /* Handles responses to an ajax request:
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */
  function ajaxHandleResponses( s, jqXHR, responses ) {

  	var ct, type, finalDataType, firstDataType,
  		contents = s.contents,
  		dataTypes = s.dataTypes;

  	// Remove auto dataType and get content-type in the process
  	while ( dataTypes[ 0 ] === "*" ) {
  		dataTypes.shift();
  		if ( ct === undefined ) {
  			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
  		}
  	}

  	// Check if we're dealing with a known content-type
  	if ( ct ) {
  		for ( type in contents ) {
  			if ( contents[ type ] && contents[ type ].test( ct ) ) {
  				dataTypes.unshift( type );
  				break;
  			}
  		}
  	}

  	// Check to see if we have a response for the expected dataType
  	if ( dataTypes[ 0 ] in responses ) {
  		finalDataType = dataTypes[ 0 ];
  	} else {

  		// Try convertible dataTypes
  		for ( type in responses ) {
  			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
  				finalDataType = type;
  				break;
  			}
  			if ( !firstDataType ) {
  				firstDataType = type;
  			}
  		}

  		// Or just use first one
  		finalDataType = finalDataType || firstDataType;
  	}

  	// If we found a dataType
  	// We add the dataType to the list if needed
  	// and return the corresponding response
  	if ( finalDataType ) {
  		if ( finalDataType !== dataTypes[ 0 ] ) {
  			dataTypes.unshift( finalDataType );
  		}
  		return responses[ finalDataType ];
  	}
  }

  /* Chain conversions given the request and the original response
   * Also sets the responseXXX fields on the jqXHR instance
   */
  function ajaxConvert( s, response, jqXHR, isSuccess ) {
  	var conv2, current, conv, tmp, prev,
  		converters = {},

  		// Work with a copy of dataTypes in case we need to modify it for conversion
  		dataTypes = s.dataTypes.slice();

  	// Create converters map with lowercased keys
  	if ( dataTypes[ 1 ] ) {
  		for ( conv in s.converters ) {
  			converters[ conv.toLowerCase() ] = s.converters[ conv ];
  		}
  	}

  	current = dataTypes.shift();

  	// Convert to each sequential dataType
  	while ( current ) {

  		if ( s.responseFields[ current ] ) {
  			jqXHR[ s.responseFields[ current ] ] = response;
  		}

  		// Apply the dataFilter if provided
  		if ( !prev && isSuccess && s.dataFilter ) {
  			response = s.dataFilter( response, s.dataType );
  		}

  		prev = current;
  		current = dataTypes.shift();

  		if ( current ) {

  			// There's only work to do if current dataType is non-auto
  			if ( current === "*" ) {

  				current = prev;

  			// Convert response if prev dataType is non-auto and differs from current
  			} else if ( prev !== "*" && prev !== current ) {

  				// Seek a direct converter
  				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

  				// If none found, seek a pair
  				if ( !conv ) {
  					for ( conv2 in converters ) {

  						// If conv2 outputs current
  						tmp = conv2.split( " " );
  						if ( tmp[ 1 ] === current ) {

  							// If prev can be converted to accepted input
  							conv = converters[ prev + " " + tmp[ 0 ] ] ||
  								converters[ "* " + tmp[ 0 ] ];
  							if ( conv ) {

  								// Condense equivalence converters
  								if ( conv === true ) {
  									conv = converters[ conv2 ];

  								// Otherwise, insert the intermediate dataType
  								} else if ( converters[ conv2 ] !== true ) {
  									current = tmp[ 0 ];
  									dataTypes.unshift( tmp[ 1 ] );
  								}
  								break;
  							}
  						}
  					}
  				}

  				// Apply converter (if not an equivalence)
  				if ( conv !== true ) {

  					// Unless errors are allowed to bubble, catch and return them
  					if ( conv && s.throws ) {
  						response = conv( response );
  					} else {
  						try {
  							response = conv( response );
  						} catch ( e ) {
  							return {
  								state: "parsererror",
  								error: conv ? e : "No conversion from " + prev + " to " + current
  							};
  						}
  					}
  				}
  			}
  		}
  	}

  	return { state: "success", data: response };
  }

  jQuery.extend( {

  	// Counter for holding the number of active queries
  	active: 0,

  	// Last-Modified header cache for next request
  	lastModified: {},
  	etag: {},

  	ajaxSettings: {
  		url: location.href,
  		type: "GET",
  		isLocal: rlocalProtocol.test( location.protocol ),
  		global: true,
  		processData: true,
  		async: true,
  		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

  		/*
  		timeout: 0,
  		data: null,
  		dataType: null,
  		username: null,
  		password: null,
  		cache: null,
  		throws: false,
  		traditional: false,
  		headers: {},
  		*/

  		accepts: {
  			"*": allTypes,
  			text: "text/plain",
  			html: "text/html",
  			xml: "application/xml, text/xml",
  			json: "application/json, text/javascript"
  		},

  		contents: {
  			xml: /\bxml\b/,
  			html: /\bhtml/,
  			json: /\bjson\b/
  		},

  		responseFields: {
  			xml: "responseXML",
  			text: "responseText",
  			json: "responseJSON"
  		},

  		// Data converters
  		// Keys separate source (or catchall "*") and destination types with a single space
  		converters: {

  			// Convert anything to text
  			"* text": String,

  			// Text to html (true = no transformation)
  			"text html": true,

  			// Evaluate text as a json expression
  			"text json": JSON.parse,

  			// Parse text as xml
  			"text xml": jQuery.parseXML
  		},

  		// For options that shouldn't be deep extended:
  		// you can add your own custom options here if
  		// and when you create one that shouldn't be
  		// deep extended (see ajaxExtend)
  		flatOptions: {
  			url: true,
  			context: true
  		}
  	},

  	// Creates a full fledged settings object into target
  	// with both ajaxSettings and settings fields.
  	// If target is omitted, writes into ajaxSettings.
  	ajaxSetup: function( target, settings ) {
  		return settings ?

  			// Building a settings object
  			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

  			// Extending ajaxSettings
  			ajaxExtend( jQuery.ajaxSettings, target );
  	},

  	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
  	ajaxTransport: addToPrefiltersOrTransports( transports ),

  	// Main method
  	ajax: function( url, options ) {

  		// If url is an object, simulate pre-1.5 signature
  		if ( typeof url === "object" ) {
  			options = url;
  			url = undefined;
  		}

  		// Force options to be an object
  		options = options || {};

  		var transport,

  			// URL without anti-cache param
  			cacheURL,

  			// Response headers
  			responseHeadersString,
  			responseHeaders,

  			// timeout handle
  			timeoutTimer,

  			// Url cleanup var
  			urlAnchor,

  			// Request state (becomes false upon send and true upon completion)
  			completed,

  			// To know if global events are to be dispatched
  			fireGlobals,

  			// Loop variable
  			i,

  			// uncached part of the url
  			uncached,

  			// Create the final options object
  			s = jQuery.ajaxSetup( {}, options ),

  			// Callbacks context
  			callbackContext = s.context || s,

  			// Context for global events is callbackContext if it is a DOM node or jQuery collection
  			globalEventContext = s.context &&
  				( callbackContext.nodeType || callbackContext.jquery ) ?
  					jQuery( callbackContext ) :
  					jQuery.event,

  			// Deferreds
  			deferred = jQuery.Deferred(),
  			completeDeferred = jQuery.Callbacks( "once memory" ),

  			// Status-dependent callbacks
  			statusCode = s.statusCode || {},

  			// Headers (they are sent all at once)
  			requestHeaders = {},
  			requestHeadersNames = {},

  			// Default abort message
  			strAbort = "canceled",

  			// Fake xhr
  			jqXHR = {
  				readyState: 0,

  				// Builds headers hashtable if needed
  				getResponseHeader: function( key ) {
  					var match;
  					if ( completed ) {
  						if ( !responseHeaders ) {
  							responseHeaders = {};
  							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
  								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
  							}
  						}
  						match = responseHeaders[ key.toLowerCase() ];
  					}
  					return match == null ? null : match;
  				},

  				// Raw string
  				getAllResponseHeaders: function() {
  					return completed ? responseHeadersString : null;
  				},

  				// Caches the header
  				setRequestHeader: function( name, value ) {
  					if ( completed == null ) {
  						name = requestHeadersNames[ name.toLowerCase() ] =
  							requestHeadersNames[ name.toLowerCase() ] || name;
  						requestHeaders[ name ] = value;
  					}
  					return this;
  				},

  				// Overrides response content-type header
  				overrideMimeType: function( type ) {
  					if ( completed == null ) {
  						s.mimeType = type;
  					}
  					return this;
  				},

  				// Status-dependent callbacks
  				statusCode: function( map ) {
  					var code;
  					if ( map ) {
  						if ( completed ) {

  							// Execute the appropriate callbacks
  							jqXHR.always( map[ jqXHR.status ] );
  						} else {

  							// Lazy-add the new callbacks in a way that preserves old ones
  							for ( code in map ) {
  								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
  							}
  						}
  					}
  					return this;
  				},

  				// Cancel the request
  				abort: function( statusText ) {
  					var finalText = statusText || strAbort;
  					if ( transport ) {
  						transport.abort( finalText );
  					}
  					done( 0, finalText );
  					return this;
  				}
  			};

  		// Attach deferreds
  		deferred.promise( jqXHR );

  		// Add protocol if not provided (prefilters might expect it)
  		// Handle falsy url in the settings object (#10093: consistency with old signature)
  		// We also use the url parameter if available
  		s.url = ( ( url || s.url || location.href ) + "" )
  			.replace( rprotocol, location.protocol + "//" );

  		// Alias method option to type as per ticket #12004
  		s.type = options.method || options.type || s.method || s.type;

  		// Extract dataTypes list
  		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

  		// A cross-domain request is in order when the origin doesn't match the current origin.
  		if ( s.crossDomain == null ) {
  			urlAnchor = document.createElement( "a" );

  			// Support: IE <=8 - 11, Edge 12 - 15
  			// IE throws exception on accessing the href property if url is malformed,
  			// e.g. http://example.com:80x/
  			try {
  				urlAnchor.href = s.url;

  				// Support: IE <=8 - 11 only
  				// Anchor's host property isn't correctly set when s.url is relative
  				urlAnchor.href = urlAnchor.href;
  				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
  					urlAnchor.protocol + "//" + urlAnchor.host;
  			} catch ( e ) {

  				// If there is an error parsing the URL, assume it is crossDomain,
  				// it can be rejected by the transport if it is invalid
  				s.crossDomain = true;
  			}
  		}

  		// Convert data if not already a string
  		if ( s.data && s.processData && typeof s.data !== "string" ) {
  			s.data = jQuery.param( s.data, s.traditional );
  		}

  		// Apply prefilters
  		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

  		// If request was aborted inside a prefilter, stop there
  		if ( completed ) {
  			return jqXHR;
  		}

  		// We can fire global events as of now if asked to
  		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
  		fireGlobals = jQuery.event && s.global;

  		// Watch for a new set of requests
  		if ( fireGlobals && jQuery.active++ === 0 ) {
  			jQuery.event.trigger( "ajaxStart" );
  		}

  		// Uppercase the type
  		s.type = s.type.toUpperCase();

  		// Determine if request has content
  		s.hasContent = !rnoContent.test( s.type );

  		// Save the URL in case we're toying with the If-Modified-Since
  		// and/or If-None-Match header later on
  		// Remove hash to simplify url manipulation
  		cacheURL = s.url.replace( rhash, "" );

  		// More options handling for requests with no content
  		if ( !s.hasContent ) {

  			// Remember the hash so we can put it back
  			uncached = s.url.slice( cacheURL.length );

  			// If data is available and should be processed, append data to url
  			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
  				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

  				// #9682: remove data so that it's not used in an eventual retry
  				delete s.data;
  			}

  			// Add or update anti-cache param if needed
  			if ( s.cache === false ) {
  				cacheURL = cacheURL.replace( rantiCache, "$1" );
  				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
  			}

  			// Put hash and anti-cache on the URL that will be requested (gh-1732)
  			s.url = cacheURL + uncached;

  		// Change '%20' to '+' if this is encoded form body content (gh-2658)
  		} else if ( s.data && s.processData &&
  			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
  			s.data = s.data.replace( r20, "+" );
  		}

  		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
  		if ( s.ifModified ) {
  			if ( jQuery.lastModified[ cacheURL ] ) {
  				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
  			}
  			if ( jQuery.etag[ cacheURL ] ) {
  				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
  			}
  		}

  		// Set the correct header, if data is being sent
  		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
  			jqXHR.setRequestHeader( "Content-Type", s.contentType );
  		}

  		// Set the Accepts header for the server, depending on the dataType
  		jqXHR.setRequestHeader(
  			"Accept",
  			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
  				s.accepts[ s.dataTypes[ 0 ] ] +
  					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
  				s.accepts[ "*" ]
  		);

  		// Check for headers option
  		for ( i in s.headers ) {
  			jqXHR.setRequestHeader( i, s.headers[ i ] );
  		}

  		// Allow custom headers/mimetypes and early abort
  		if ( s.beforeSend &&
  			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

  			// Abort if not done already and return
  			return jqXHR.abort();
  		}

  		// Aborting is no longer a cancellation
  		strAbort = "abort";

  		// Install callbacks on deferreds
  		completeDeferred.add( s.complete );
  		jqXHR.done( s.success );
  		jqXHR.fail( s.error );

  		// Get transport
  		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

  		// If no transport, we auto-abort
  		if ( !transport ) {
  			done( -1, "No Transport" );
  		} else {
  			jqXHR.readyState = 1;

  			// Send global event
  			if ( fireGlobals ) {
  				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
  			}

  			// If request was aborted inside ajaxSend, stop there
  			if ( completed ) {
  				return jqXHR;
  			}

  			// Timeout
  			if ( s.async && s.timeout > 0 ) {
  				timeoutTimer = window.setTimeout( function() {
  					jqXHR.abort( "timeout" );
  				}, s.timeout );
  			}

  			try {
  				completed = false;
  				transport.send( requestHeaders, done );
  			} catch ( e ) {

  				// Rethrow post-completion exceptions
  				if ( completed ) {
  					throw e;
  				}

  				// Propagate others as results
  				done( -1, e );
  			}
  		}

  		// Callback for when everything is done
  		function done( status, nativeStatusText, responses, headers ) {
  			var isSuccess, success, error, response, modified,
  				statusText = nativeStatusText;

  			// Ignore repeat invocations
  			if ( completed ) {
  				return;
  			}

  			completed = true;

  			// Clear timeout if it exists
  			if ( timeoutTimer ) {
  				window.clearTimeout( timeoutTimer );
  			}

  			// Dereference transport for early garbage collection
  			// (no matter how long the jqXHR object will be used)
  			transport = undefined;

  			// Cache response headers
  			responseHeadersString = headers || "";

  			// Set readyState
  			jqXHR.readyState = status > 0 ? 4 : 0;

  			// Determine if successful
  			isSuccess = status >= 200 && status < 300 || status === 304;

  			// Get response data
  			if ( responses ) {
  				response = ajaxHandleResponses( s, jqXHR, responses );
  			}

  			// Convert no matter what (that way responseXXX fields are always set)
  			response = ajaxConvert( s, response, jqXHR, isSuccess );

  			// If successful, handle type chaining
  			if ( isSuccess ) {

  				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
  				if ( s.ifModified ) {
  					modified = jqXHR.getResponseHeader( "Last-Modified" );
  					if ( modified ) {
  						jQuery.lastModified[ cacheURL ] = modified;
  					}
  					modified = jqXHR.getResponseHeader( "etag" );
  					if ( modified ) {
  						jQuery.etag[ cacheURL ] = modified;
  					}
  				}

  				// if no content
  				if ( status === 204 || s.type === "HEAD" ) {
  					statusText = "nocontent";

  				// if not modified
  				} else if ( status === 304 ) {
  					statusText = "notmodified";

  				// If we have data, let's convert it
  				} else {
  					statusText = response.state;
  					success = response.data;
  					error = response.error;
  					isSuccess = !error;
  				}
  			} else {

  				// Extract error from statusText and normalize for non-aborts
  				error = statusText;
  				if ( status || !statusText ) {
  					statusText = "error";
  					if ( status < 0 ) {
  						status = 0;
  					}
  				}
  			}

  			// Set data for the fake xhr object
  			jqXHR.status = status;
  			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

  			// Success/Error
  			if ( isSuccess ) {
  				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
  			} else {
  				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
  			}

  			// Status-dependent callbacks
  			jqXHR.statusCode( statusCode );
  			statusCode = undefined;

  			if ( fireGlobals ) {
  				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
  					[ jqXHR, s, isSuccess ? success : error ] );
  			}

  			// Complete
  			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

  			if ( fireGlobals ) {
  				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

  				// Handle the global AJAX counter
  				if ( !( --jQuery.active ) ) {
  					jQuery.event.trigger( "ajaxStop" );
  				}
  			}
  		}

  		return jqXHR;
  	},

  	getJSON: function( url, data, callback ) {
  		return jQuery.get( url, data, callback, "json" );
  	},

  	getScript: function( url, callback ) {
  		return jQuery.get( url, undefined, callback, "script" );
  	}
  } );

  jQuery.each( [ "get", "post" ], function( i, method ) {
  	jQuery[ method ] = function( url, data, callback, type ) {

  		// Shift arguments if data argument was omitted
  		if ( isFunction( data ) ) {
  			type = type || callback;
  			callback = data;
  			data = undefined;
  		}

  		// The url can be an options object (which then must have .url)
  		return jQuery.ajax( jQuery.extend( {
  			url: url,
  			type: method,
  			dataType: type,
  			data: data,
  			success: callback
  		}, jQuery.isPlainObject( url ) && url ) );
  	};
  } );


  jQuery._evalUrl = function( url ) {
  	return jQuery.ajax( {
  		url: url,

  		// Make this explicit, since user can override this through ajaxSetup (#11264)
  		type: "GET",
  		dataType: "script",
  		cache: true,
  		async: false,
  		global: false,
  		"throws": true
  	} );
  };


  jQuery.fn.extend( {
  	wrapAll: function( html ) {
  		var wrap;

  		if ( this[ 0 ] ) {
  			if ( isFunction( html ) ) {
  				html = html.call( this[ 0 ] );
  			}

  			// The elements to wrap the target around
  			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

  			if ( this[ 0 ].parentNode ) {
  				wrap.insertBefore( this[ 0 ] );
  			}

  			wrap.map( function() {
  				var elem = this;

  				while ( elem.firstElementChild ) {
  					elem = elem.firstElementChild;
  				}

  				return elem;
  			} ).append( this );
  		}

  		return this;
  	},

  	wrapInner: function( html ) {
  		if ( isFunction( html ) ) {
  			return this.each( function( i ) {
  				jQuery( this ).wrapInner( html.call( this, i ) );
  			} );
  		}

  		return this.each( function() {
  			var self = jQuery( this ),
  				contents = self.contents();

  			if ( contents.length ) {
  				contents.wrapAll( html );

  			} else {
  				self.append( html );
  			}
  		} );
  	},

  	wrap: function( html ) {
  		var htmlIsFunction = isFunction( html );

  		return this.each( function( i ) {
  			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
  		} );
  	},

  	unwrap: function( selector ) {
  		this.parent( selector ).not( "body" ).each( function() {
  			jQuery( this ).replaceWith( this.childNodes );
  		} );
  		return this;
  	}
  } );


  jQuery.expr.pseudos.hidden = function( elem ) {
  	return !jQuery.expr.pseudos.visible( elem );
  };
  jQuery.expr.pseudos.visible = function( elem ) {
  	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
  };




  jQuery.ajaxSettings.xhr = function() {
  	try {
  		return new window.XMLHttpRequest();
  	} catch ( e ) {}
  };

  var xhrSuccessStatus = {

  		// File protocol always yields status code 0, assume 200
  		0: 200,

  		// Support: IE <=9 only
  		// #1450: sometimes IE returns 1223 when it should be 204
  		1223: 204
  	},
  	xhrSupported = jQuery.ajaxSettings.xhr();

  support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
  support.ajax = xhrSupported = !!xhrSupported;

  jQuery.ajaxTransport( function( options ) {
  	var callback, errorCallback;

  	// Cross domain only allowed if supported through XMLHttpRequest
  	if ( support.cors || xhrSupported && !options.crossDomain ) {
  		return {
  			send: function( headers, complete ) {
  				var i,
  					xhr = options.xhr();

  				xhr.open(
  					options.type,
  					options.url,
  					options.async,
  					options.username,
  					options.password
  				);

  				// Apply custom fields if provided
  				if ( options.xhrFields ) {
  					for ( i in options.xhrFields ) {
  						xhr[ i ] = options.xhrFields[ i ];
  					}
  				}

  				// Override mime type if needed
  				if ( options.mimeType && xhr.overrideMimeType ) {
  					xhr.overrideMimeType( options.mimeType );
  				}

  				// X-Requested-With header
  				// For cross-domain requests, seeing as conditions for a preflight are
  				// akin to a jigsaw puzzle, we simply never set it to be sure.
  				// (it can always be set on a per-request basis or even using ajaxSetup)
  				// For same-domain requests, won't change header if already provided.
  				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
  					headers[ "X-Requested-With" ] = "XMLHttpRequest";
  				}

  				// Set headers
  				for ( i in headers ) {
  					xhr.setRequestHeader( i, headers[ i ] );
  				}

  				// Callback
  				callback = function( type ) {
  					return function() {
  						if ( callback ) {
  							callback = errorCallback = xhr.onload =
  								xhr.onerror = xhr.onabort = xhr.ontimeout =
  									xhr.onreadystatechange = null;

  							if ( type === "abort" ) {
  								xhr.abort();
  							} else if ( type === "error" ) {

  								// Support: IE <=9 only
  								// On a manual native abort, IE9 throws
  								// errors on any property access that is not readyState
  								if ( typeof xhr.status !== "number" ) {
  									complete( 0, "error" );
  								} else {
  									complete(

  										// File: protocol always yields status 0; see #8605, #14207
  										xhr.status,
  										xhr.statusText
  									);
  								}
  							} else {
  								complete(
  									xhrSuccessStatus[ xhr.status ] || xhr.status,
  									xhr.statusText,

  									// Support: IE <=9 only
  									// IE9 has no XHR2 but throws on binary (trac-11426)
  									// For XHR2 non-text, let the caller handle it (gh-2498)
  									( xhr.responseType || "text" ) !== "text"  ||
  									typeof xhr.responseText !== "string" ?
  										{ binary: xhr.response } :
  										{ text: xhr.responseText },
  									xhr.getAllResponseHeaders()
  								);
  							}
  						}
  					};
  				};

  				// Listen to events
  				xhr.onload = callback();
  				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

  				// Support: IE 9 only
  				// Use onreadystatechange to replace onabort
  				// to handle uncaught aborts
  				if ( xhr.onabort !== undefined ) {
  					xhr.onabort = errorCallback;
  				} else {
  					xhr.onreadystatechange = function() {

  						// Check readyState before timeout as it changes
  						if ( xhr.readyState === 4 ) {

  							// Allow onerror to be called first,
  							// but that will not handle a native abort
  							// Also, save errorCallback to a variable
  							// as xhr.onerror cannot be accessed
  							window.setTimeout( function() {
  								if ( callback ) {
  									errorCallback();
  								}
  							} );
  						}
  					};
  				}

  				// Create the abort callback
  				callback = callback( "abort" );

  				try {

  					// Do send the request (this may raise an exception)
  					xhr.send( options.hasContent && options.data || null );
  				} catch ( e ) {

  					// #14683: Only rethrow if this hasn't been notified as an error yet
  					if ( callback ) {
  						throw e;
  					}
  				}
  			},

  			abort: function() {
  				if ( callback ) {
  					callback();
  				}
  			}
  		};
  	}
  } );




  // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
  jQuery.ajaxPrefilter( function( s ) {
  	if ( s.crossDomain ) {
  		s.contents.script = false;
  	}
  } );

  // Install script dataType
  jQuery.ajaxSetup( {
  	accepts: {
  		script: "text/javascript, application/javascript, " +
  			"application/ecmascript, application/x-ecmascript"
  	},
  	contents: {
  		script: /\b(?:java|ecma)script\b/
  	},
  	converters: {
  		"text script": function( text ) {
  			jQuery.globalEval( text );
  			return text;
  		}
  	}
  } );

  // Handle cache's special case and crossDomain
  jQuery.ajaxPrefilter( "script", function( s ) {
  	if ( s.cache === undefined ) {
  		s.cache = false;
  	}
  	if ( s.crossDomain ) {
  		s.type = "GET";
  	}
  } );

  // Bind script tag hack transport
  jQuery.ajaxTransport( "script", function( s ) {

  	// This transport only deals with cross domain requests
  	if ( s.crossDomain ) {
  		var script, callback;
  		return {
  			send: function( _, complete ) {
  				script = jQuery( "<script>" ).prop( {
  					charset: s.scriptCharset,
  					src: s.url
  				} ).on(
  					"load error",
  					callback = function( evt ) {
  						script.remove();
  						callback = null;
  						if ( evt ) {
  							complete( evt.type === "error" ? 404 : 200, evt.type );
  						}
  					}
  				);

  				// Use native DOM manipulation to avoid our domManip AJAX trickery
  				document.head.appendChild( script[ 0 ] );
  			},
  			abort: function() {
  				if ( callback ) {
  					callback();
  				}
  			}
  		};
  	}
  } );




  var oldCallbacks = [],
  	rjsonp = /(=)\?(?=&|$)|\?\?/;

  // Default jsonp settings
  jQuery.ajaxSetup( {
  	jsonp: "callback",
  	jsonpCallback: function() {
  		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
  		this[ callback ] = true;
  		return callback;
  	}
  } );

  // Detect, normalize options and install callbacks for jsonp requests
  jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

  	var callbackName, overwritten, responseContainer,
  		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
  			"url" :
  			typeof s.data === "string" &&
  				( s.contentType || "" )
  					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
  				rjsonp.test( s.data ) && "data"
  		);

  	// Handle iff the expected data type is "jsonp" or we have a parameter to set
  	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

  		// Get callback name, remembering preexisting value associated with it
  		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
  			s.jsonpCallback() :
  			s.jsonpCallback;

  		// Insert callback into url or form data
  		if ( jsonProp ) {
  			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
  		} else if ( s.jsonp !== false ) {
  			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
  		}

  		// Use data converter to retrieve json after script execution
  		s.converters[ "script json" ] = function() {
  			if ( !responseContainer ) {
  				jQuery.error( callbackName + " was not called" );
  			}
  			return responseContainer[ 0 ];
  		};

  		// Force json dataType
  		s.dataTypes[ 0 ] = "json";

  		// Install callback
  		overwritten = window[ callbackName ];
  		window[ callbackName ] = function() {
  			responseContainer = arguments;
  		};

  		// Clean-up function (fires after converters)
  		jqXHR.always( function() {

  			// If previous value didn't exist - remove it
  			if ( overwritten === undefined ) {
  				jQuery( window ).removeProp( callbackName );

  			// Otherwise restore preexisting value
  			} else {
  				window[ callbackName ] = overwritten;
  			}

  			// Save back as free
  			if ( s[ callbackName ] ) {

  				// Make sure that re-using the options doesn't screw things around
  				s.jsonpCallback = originalSettings.jsonpCallback;

  				// Save the callback name for future use
  				oldCallbacks.push( callbackName );
  			}

  			// Call if it was a function and we have a response
  			if ( responseContainer && isFunction( overwritten ) ) {
  				overwritten( responseContainer[ 0 ] );
  			}

  			responseContainer = overwritten = undefined;
  		} );

  		// Delegate to script
  		return "script";
  	}
  } );




  // Support: Safari 8 only
  // In Safari 8 documents created via document.implementation.createHTMLDocument
  // collapse sibling forms: the second one becomes a child of the first one.
  // Because of that, this security measure has to be disabled in Safari 8.
  // https://bugs.webkit.org/show_bug.cgi?id=137337
  support.createHTMLDocument = ( function() {
  	var body = document.implementation.createHTMLDocument( "" ).body;
  	body.innerHTML = "<form></form><form></form>";
  	return body.childNodes.length === 2;
  } )();


  // Argument "data" should be string of html
  // context (optional): If specified, the fragment will be created in this context,
  // defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string
  jQuery.parseHTML = function( data, context, keepScripts ) {
  	if ( typeof data !== "string" ) {
  		return [];
  	}
  	if ( typeof context === "boolean" ) {
  		keepScripts = context;
  		context = false;
  	}

  	var base, parsed, scripts;

  	if ( !context ) {

  		// Stop scripts or inline event handlers from being executed immediately
  		// by using document.implementation
  		if ( support.createHTMLDocument ) {
  			context = document.implementation.createHTMLDocument( "" );

  			// Set the base href for the created document
  			// so any parsed elements with URLs
  			// are based on the document's URL (gh-2965)
  			base = context.createElement( "base" );
  			base.href = document.location.href;
  			context.head.appendChild( base );
  		} else {
  			context = document;
  		}
  	}

  	parsed = rsingleTag.exec( data );
  	scripts = !keepScripts && [];

  	// Single tag
  	if ( parsed ) {
  		return [ context.createElement( parsed[ 1 ] ) ];
  	}

  	parsed = buildFragment( [ data ], context, scripts );

  	if ( scripts && scripts.length ) {
  		jQuery( scripts ).remove();
  	}

  	return jQuery.merge( [], parsed.childNodes );
  };


  /**
   * Load a url into a page
   */
  jQuery.fn.load = function( url, params, callback ) {
  	var selector, type, response,
  		self = this,
  		off = url.indexOf( " " );

  	if ( off > -1 ) {
  		selector = stripAndCollapse( url.slice( off ) );
  		url = url.slice( 0, off );
  	}

  	// If it's a function
  	if ( isFunction( params ) ) {

  		// We assume that it's the callback
  		callback = params;
  		params = undefined;

  	// Otherwise, build a param string
  	} else if ( params && typeof params === "object" ) {
  		type = "POST";
  	}

  	// If we have elements to modify, make the request
  	if ( self.length > 0 ) {
  		jQuery.ajax( {
  			url: url,

  			// If "type" variable is undefined, then "GET" method will be used.
  			// Make value of this field explicit since
  			// user can override it through ajaxSetup method
  			type: type || "GET",
  			dataType: "html",
  			data: params
  		} ).done( function( responseText ) {

  			// Save response for use in complete callback
  			response = arguments;

  			self.html( selector ?

  				// If a selector was specified, locate the right elements in a dummy div
  				// Exclude scripts to avoid IE 'Permission Denied' errors
  				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

  				// Otherwise use the full result
  				responseText );

  		// If the request succeeds, this function gets "data", "status", "jqXHR"
  		// but they are ignored because response was set above.
  		// If it fails, this function gets "jqXHR", "status", "error"
  		} ).always( callback && function( jqXHR, status ) {
  			self.each( function() {
  				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
  			} );
  		} );
  	}

  	return this;
  };




  // Attach a bunch of functions for handling common AJAX events
  jQuery.each( [
  	"ajaxStart",
  	"ajaxStop",
  	"ajaxComplete",
  	"ajaxError",
  	"ajaxSuccess",
  	"ajaxSend"
  ], function( i, type ) {
  	jQuery.fn[ type ] = function( fn ) {
  		return this.on( type, fn );
  	};
  } );




  jQuery.expr.pseudos.animated = function( elem ) {
  	return jQuery.grep( jQuery.timers, function( fn ) {
  		return elem === fn.elem;
  	} ).length;
  };




  jQuery.offset = {
  	setOffset: function( elem, options, i ) {
  		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
  			position = jQuery.css( elem, "position" ),
  			curElem = jQuery( elem ),
  			props = {};

  		// Set position first, in-case top/left are set even on static elem
  		if ( position === "static" ) {
  			elem.style.position = "relative";
  		}

  		curOffset = curElem.offset();
  		curCSSTop = jQuery.css( elem, "top" );
  		curCSSLeft = jQuery.css( elem, "left" );
  		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
  			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

  		// Need to be able to calculate position if either
  		// top or left is auto and position is either absolute or fixed
  		if ( calculatePosition ) {
  			curPosition = curElem.position();
  			curTop = curPosition.top;
  			curLeft = curPosition.left;

  		} else {
  			curTop = parseFloat( curCSSTop ) || 0;
  			curLeft = parseFloat( curCSSLeft ) || 0;
  		}

  		if ( isFunction( options ) ) {

  			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
  			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
  		}

  		if ( options.top != null ) {
  			props.top = ( options.top - curOffset.top ) + curTop;
  		}
  		if ( options.left != null ) {
  			props.left = ( options.left - curOffset.left ) + curLeft;
  		}

  		if ( "using" in options ) {
  			options.using.call( elem, props );

  		} else {
  			curElem.css( props );
  		}
  	}
  };

  jQuery.fn.extend( {

  	// offset() relates an element's border box to the document origin
  	offset: function( options ) {

  		// Preserve chaining for setter
  		if ( arguments.length ) {
  			return options === undefined ?
  				this :
  				this.each( function( i ) {
  					jQuery.offset.setOffset( this, options, i );
  				} );
  		}

  		var rect, win,
  			elem = this[ 0 ];

  		if ( !elem ) {
  			return;
  		}

  		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
  		// Support: IE <=11 only
  		// Running getBoundingClientRect on a
  		// disconnected node in IE throws an error
  		if ( !elem.getClientRects().length ) {
  			return { top: 0, left: 0 };
  		}

  		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
  		rect = elem.getBoundingClientRect();
  		win = elem.ownerDocument.defaultView;
  		return {
  			top: rect.top + win.pageYOffset,
  			left: rect.left + win.pageXOffset
  		};
  	},

  	// position() relates an element's margin box to its offset parent's padding box
  	// This corresponds to the behavior of CSS absolute positioning
  	position: function() {
  		if ( !this[ 0 ] ) {
  			return;
  		}

  		var offsetParent, offset, doc,
  			elem = this[ 0 ],
  			parentOffset = { top: 0, left: 0 };

  		// position:fixed elements are offset from the viewport, which itself always has zero offset
  		if ( jQuery.css( elem, "position" ) === "fixed" ) {

  			// Assume position:fixed implies availability of getBoundingClientRect
  			offset = elem.getBoundingClientRect();

  		} else {
  			offset = this.offset();

  			// Account for the *real* offset parent, which can be the document or its root element
  			// when a statically positioned element is identified
  			doc = elem.ownerDocument;
  			offsetParent = elem.offsetParent || doc.documentElement;
  			while ( offsetParent &&
  				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
  				jQuery.css( offsetParent, "position" ) === "static" ) {

  				offsetParent = offsetParent.parentNode;
  			}
  			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

  				// Incorporate borders into its offset, since they are outside its content origin
  				parentOffset = jQuery( offsetParent ).offset();
  				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
  				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
  			}
  		}

  		// Subtract parent offsets and element margins
  		return {
  			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
  			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
  		};
  	},

  	// This method will return documentElement in the following cases:
  	// 1) For the element inside the iframe without offsetParent, this method will return
  	//    documentElement of the parent window
  	// 2) For the hidden or detached element
  	// 3) For body or html element, i.e. in case of the html node - it will return itself
  	//
  	// but those exceptions were never presented as a real life use-cases
  	// and might be considered as more preferable results.
  	//
  	// This logic, however, is not guaranteed and can change at any point in the future
  	offsetParent: function() {
  		return this.map( function() {
  			var offsetParent = this.offsetParent;

  			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
  				offsetParent = offsetParent.offsetParent;
  			}

  			return offsetParent || documentElement;
  		} );
  	}
  } );

  // Create scrollLeft and scrollTop methods
  jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
  	var top = "pageYOffset" === prop;

  	jQuery.fn[ method ] = function( val ) {
  		return access( this, function( elem, method, val ) {

  			// Coalesce documents and windows
  			var win;
  			if ( isWindow( elem ) ) {
  				win = elem;
  			} else if ( elem.nodeType === 9 ) {
  				win = elem.defaultView;
  			}

  			if ( val === undefined ) {
  				return win ? win[ prop ] : elem[ method ];
  			}

  			if ( win ) {
  				win.scrollTo(
  					!top ? val : win.pageXOffset,
  					top ? val : win.pageYOffset
  				);

  			} else {
  				elem[ method ] = val;
  			}
  		}, method, val, arguments.length );
  	};
  } );

  // Support: Safari <=7 - 9.1, Chrome <=37 - 49
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
  // getComputedStyle returns percent when specified for top/left/bottom/right;
  // rather than make the css module depend on the offset module, just check for it here
  jQuery.each( [ "top", "left" ], function( i, prop ) {
  	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
  		function( elem, computed ) {
  			if ( computed ) {
  				computed = curCSS( elem, prop );

  				// If curCSS returns percentage, fallback to offset
  				return rnumnonpx.test( computed ) ?
  					jQuery( elem ).position()[ prop ] + "px" :
  					computed;
  			}
  		}
  	);
  } );


  // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
  jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
  	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
  		function( defaultExtra, funcName ) {

  		// Margin is only for outerHeight, outerWidth
  		jQuery.fn[ funcName ] = function( margin, value ) {
  			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
  				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

  			return access( this, function( elem, type, value ) {
  				var doc;

  				if ( isWindow( elem ) ) {

  					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
  					return funcName.indexOf( "outer" ) === 0 ?
  						elem[ "inner" + name ] :
  						elem.document.documentElement[ "client" + name ];
  				}

  				// Get document width or height
  				if ( elem.nodeType === 9 ) {
  					doc = elem.documentElement;

  					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
  					// whichever is greatest
  					return Math.max(
  						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
  						elem.body[ "offset" + name ], doc[ "offset" + name ],
  						doc[ "client" + name ]
  					);
  				}

  				return value === undefined ?

  					// Get width or height on the element, requesting but not forcing parseFloat
  					jQuery.css( elem, type, extra ) :

  					// Set width or height on the element
  					jQuery.style( elem, type, value, extra );
  			}, type, chainable ? margin : undefined, chainable );
  		};
  	} );
  } );


  jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
  	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
  	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
  	function( i, name ) {

  	// Handle event binding
  	jQuery.fn[ name ] = function( data, fn ) {
  		return arguments.length > 0 ?
  			this.on( name, null, data, fn ) :
  			this.trigger( name );
  	};
  } );

  jQuery.fn.extend( {
  	hover: function( fnOver, fnOut ) {
  		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
  	}
  } );




  jQuery.fn.extend( {

  	bind: function( types, data, fn ) {
  		return this.on( types, null, data, fn );
  	},
  	unbind: function( types, fn ) {
  		return this.off( types, null, fn );
  	},

  	delegate: function( selector, types, data, fn ) {
  		return this.on( types, selector, data, fn );
  	},
  	undelegate: function( selector, types, fn ) {

  		// ( namespace ) or ( selector, types [, fn] )
  		return arguments.length === 1 ?
  			this.off( selector, "**" ) :
  			this.off( types, selector || "**", fn );
  	}
  } );

  // Bind a function to a context, optionally partially applying any
  // arguments.
  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
  // However, it is not slated for removal any time soon
  jQuery.proxy = function( fn, context ) {
  	var tmp, args, proxy;

  	if ( typeof context === "string" ) {
  		tmp = fn[ context ];
  		context = fn;
  		fn = tmp;
  	}

  	// Quick check to determine if target is callable, in the spec
  	// this throws a TypeError, but we will just return undefined.
  	if ( !isFunction( fn ) ) {
  		return undefined;
  	}

  	// Simulated bind
  	args = slice.call( arguments, 2 );
  	proxy = function() {
  		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
  	};

  	// Set the guid of unique handler to the same of original handler, so it can be removed
  	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

  	return proxy;
  };

  jQuery.holdReady = function( hold ) {
  	if ( hold ) {
  		jQuery.readyWait++;
  	} else {
  		jQuery.ready( true );
  	}
  };
  jQuery.isArray = Array.isArray;
  jQuery.parseJSON = JSON.parse;
  jQuery.nodeName = nodeName;
  jQuery.isFunction = isFunction;
  jQuery.isWindow = isWindow;
  jQuery.camelCase = camelCase;
  jQuery.type = toType;

  jQuery.now = Date.now;

  jQuery.isNumeric = function( obj ) {

  	// As of jQuery 3.0, isNumeric is limited to
  	// strings and numbers (primitives or objects)
  	// that can be coerced to finite numbers (gh-2662)
  	var type = jQuery.type( obj );
  	return ( type === "number" || type === "string" ) &&

  		// parseFloat NaNs numeric-cast false positives ("")
  		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
  		// subtraction forces infinities to NaN
  		!isNaN( obj - parseFloat( obj ) );
  };




  var

  	// Map over jQuery in case of overwrite
  	_jQuery = window.jQuery,

  	// Map over the $ in case of overwrite
  	_$ = window.$;

  jQuery.noConflict = function( deep ) {
  	if ( window.$ === jQuery ) {
  		window.$ = _$;
  	}

  	if ( deep && window.jQuery === jQuery ) {
  		window.jQuery = _jQuery;
  	}

  	return jQuery;
  };

  // Expose jQuery and $ identifiers, even in AMD
  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (#13566)
  if ( !noGlobal ) {
  	window.jQuery = window.$ = jQuery;
  }




  return jQuery;
  } );
  });

  var underscore = createCommonjsModule(function (module, exports) {
  //     Underscore.js 1.9.1
  //     http://underscorejs.org
  //     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  //     Underscore may be freely distributed under the MIT license.

  (function() {

    // Baseline setup
    // --------------

    // Establish the root object, `window` (`self`) in the browser, `global`
    // on the server, or `this` in some virtual machines. We use `self`
    // instead of `window` for `WebWorker` support.
    var root = typeof self == 'object' && self.self === self && self ||
              typeof commonjsGlobal == 'object' && commonjsGlobal.global === commonjsGlobal && commonjsGlobal ||
              this ||
              {};

    // Save the previous value of the `_` variable.
    var previousUnderscore = root._;

    // Save bytes in the minified (but not gzipped) version:
    var ArrayProto = Array.prototype, ObjProto = Object.prototype;
    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

    // Create quick reference variables for speed access to core prototypes.
    var push = ArrayProto.push,
        slice = ArrayProto.slice,
        toString = ObjProto.toString,
        hasOwnProperty = ObjProto.hasOwnProperty;

    // All **ECMAScript 5** native function implementations that we hope to use
    // are declared here.
    var nativeIsArray = Array.isArray,
        nativeKeys = Object.keys,
        nativeCreate = Object.create;

    // Naked function reference for surrogate-prototype-swapping.
    var Ctor = function(){};

    // Create a safe reference to the Underscore object for use below.
    var _ = function(obj) {
      if (obj instanceof _) return obj;
      if (!(this instanceof _)) return new _(obj);
      this._wrapped = obj;
    };

    // Export the Underscore object for **Node.js**, with
    // backwards-compatibility for their old module API. If we're in
    // the browser, add `_` as a global object.
    // (`nodeType` is checked to ensure that `module`
    // and `exports` are not HTML elements.)
    if (!exports.nodeType) {
      if (!module.nodeType && module.exports) {
        exports = module.exports = _;
      }
      exports._ = _;
    } else {
      root._ = _;
    }

    // Current version.
    _.VERSION = '1.9.1';

    // Internal function that returns an efficient (for current engines) version
    // of the passed-in callback, to be repeatedly applied in other Underscore
    // functions.
    var optimizeCb = function(func, context, argCount) {
      if (context === void 0) return func;
      switch (argCount == null ? 3 : argCount) {
        case 1: return function(value) {
          return func.call(context, value);
        };
        // The 2-argument case is omitted because we’re not using it.
        case 3: return function(value, index, collection) {
          return func.call(context, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(context, accumulator, value, index, collection);
        };
      }
      return function() {
        return func.apply(context, arguments);
      };
    };

    var builtinIteratee;

    // An internal function to generate callbacks that can be applied to each
    // element in a collection, returning the desired result — either `identity`,
    // an arbitrary callback, a property matcher, or a property accessor.
    var cb = function(value, context, argCount) {
      if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
      if (value == null) return _.identity;
      if (_.isFunction(value)) return optimizeCb(value, context, argCount);
      if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
      return _.property(value);
    };

    // External wrapper for our callback generator. Users may customize
    // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
    // This abstraction hides the internal-only argCount argument.
    _.iteratee = builtinIteratee = function(value, context) {
      return cb(value, context, Infinity);
    };

    // Some functions take a variable number of arguments, or a few expected
    // arguments at the beginning and then a variable number of values to operate
    // on. This helper accumulates all remaining arguments past the function’s
    // argument length (or an explicit `startIndex`), into an array that becomes
    // the last argument. Similar to ES6’s "rest parameter".
    var restArguments = function(func, startIndex) {
      startIndex = startIndex == null ? func.length - 1 : +startIndex;
      return function() {
        var length = Math.max(arguments.length - startIndex, 0),
            rest = Array(length),
            index = 0;
        for (; index < length; index++) {
          rest[index] = arguments[index + startIndex];
        }
        switch (startIndex) {
          case 0: return func.call(this, rest);
          case 1: return func.call(this, arguments[0], rest);
          case 2: return func.call(this, arguments[0], arguments[1], rest);
        }
        var args = Array(startIndex + 1);
        for (index = 0; index < startIndex; index++) {
          args[index] = arguments[index];
        }
        args[startIndex] = rest;
        return func.apply(this, args);
      };
    };

    // An internal function for creating a new object that inherits from another.
    var baseCreate = function(prototype) {
      if (!_.isObject(prototype)) return {};
      if (nativeCreate) return nativeCreate(prototype);
      Ctor.prototype = prototype;
      var result = new Ctor;
      Ctor.prototype = null;
      return result;
    };

    var shallowProperty = function(key) {
      return function(obj) {
        return obj == null ? void 0 : obj[key];
      };
    };

    var has = function(obj, path) {
      return obj != null && hasOwnProperty.call(obj, path);
    };

    var deepGet = function(obj, path) {
      var length = path.length;
      for (var i = 0; i < length; i++) {
        if (obj == null) return void 0;
        obj = obj[path[i]];
      }
      return length ? obj : void 0;
    };

    // Helper for collection methods to determine whether a collection
    // should be iterated as an array or as an object.
    // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
    // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
    var getLength = shallowProperty('length');
    var isArrayLike = function(collection) {
      var length = getLength(collection);
      return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
    };

    // Collection Functions
    // --------------------

    // The cornerstone, an `each` implementation, aka `forEach`.
    // Handles raw objects in addition to array-likes. Treats all
    // sparse array-likes as if they were dense.
    _.each = _.forEach = function(obj, iteratee, context) {
      iteratee = optimizeCb(iteratee, context);
      var i, length;
      if (isArrayLike(obj)) {
        for (i = 0, length = obj.length; i < length; i++) {
          iteratee(obj[i], i, obj);
        }
      } else {
        var keys = _.keys(obj);
        for (i = 0, length = keys.length; i < length; i++) {
          iteratee(obj[keys[i]], keys[i], obj);
        }
      }
      return obj;
    };

    // Return the results of applying the iteratee to each element.
    _.map = _.collect = function(obj, iteratee, context) {
      iteratee = cb(iteratee, context);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          results = Array(length);
      for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        results[index] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
    };

    // Create a reducing function iterating left or right.
    var createReduce = function(dir) {
      // Wrap code that reassigns argument variables in a separate function than
      // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
      var reducer = function(obj, iteratee, memo, initial) {
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length,
            index = dir > 0 ? 0 : length - 1;
        if (!initial) {
          memo = obj[keys ? keys[index] : index];
          index += dir;
        }
        for (; index >= 0 && index < length; index += dir) {
          var currentKey = keys ? keys[index] : index;
          memo = iteratee(memo, obj[currentKey], currentKey, obj);
        }
        return memo;
      };

      return function(obj, iteratee, memo, context) {
        var initial = arguments.length >= 3;
        return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
      };
    };

    // **Reduce** builds up a single result from a list of values, aka `inject`,
    // or `foldl`.
    _.reduce = _.foldl = _.inject = createReduce(1);

    // The right-associative version of reduce, also known as `foldr`.
    _.reduceRight = _.foldr = createReduce(-1);

    // Return the first value which passes a truth test. Aliased as `detect`.
    _.find = _.detect = function(obj, predicate, context) {
      var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
      var key = keyFinder(obj, predicate, context);
      if (key !== void 0 && key !== -1) return obj[key];
    };

    // Return all the elements that pass a truth test.
    // Aliased as `select`.
    _.filter = _.select = function(obj, predicate, context) {
      var results = [];
      predicate = cb(predicate, context);
      _.each(obj, function(value, index, list) {
        if (predicate(value, index, list)) results.push(value);
      });
      return results;
    };

    // Return all the elements for which a truth test fails.
    _.reject = function(obj, predicate, context) {
      return _.filter(obj, _.negate(cb(predicate)), context);
    };

    // Determine whether all of the elements match a truth test.
    // Aliased as `all`.
    _.every = _.all = function(obj, predicate, context) {
      predicate = cb(predicate, context);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length;
      for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        if (!predicate(obj[currentKey], currentKey, obj)) return false;
      }
      return true;
    };

    // Determine if at least one element in the object matches a truth test.
    // Aliased as `any`.
    _.some = _.any = function(obj, predicate, context) {
      predicate = cb(predicate, context);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length;
      for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        if (predicate(obj[currentKey], currentKey, obj)) return true;
      }
      return false;
    };

    // Determine if the array or object contains a given item (using `===`).
    // Aliased as `includes` and `include`.
    _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      if (typeof fromIndex != 'number' || guard) fromIndex = 0;
      return _.indexOf(obj, item, fromIndex) >= 0;
    };

    // Invoke a method (with arguments) on every item in a collection.
    _.invoke = restArguments(function(obj, path, args) {
      var contextPath, func;
      if (_.isFunction(path)) {
        func = path;
      } else if (_.isArray(path)) {
        contextPath = path.slice(0, -1);
        path = path[path.length - 1];
      }
      return _.map(obj, function(context) {
        var method = func;
        if (!method) {
          if (contextPath && contextPath.length) {
            context = deepGet(context, contextPath);
          }
          if (context == null) return void 0;
          method = context[path];
        }
        return method == null ? method : method.apply(context, args);
      });
    });

    // Convenience version of a common use case of `map`: fetching a property.
    _.pluck = function(obj, key) {
      return _.map(obj, _.property(key));
    };

    // Convenience version of a common use case of `filter`: selecting only objects
    // containing specific `key:value` pairs.
    _.where = function(obj, attrs) {
      return _.filter(obj, _.matcher(attrs));
    };

    // Convenience version of a common use case of `find`: getting the first object
    // containing specific `key:value` pairs.
    _.findWhere = function(obj, attrs) {
      return _.find(obj, _.matcher(attrs));
    };

    // Return the maximum element (or element-based computation).
    _.max = function(obj, iteratee, context) {
      var result = -Infinity, lastComputed = -Infinity,
          value, computed;
      if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
        obj = isArrayLike(obj) ? obj : _.values(obj);
        for (var i = 0, length = obj.length; i < length; i++) {
          value = obj[i];
          if (value != null && value > result) {
            result = value;
          }
        }
      } else {
        iteratee = cb(iteratee, context);
        _.each(obj, function(v, index, list) {
          computed = iteratee(v, index, list);
          if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
            result = v;
            lastComputed = computed;
          }
        });
      }
      return result;
    };

    // Return the minimum element (or element-based computation).
    _.min = function(obj, iteratee, context) {
      var result = Infinity, lastComputed = Infinity,
          value, computed;
      if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
        obj = isArrayLike(obj) ? obj : _.values(obj);
        for (var i = 0, length = obj.length; i < length; i++) {
          value = obj[i];
          if (value != null && value < result) {
            result = value;
          }
        }
      } else {
        iteratee = cb(iteratee, context);
        _.each(obj, function(v, index, list) {
          computed = iteratee(v, index, list);
          if (computed < lastComputed || computed === Infinity && result === Infinity) {
            result = v;
            lastComputed = computed;
          }
        });
      }
      return result;
    };

    // Shuffle a collection.
    _.shuffle = function(obj) {
      return _.sample(obj, Infinity);
    };

    // Sample **n** random values from a collection using the modern version of the
    // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
    // If **n** is not specified, returns a single random element.
    // The internal `guard` argument allows it to work with `map`.
    _.sample = function(obj, n, guard) {
      if (n == null || guard) {
        if (!isArrayLike(obj)) obj = _.values(obj);
        return obj[_.random(obj.length - 1)];
      }
      var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
      var length = getLength(sample);
      n = Math.max(Math.min(n, length), 0);
      var last = length - 1;
      for (var index = 0; index < n; index++) {
        var rand = _.random(index, last);
        var temp = sample[index];
        sample[index] = sample[rand];
        sample[rand] = temp;
      }
      return sample.slice(0, n);
    };

    // Sort the object's values by a criterion produced by an iteratee.
    _.sortBy = function(obj, iteratee, context) {
      var index = 0;
      iteratee = cb(iteratee, context);
      return _.pluck(_.map(obj, function(value, key, list) {
        return {
          value: value,
          index: index++,
          criteria: iteratee(value, key, list)
        };
      }).sort(function(left, right) {
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
          if (a > b || a === void 0) return 1;
          if (a < b || b === void 0) return -1;
        }
        return left.index - right.index;
      }), 'value');
    };

    // An internal function used for aggregate "group by" operations.
    var group = function(behavior, partition) {
      return function(obj, iteratee, context) {
        var result = partition ? [[], []] : {};
        iteratee = cb(iteratee, context);
        _.each(obj, function(value, index) {
          var key = iteratee(value, index, obj);
          behavior(result, value, key);
        });
        return result;
      };
    };

    // Groups the object's values by a criterion. Pass either a string attribute
    // to group by, or a function that returns the criterion.
    _.groupBy = group(function(result, value, key) {
      if (has(result, key)) result[key].push(value); else result[key] = [value];
    });

    // Indexes the object's values by a criterion, similar to `groupBy`, but for
    // when you know that your index values will be unique.
    _.indexBy = group(function(result, value, key) {
      result[key] = value;
    });

    // Counts instances of an object that group by a certain criterion. Pass
    // either a string attribute to count by, or a function that returns the
    // criterion.
    _.countBy = group(function(result, value, key) {
      if (has(result, key)) result[key]++; else result[key] = 1;
    });

    var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
    // Safely create a real, live array from anything iterable.
    _.toArray = function(obj) {
      if (!obj) return [];
      if (_.isArray(obj)) return slice.call(obj);
      if (_.isString(obj)) {
        // Keep surrogate pair characters together
        return obj.match(reStrSymbol);
      }
      if (isArrayLike(obj)) return _.map(obj, _.identity);
      return _.values(obj);
    };

    // Return the number of elements in an object.
    _.size = function(obj) {
      if (obj == null) return 0;
      return isArrayLike(obj) ? obj.length : _.keys(obj).length;
    };

    // Split a collection into two arrays: one whose elements all satisfy the given
    // predicate, and one whose elements all do not satisfy the predicate.
    _.partition = group(function(result, value, pass) {
      result[pass ? 0 : 1].push(value);
    }, true);

    // Array Functions
    // ---------------

    // Get the first element of an array. Passing **n** will return the first N
    // values in the array. Aliased as `head` and `take`. The **guard** check
    // allows it to work with `_.map`.
    _.first = _.head = _.take = function(array, n, guard) {
      if (array == null || array.length < 1) return n == null ? void 0 : [];
      if (n == null || guard) return array[0];
      return _.initial(array, array.length - n);
    };

    // Returns everything but the last entry of the array. Especially useful on
    // the arguments object. Passing **n** will return all the values in
    // the array, excluding the last N.
    _.initial = function(array, n, guard) {
      return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
    };

    // Get the last element of an array. Passing **n** will return the last N
    // values in the array.
    _.last = function(array, n, guard) {
      if (array == null || array.length < 1) return n == null ? void 0 : [];
      if (n == null || guard) return array[array.length - 1];
      return _.rest(array, Math.max(0, array.length - n));
    };

    // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
    // Especially useful on the arguments object. Passing an **n** will return
    // the rest N values in the array.
    _.rest = _.tail = _.drop = function(array, n, guard) {
      return slice.call(array, n == null || guard ? 1 : n);
    };

    // Trim out all falsy values from an array.
    _.compact = function(array) {
      return _.filter(array, Boolean);
    };

    // Internal implementation of a recursive `flatten` function.
    var flatten = function(input, shallow, strict, output) {
      output = output || [];
      var idx = output.length;
      for (var i = 0, length = getLength(input); i < length; i++) {
        var value = input[i];
        if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
          // Flatten current level of array or arguments object.
          if (shallow) {
            var j = 0, len = value.length;
            while (j < len) output[idx++] = value[j++];
          } else {
            flatten(value, shallow, strict, output);
            idx = output.length;
          }
        } else if (!strict) {
          output[idx++] = value;
        }
      }
      return output;
    };

    // Flatten out an array, either recursively (by default), or just one level.
    _.flatten = function(array, shallow) {
      return flatten(array, shallow, false);
    };

    // Return a version of the array that does not contain the specified value(s).
    _.without = restArguments(function(array, otherArrays) {
      return _.difference(array, otherArrays);
    });

    // Produce a duplicate-free version of the array. If the array has already
    // been sorted, you have the option of using a faster algorithm.
    // The faster algorithm will not work with an iteratee if the iteratee
    // is not a one-to-one function, so providing an iteratee will disable
    // the faster algorithm.
    // Aliased as `unique`.
    _.uniq = _.unique = function(array, isSorted, iteratee, context) {
      if (!_.isBoolean(isSorted)) {
        context = iteratee;
        iteratee = isSorted;
        isSorted = false;
      }
      if (iteratee != null) iteratee = cb(iteratee, context);
      var result = [];
      var seen = [];
      for (var i = 0, length = getLength(array); i < length; i++) {
        var value = array[i],
            computed = iteratee ? iteratee(value, i, array) : value;
        if (isSorted && !iteratee) {
          if (!i || seen !== computed) result.push(value);
          seen = computed;
        } else if (iteratee) {
          if (!_.contains(seen, computed)) {
            seen.push(computed);
            result.push(value);
          }
        } else if (!_.contains(result, value)) {
          result.push(value);
        }
      }
      return result;
    };

    // Produce an array that contains the union: each distinct element from all of
    // the passed-in arrays.
    _.union = restArguments(function(arrays) {
      return _.uniq(flatten(arrays, true, true));
    });

    // Produce an array that contains every item shared between all the
    // passed-in arrays.
    _.intersection = function(array) {
      var result = [];
      var argsLength = arguments.length;
      for (var i = 0, length = getLength(array); i < length; i++) {
        var item = array[i];
        if (_.contains(result, item)) continue;
        var j;
        for (j = 1; j < argsLength; j++) {
          if (!_.contains(arguments[j], item)) break;
        }
        if (j === argsLength) result.push(item);
      }
      return result;
    };

    // Take the difference between one array and a number of other arrays.
    // Only the elements present in just the first array will remain.
    _.difference = restArguments(function(array, rest) {
      rest = flatten(rest, true, true);
      return _.filter(array, function(value){
        return !_.contains(rest, value);
      });
    });

    // Complement of _.zip. Unzip accepts an array of arrays and groups
    // each array's elements on shared indices.
    _.unzip = function(array) {
      var length = array && _.max(array, getLength).length || 0;
      var result = Array(length);

      for (var index = 0; index < length; index++) {
        result[index] = _.pluck(array, index);
      }
      return result;
    };

    // Zip together multiple lists into a single array -- elements that share
    // an index go together.
    _.zip = restArguments(_.unzip);

    // Converts lists into objects. Pass either a single array of `[key, value]`
    // pairs, or two parallel arrays of the same length -- one of keys, and one of
    // the corresponding values. Passing by pairs is the reverse of _.pairs.
    _.object = function(list, values) {
      var result = {};
      for (var i = 0, length = getLength(list); i < length; i++) {
        if (values) {
          result[list[i]] = values[i];
        } else {
          result[list[i][0]] = list[i][1];
        }
      }
      return result;
    };

    // Generator function to create the findIndex and findLastIndex functions.
    var createPredicateIndexFinder = function(dir) {
      return function(array, predicate, context) {
        predicate = cb(predicate, context);
        var length = getLength(array);
        var index = dir > 0 ? 0 : length - 1;
        for (; index >= 0 && index < length; index += dir) {
          if (predicate(array[index], index, array)) return index;
        }
        return -1;
      };
    };

    // Returns the first index on an array-like that passes a predicate test.
    _.findIndex = createPredicateIndexFinder(1);
    _.findLastIndex = createPredicateIndexFinder(-1);

    // Use a comparator function to figure out the smallest index at which
    // an object should be inserted so as to maintain order. Uses binary search.
    _.sortedIndex = function(array, obj, iteratee, context) {
      iteratee = cb(iteratee, context, 1);
      var value = iteratee(obj);
      var low = 0, high = getLength(array);
      while (low < high) {
        var mid = Math.floor((low + high) / 2);
        if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
      }
      return low;
    };

    // Generator function to create the indexOf and lastIndexOf functions.
    var createIndexFinder = function(dir, predicateFind, sortedIndex) {
      return function(array, item, idx) {
        var i = 0, length = getLength(array);
        if (typeof idx == 'number') {
          if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
          } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
          }
        } else if (sortedIndex && idx && length) {
          idx = sortedIndex(array, item);
          return array[idx] === item ? idx : -1;
        }
        if (item !== item) {
          idx = predicateFind(slice.call(array, i, length), _.isNaN);
          return idx >= 0 ? idx + i : -1;
        }
        for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
          if (array[idx] === item) return idx;
        }
        return -1;
      };
    };

    // Return the position of the first occurrence of an item in an array,
    // or -1 if the item is not included in the array.
    // If the array is large and already in sort order, pass `true`
    // for **isSorted** to use binary search.
    _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
    _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

    // Generate an integer Array containing an arithmetic progression. A port of
    // the native Python `range()` function. See
    // [the Python documentation](http://docs.python.org/library/functions.html#range).
    _.range = function(start, stop, step) {
      if (stop == null) {
        stop = start || 0;
        start = 0;
      }
      if (!step) {
        step = stop < start ? -1 : 1;
      }

      var length = Math.max(Math.ceil((stop - start) / step), 0);
      var range = Array(length);

      for (var idx = 0; idx < length; idx++, start += step) {
        range[idx] = start;
      }

      return range;
    };

    // Chunk a single array into multiple arrays, each containing `count` or fewer
    // items.
    _.chunk = function(array, count) {
      if (count == null || count < 1) return [];
      var result = [];
      var i = 0, length = array.length;
      while (i < length) {
        result.push(slice.call(array, i, i += count));
      }
      return result;
    };

    // Function (ahem) Functions
    // ------------------

    // Determines whether to execute a function as a constructor
    // or a normal function with the provided arguments.
    var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
      if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
      var self = baseCreate(sourceFunc.prototype);
      var result = sourceFunc.apply(self, args);
      if (_.isObject(result)) return result;
      return self;
    };

    // Create a function bound to a given object (assigning `this`, and arguments,
    // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
    // available.
    _.bind = restArguments(function(func, context, args) {
      if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
      var bound = restArguments(function(callArgs) {
        return executeBound(func, bound, context, this, args.concat(callArgs));
      });
      return bound;
    });

    // Partially apply a function by creating a version that has had some of its
    // arguments pre-filled, without changing its dynamic `this` context. _ acts
    // as a placeholder by default, allowing any combination of arguments to be
    // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
    _.partial = restArguments(function(func, boundArgs) {
      var placeholder = _.partial.placeholder;
      var bound = function() {
        var position = 0, length = boundArgs.length;
        var args = Array(length);
        for (var i = 0; i < length; i++) {
          args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
        }
        while (position < arguments.length) args.push(arguments[position++]);
        return executeBound(func, bound, this, this, args);
      };
      return bound;
    });

    _.partial.placeholder = _;

    // Bind a number of an object's methods to that object. Remaining arguments
    // are the method names to be bound. Useful for ensuring that all callbacks
    // defined on an object belong to it.
    _.bindAll = restArguments(function(obj, keys) {
      keys = flatten(keys, false, false);
      var index = keys.length;
      if (index < 1) throw new Error('bindAll must be passed function names');
      while (index--) {
        var key = keys[index];
        obj[key] = _.bind(obj[key], obj);
      }
    });

    // Memoize an expensive function by storing its results.
    _.memoize = function(func, hasher) {
      var memoize = function(key) {
        var cache = memoize.cache;
        var address = '' + (hasher ? hasher.apply(this, arguments) : key);
        if (!has(cache, address)) cache[address] = func.apply(this, arguments);
        return cache[address];
      };
      memoize.cache = {};
      return memoize;
    };

    // Delays a function for the given number of milliseconds, and then calls
    // it with the arguments supplied.
    _.delay = restArguments(function(func, wait, args) {
      return setTimeout(function() {
        return func.apply(null, args);
      }, wait);
    });

    // Defers a function, scheduling it to run after the current call stack has
    // cleared.
    _.defer = _.partial(_.delay, _, 1);

    // Returns a function, that, when invoked, will only be triggered at most once
    // during a given window of time. Normally, the throttled function will run
    // as much as it can, without ever going more than once per `wait` duration;
    // but if you'd like to disable the execution on the leading edge, pass
    // `{leading: false}`. To disable execution on the trailing edge, ditto.
    _.throttle = function(func, wait, options) {
      var timeout, context, args, result;
      var previous = 0;
      if (!options) options = {};

      var later = function() {
        previous = options.leading === false ? 0 : _.now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      };

      var throttled = function() {
        var now = _.now();
        if (!previous && options.leading === false) previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          previous = now;
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }
        return result;
      };

      throttled.cancel = function() {
        clearTimeout(timeout);
        previous = 0;
        timeout = context = args = null;
      };

      return throttled;
    };

    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.
    _.debounce = function(func, wait, immediate) {
      var timeout, result;

      var later = function(context, args) {
        timeout = null;
        if (args) result = func.apply(context, args);
      };

      var debounced = restArguments(function(args) {
        if (timeout) clearTimeout(timeout);
        if (immediate) {
          var callNow = !timeout;
          timeout = setTimeout(later, wait);
          if (callNow) result = func.apply(this, args);
        } else {
          timeout = _.delay(later, wait, this, args);
        }

        return result;
      });

      debounced.cancel = function() {
        clearTimeout(timeout);
        timeout = null;
      };

      return debounced;
    };

    // Returns the first function passed as an argument to the second,
    // allowing you to adjust arguments, run code before and after, and
    // conditionally execute the original function.
    _.wrap = function(func, wrapper) {
      return _.partial(wrapper, func);
    };

    // Returns a negated version of the passed-in predicate.
    _.negate = function(predicate) {
      return function() {
        return !predicate.apply(this, arguments);
      };
    };

    // Returns a function that is the composition of a list of functions, each
    // consuming the return value of the function that follows.
    _.compose = function() {
      var args = arguments;
      var start = args.length - 1;
      return function() {
        var i = start;
        var result = args[start].apply(this, arguments);
        while (i--) result = args[i].call(this, result);
        return result;
      };
    };

    // Returns a function that will only be executed on and after the Nth call.
    _.after = function(times, func) {
      return function() {
        if (--times < 1) {
          return func.apply(this, arguments);
        }
      };
    };

    // Returns a function that will only be executed up to (but not including) the Nth call.
    _.before = function(times, func) {
      var memo;
      return function() {
        if (--times > 0) {
          memo = func.apply(this, arguments);
        }
        if (times <= 1) func = null;
        return memo;
      };
    };

    // Returns a function that will be executed at most one time, no matter how
    // often you call it. Useful for lazy initialization.
    _.once = _.partial(_.before, 2);

    _.restArguments = restArguments;

    // Object Functions
    // ----------------

    // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
    var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
    var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

    var collectNonEnumProps = function(obj, keys) {
      var nonEnumIdx = nonEnumerableProps.length;
      var constructor = obj.constructor;
      var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

      // Constructor is a special case.
      var prop = 'constructor';
      if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

      while (nonEnumIdx--) {
        prop = nonEnumerableProps[nonEnumIdx];
        if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
          keys.push(prop);
        }
      }
    };

    // Retrieve the names of an object's own properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`.
    _.keys = function(obj) {
      if (!_.isObject(obj)) return [];
      if (nativeKeys) return nativeKeys(obj);
      var keys = [];
      for (var key in obj) if (has(obj, key)) keys.push(key);
      // Ahem, IE < 9.
      if (hasEnumBug) collectNonEnumProps(obj, keys);
      return keys;
    };

    // Retrieve all the property names of an object.
    _.allKeys = function(obj) {
      if (!_.isObject(obj)) return [];
      var keys = [];
      for (var key in obj) keys.push(key);
      // Ahem, IE < 9.
      if (hasEnumBug) collectNonEnumProps(obj, keys);
      return keys;
    };

    // Retrieve the values of an object's properties.
    _.values = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var values = Array(length);
      for (var i = 0; i < length; i++) {
        values[i] = obj[keys[i]];
      }
      return values;
    };

    // Returns the results of applying the iteratee to each element of the object.
    // In contrast to _.map it returns an object.
    _.mapObject = function(obj, iteratee, context) {
      iteratee = cb(iteratee, context);
      var keys = _.keys(obj),
          length = keys.length,
          results = {};
      for (var index = 0; index < length; index++) {
        var currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
    };

    // Convert an object into a list of `[key, value]` pairs.
    // The opposite of _.object.
    _.pairs = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var pairs = Array(length);
      for (var i = 0; i < length; i++) {
        pairs[i] = [keys[i], obj[keys[i]]];
      }
      return pairs;
    };

    // Invert the keys and values of an object. The values must be serializable.
    _.invert = function(obj) {
      var result = {};
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        result[obj[keys[i]]] = keys[i];
      }
      return result;
    };

    // Return a sorted list of the function names available on the object.
    // Aliased as `methods`.
    _.functions = _.methods = function(obj) {
      var names = [];
      for (var key in obj) {
        if (_.isFunction(obj[key])) names.push(key);
      }
      return names.sort();
    };

    // An internal function for creating assigner functions.
    var createAssigner = function(keysFunc, defaults) {
      return function(obj) {
        var length = arguments.length;
        if (defaults) obj = Object(obj);
        if (length < 2 || obj == null) return obj;
        for (var index = 1; index < length; index++) {
          var source = arguments[index],
              keys = keysFunc(source),
              l = keys.length;
          for (var i = 0; i < l; i++) {
            var key = keys[i];
            if (!defaults || obj[key] === void 0) obj[key] = source[key];
          }
        }
        return obj;
      };
    };

    // Extend a given object with all the properties in passed-in object(s).
    _.extend = createAssigner(_.allKeys);

    // Assigns a given object with all the own properties in the passed-in object(s).
    // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
    _.extendOwn = _.assign = createAssigner(_.keys);

    // Returns the first key on an object that passes a predicate test.
    _.findKey = function(obj, predicate, context) {
      predicate = cb(predicate, context);
      var keys = _.keys(obj), key;
      for (var i = 0, length = keys.length; i < length; i++) {
        key = keys[i];
        if (predicate(obj[key], key, obj)) return key;
      }
    };

    // Internal pick helper function to determine if `obj` has key `key`.
    var keyInObj = function(value, key, obj) {
      return key in obj;
    };

    // Return a copy of the object only containing the whitelisted properties.
    _.pick = restArguments(function(obj, keys) {
      var result = {}, iteratee = keys[0];
      if (obj == null) return result;
      if (_.isFunction(iteratee)) {
        if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
        keys = _.allKeys(obj);
      } else {
        iteratee = keyInObj;
        keys = flatten(keys, false, false);
        obj = Object(obj);
      }
      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i];
        var value = obj[key];
        if (iteratee(value, key, obj)) result[key] = value;
      }
      return result;
    });

    // Return a copy of the object without the blacklisted properties.
    _.omit = restArguments(function(obj, keys) {
      var iteratee = keys[0], context;
      if (_.isFunction(iteratee)) {
        iteratee = _.negate(iteratee);
        if (keys.length > 1) context = keys[1];
      } else {
        keys = _.map(flatten(keys, false, false), String);
        iteratee = function(value, key) {
          return !_.contains(keys, key);
        };
      }
      return _.pick(obj, iteratee, context);
    });

    // Fill in a given object with default properties.
    _.defaults = createAssigner(_.allKeys, true);

    // Creates an object that inherits from the given prototype object.
    // If additional properties are provided then they will be added to the
    // created object.
    _.create = function(prototype, props) {
      var result = baseCreate(prototype);
      if (props) _.extendOwn(result, props);
      return result;
    };

    // Create a (shallow-cloned) duplicate of an object.
    _.clone = function(obj) {
      if (!_.isObject(obj)) return obj;
      return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
    };

    // Invokes interceptor with the obj, and then returns obj.
    // The primary purpose of this method is to "tap into" a method chain, in
    // order to perform operations on intermediate results within the chain.
    _.tap = function(obj, interceptor) {
      interceptor(obj);
      return obj;
    };

    // Returns whether an object has a given set of `key:value` pairs.
    _.isMatch = function(object, attrs) {
      var keys = _.keys(attrs), length = keys.length;
      if (object == null) return !length;
      var obj = Object(object);
      for (var i = 0; i < length; i++) {
        var key = keys[i];
        if (attrs[key] !== obj[key] || !(key in obj)) return false;
      }
      return true;
    };


    // Internal recursive comparison function for `isEqual`.
    var eq, deepEq;
    eq = function(a, b, aStack, bStack) {
      // Identical objects are equal. `0 === -0`, but they aren't identical.
      // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
      if (a === b) return a !== 0 || 1 / a === 1 / b;
      // `null` or `undefined` only equal to itself (strict comparison).
      if (a == null || b == null) return false;
      // `NaN`s are equivalent, but non-reflexive.
      if (a !== a) return b !== b;
      // Exhaust primitive checks
      var type = typeof a;
      if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
      return deepEq(a, b, aStack, bStack);
    };

    // Internal recursive comparison function for `isEqual`.
    deepEq = function(a, b, aStack, bStack) {
      // Unwrap any wrapped objects.
      if (a instanceof _) a = a._wrapped;
      if (b instanceof _) b = b._wrapped;
      // Compare `[[Class]]` names.
      var className = toString.call(a);
      if (className !== toString.call(b)) return false;
      switch (className) {
        // Strings, numbers, regular expressions, dates, and booleans are compared by value.
        case '[object RegExp]':
        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
        case '[object String]':
          // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
          // equivalent to `new String("5")`.
          return '' + a === '' + b;
        case '[object Number]':
          // `NaN`s are equivalent, but non-reflexive.
          // Object(NaN) is equivalent to NaN.
          if (+a !== +a) return +b !== +b;
          // An `egal` comparison is performed for other numeric values.
          return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case '[object Date]':
        case '[object Boolean]':
          // Coerce dates and booleans to numeric primitive values. Dates are compared by their
          // millisecond representations. Note that invalid dates with millisecond representations
          // of `NaN` are not equivalent.
          return +a === +b;
        case '[object Symbol]':
          return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
      }

      var areArrays = className === '[object Array]';
      if (!areArrays) {
        if (typeof a != 'object' || typeof b != 'object') return false;

        // Objects with different constructors are not equivalent, but `Object`s or `Array`s
        // from different frames are.
        var aCtor = a.constructor, bCtor = b.constructor;
        if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                                 _.isFunction(bCtor) && bCtor instanceof bCtor)
                            && ('constructor' in a && 'constructor' in b)) {
          return false;
        }
      }
      // Assume equality for cyclic structures. The algorithm for detecting cyclic
      // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

      // Initializing stack of traversed objects.
      // It's done here since we only need them for objects and arrays comparison.
      aStack = aStack || [];
      bStack = bStack || [];
      var length = aStack.length;
      while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] === a) return bStack[length] === b;
      }

      // Add the first object to the stack of traversed objects.
      aStack.push(a);
      bStack.push(b);

      // Recursively compare objects and arrays.
      if (areArrays) {
        // Compare array lengths to determine if a deep comparison is necessary.
        length = a.length;
        if (length !== b.length) return false;
        // Deep compare the contents, ignoring non-numeric properties.
        while (length--) {
          if (!eq(a[length], b[length], aStack, bStack)) return false;
        }
      } else {
        // Deep compare objects.
        var keys = _.keys(a), key;
        length = keys.length;
        // Ensure that both objects contain the same number of properties before comparing deep equality.
        if (_.keys(b).length !== length) return false;
        while (length--) {
          // Deep compare each member
          key = keys[length];
          if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
        }
      }
      // Remove the first object from the stack of traversed objects.
      aStack.pop();
      bStack.pop();
      return true;
    };

    // Perform a deep comparison to check if two objects are equal.
    _.isEqual = function(a, b) {
      return eq(a, b);
    };

    // Is a given array, string, or object empty?
    // An "empty" object has no enumerable own-properties.
    _.isEmpty = function(obj) {
      if (obj == null) return true;
      if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
      return _.keys(obj).length === 0;
    };

    // Is a given value a DOM element?
    _.isElement = function(obj) {
      return !!(obj && obj.nodeType === 1);
    };

    // Is a given value an array?
    // Delegates to ECMA5's native Array.isArray
    _.isArray = nativeIsArray || function(obj) {
      return toString.call(obj) === '[object Array]';
    };

    // Is a given variable an object?
    _.isObject = function(obj) {
      var type = typeof obj;
      return type === 'function' || type === 'object' && !!obj;
    };

    // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
    _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {
      _['is' + name] = function(obj) {
        return toString.call(obj) === '[object ' + name + ']';
      };
    });

    // Define a fallback version of the method in browsers (ahem, IE < 9), where
    // there isn't any inspectable "Arguments" type.
    if (!_.isArguments(arguments)) {
      _.isArguments = function(obj) {
        return has(obj, 'callee');
      };
    }

    // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
    // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
    var nodelist = root.document && root.document.childNodes;
    if (typeof Int8Array != 'object' && typeof nodelist != 'function') {
      _.isFunction = function(obj) {
        return typeof obj == 'function' || false;
      };
    }

    // Is a given object a finite number?
    _.isFinite = function(obj) {
      return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
    };

    // Is the given value `NaN`?
    _.isNaN = function(obj) {
      return _.isNumber(obj) && isNaN(obj);
    };

    // Is a given value a boolean?
    _.isBoolean = function(obj) {
      return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
    };

    // Is a given value equal to null?
    _.isNull = function(obj) {
      return obj === null;
    };

    // Is a given variable undefined?
    _.isUndefined = function(obj) {
      return obj === void 0;
    };

    // Shortcut function for checking if an object has a given property directly
    // on itself (in other words, not on a prototype).
    _.has = function(obj, path) {
      if (!_.isArray(path)) {
        return has(obj, path);
      }
      var length = path.length;
      for (var i = 0; i < length; i++) {
        var key = path[i];
        if (obj == null || !hasOwnProperty.call(obj, key)) {
          return false;
        }
        obj = obj[key];
      }
      return !!length;
    };

    // Utility Functions
    // -----------------

    // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
    // previous owner. Returns a reference to the Underscore object.
    _.noConflict = function() {
      root._ = previousUnderscore;
      return this;
    };

    // Keep the identity function around for default iteratees.
    _.identity = function(value) {
      return value;
    };

    // Predicate-generating functions. Often useful outside of Underscore.
    _.constant = function(value) {
      return function() {
        return value;
      };
    };

    _.noop = function(){};

    // Creates a function that, when passed an object, will traverse that object’s
    // properties down the given `path`, specified as an array of keys or indexes.
    _.property = function(path) {
      if (!_.isArray(path)) {
        return shallowProperty(path);
      }
      return function(obj) {
        return deepGet(obj, path);
      };
    };

    // Generates a function for a given object that returns a given property.
    _.propertyOf = function(obj) {
      if (obj == null) {
        return function(){};
      }
      return function(path) {
        return !_.isArray(path) ? obj[path] : deepGet(obj, path);
      };
    };

    // Returns a predicate for checking whether an object has a given set of
    // `key:value` pairs.
    _.matcher = _.matches = function(attrs) {
      attrs = _.extendOwn({}, attrs);
      return function(obj) {
        return _.isMatch(obj, attrs);
      };
    };

    // Run a function **n** times.
    _.times = function(n, iteratee, context) {
      var accum = Array(Math.max(0, n));
      iteratee = optimizeCb(iteratee, context, 1);
      for (var i = 0; i < n; i++) accum[i] = iteratee(i);
      return accum;
    };

    // Return a random integer between min and max (inclusive).
    _.random = function(min, max) {
      if (max == null) {
        max = min;
        min = 0;
      }
      return min + Math.floor(Math.random() * (max - min + 1));
    };

    // A (possibly faster) way to get the current timestamp as an integer.
    _.now = Date.now || function() {
      return new Date().getTime();
    };

    // List of HTML entities for escaping.
    var escapeMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '`': '&#x60;'
    };
    var unescapeMap = _.invert(escapeMap);

    // Functions for escaping and unescaping strings to/from HTML interpolation.
    var createEscaper = function(map) {
      var escaper = function(match) {
        return map[match];
      };
      // Regexes for identifying a key that needs to be escaped.
      var source = '(?:' + _.keys(map).join('|') + ')';
      var testRegexp = RegExp(source);
      var replaceRegexp = RegExp(source, 'g');
      return function(string) {
        string = string == null ? '' : '' + string;
        return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
      };
    };
    _.escape = createEscaper(escapeMap);
    _.unescape = createEscaper(unescapeMap);

    // Traverses the children of `obj` along `path`. If a child is a function, it
    // is invoked with its parent as context. Returns the value of the final
    // child, or `fallback` if any child is undefined.
    _.result = function(obj, path, fallback) {
      if (!_.isArray(path)) path = [path];
      var length = path.length;
      if (!length) {
        return _.isFunction(fallback) ? fallback.call(obj) : fallback;
      }
      for (var i = 0; i < length; i++) {
        var prop = obj == null ? void 0 : obj[path[i]];
        if (prop === void 0) {
          prop = fallback;
          i = length; // Ensure we don't continue iterating.
        }
        obj = _.isFunction(prop) ? prop.call(obj) : prop;
      }
      return obj;
    };

    // Generate a unique integer id (unique within the entire client session).
    // Useful for temporary DOM ids.
    var idCounter = 0;
    _.uniqueId = function(prefix) {
      var id = ++idCounter + '';
      return prefix ? prefix + id : id;
    };

    // By default, Underscore uses ERB-style template delimiters, change the
    // following template settings to use alternative delimiters.
    _.templateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      escape: /<%-([\s\S]+?)%>/g
    };

    // When customizing `templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /(.)^/;

    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
      "'": "'",
      '\\': '\\',
      '\r': 'r',
      '\n': 'n',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };

    var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

    var escapeChar = function(match) {
      return '\\' + escapes[match];
    };

    // JavaScript micro-templating, similar to John Resig's implementation.
    // Underscore templating handles arbitrary delimiters, preserves whitespace,
    // and correctly escapes quotes within interpolated code.
    // NB: `oldSettings` only exists for backwards compatibility.
    _.template = function(text, settings, oldSettings) {
      if (!settings && oldSettings) settings = oldSettings;
      settings = _.defaults({}, settings, _.templateSettings);

      // Combine delimiters into one regular expression via alternation.
      var matcher = RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
      ].join('|') + '|$', 'g');

      // Compile the template source, escaping string literals appropriately.
      var index = 0;
      var source = "__p+='";
      text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
        source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
        index = offset + match.length;

        if (escape) {
          source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
        } else if (interpolate) {
          source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
        } else if (evaluate) {
          source += "';\n" + evaluate + "\n__p+='";
        }

        // Adobe VMs need the match returned to produce the correct offset.
        return match;
      });
      source += "';\n";

      // If a variable is not specified, place data values in local scope.
      if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

      source = "var __t,__p='',__j=Array.prototype.join," +
        "print=function(){__p+=__j.call(arguments,'');};\n" +
        source + 'return __p;\n';

      var render;
      try {
        render = new Function(settings.variable || 'obj', '_', source);
      } catch (e) {
        e.source = source;
        throw e;
      }

      var template = function(data) {
        return render.call(this, data, _);
      };

      // Provide the compiled source as a convenience for precompilation.
      var argument = settings.variable || 'obj';
      template.source = 'function(' + argument + '){\n' + source + '}';

      return template;
    };

    // Add a "chain" function. Start chaining a wrapped Underscore object.
    _.chain = function(obj) {
      var instance = _(obj);
      instance._chain = true;
      return instance;
    };

    // OOP
    // ---------------
    // If Underscore is called as a function, it returns a wrapped object that
    // can be used OO-style. This wrapper holds altered versions of all the
    // underscore functions. Wrapped objects may be chained.

    // Helper function to continue chaining intermediate results.
    var chainResult = function(instance, obj) {
      return instance._chain ? _(obj).chain() : obj;
    };

    // Add your own custom functions to the Underscore object.
    _.mixin = function(obj) {
      _.each(_.functions(obj), function(name) {
        var func = _[name] = obj[name];
        _.prototype[name] = function() {
          var args = [this._wrapped];
          push.apply(args, arguments);
          return chainResult(this, func.apply(_, args));
        };
      });
      return _;
    };

    // Add all of the Underscore functions to the wrapper object.
    _.mixin(_);

    // Add all mutator Array functions to the wrapper.
    _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj = this._wrapped;
        method.apply(obj, arguments);
        if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
        return chainResult(this, obj);
      };
    });

    // Add all accessor Array functions to the wrapper.
    _.each(['concat', 'join', 'slice'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        return chainResult(this, method.apply(this._wrapped, arguments));
      };
    });

    // Extracts the result from a wrapped and chained object.
    _.prototype.value = function() {
      return this._wrapped;
    };

    // Provide unwrapping proxy for some methods used in engine operations
    // such as arithmetic and JSON stringification.
    _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

    _.prototype.toString = function() {
      return String(this._wrapped);
    };
  }());
  });
  var underscore_1 = underscore._;

  /**
   * Ensure some object is a coerced to a string
   **/
  var makeString = function makeString(object) {
    if (object == null) return '';
    return '' + object;
  };

  var isBlank = function isBlank(str) {
    return (/^\s*$/).test(makeString(str));
  };

  var stripTags = function stripTags(str) {
    return makeString(str).replace(/<\/?[^>]+>/g, '');
  };

  var capitalize = function capitalize(str, lowercaseRest) {
    str = makeString(str);
    var remainingChars = !lowercaseRest ? str.slice(1) : str.slice(1).toLowerCase();

    return str.charAt(0).toUpperCase() + remainingChars;
  };

  var decapitalize = function decapitalize(str) {
    str = makeString(str);
    return str.charAt(0).toLowerCase() + str.slice(1);
  };

  var chop = function chop(str, step) {
    if (str == null) return [];
    str = String(str);
    step = ~~step;
    return step > 0 ? str.match(new RegExp('.{1,' + step + '}', 'g')) : [str];
  };

  var escapeRegExp = function escapeRegExp(str) {
    return makeString(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
  };

  var defaultToWhiteSpace = function defaultToWhiteSpace(characters) {
    if (characters == null)
      return '\\s';
    else if (characters.source)
      return characters.source;
    else
      return '[' + escapeRegExp(characters) + ']';
  };

  var nativeTrim = String.prototype.trim;

  var trim = function trim(str, characters) {
    str = makeString(str);
    if (!characters && nativeTrim) return nativeTrim.call(str);
    characters = defaultToWhiteSpace(characters);
    return str.replace(new RegExp('^' + characters + '+|' + characters + '+$', 'g'), '');
  };

  var clean = function clean(str) {
    return trim(str).replace(/\s\s+/g, ' ');
  };

  var from  = 'ąàáäâãåæăćčĉęèéëêĝĥìíïîĵłľńňòóöőôõðøśșşšŝťțţŭùúüűûñÿýçżźž',
    to    = 'aaaaaaaaaccceeeeeghiiiijllnnoooooooossssstttuuuuuunyyczzz';

  from += from.toUpperCase();
  to += to.toUpperCase();

  to = to.split('');

  // for tokens requireing multitoken output
  from += 'ß';
  to.push('ss');


  var cleanDiacritics = function cleanDiacritics(str) {
    return makeString(str).replace(/.{1}/g, function(c){
      var index = from.indexOf(c);
      return index === -1 ? c : to[index];
    });
  };

  var count = function(str, substr) {
    str = makeString(str);
    substr = makeString(substr);

    if (str.length === 0 || substr.length === 0) return 0;
    
    return str.split(substr).length - 1;
  };

  var chars = function chars(str) {
    return makeString(str).split('');
  };

  var swapCase = function swapCase(str) {
    return makeString(str).replace(/\S/g, function(c) {
      return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase();
    });
  };

  /* We're explicitly defining the list of entities we want to escape.
  nbsp is an HTML entity, but we don't want to escape all space characters in a string, hence its omission in this map.

  */
  var escapeChars = {
    '¢' : 'cent',
    '£' : 'pound',
    '¥' : 'yen',
    '€': 'euro',
    '©' :'copy',
    '®' : 'reg',
    '<' : 'lt',
    '>' : 'gt',
    '"' : 'quot',
    '&' : 'amp',
    '\'' : '#39'
  };

  var escapeChars_1 = escapeChars;

  var regexString = '[';
  for(var key in escapeChars_1) {
    regexString += key;
  }
  regexString += ']';

  var regex = new RegExp( regexString, 'g');

  var escapeHTML = function escapeHTML(str) {

    return makeString(str).replace(regex, function(m) {
      return '&' + escapeChars_1[m] + ';';
    });
  };

  /*
  We're explicitly defining the list of entities that might see in escape HTML strings
  */
  var htmlEntities = {
    nbsp: ' ',
    cent: '¢',
    pound: '£',
    yen: '¥',
    euro: '€',
    copy: '©',
    reg: '®',
    lt: '<',
    gt: '>',
    quot: '"',
    amp: '&',
    apos: '\''
  };

  var htmlEntities_1 = htmlEntities;

  var unescapeHTML = function unescapeHTML(str) {
    return makeString(str).replace(/\&([^;]{1,10});/g, function(entity, entityCode) {
      var match;

      if (entityCode in htmlEntities_1) {
        return htmlEntities_1[entityCode];
      /*eslint no-cond-assign: 0*/
      } else if (match = entityCode.match(/^#x([\da-fA-F]+)$/)) {
        return String.fromCharCode(parseInt(match[1], 16));
      /*eslint no-cond-assign: 0*/
      } else if (match = entityCode.match(/^#(\d+)$/)) {
        return String.fromCharCode(~~match[1]);
      } else {
        return entity;
      }
    });
  };

  var splice = function splice(str, i, howmany, substr) {
    var arr = chars(str);
    arr.splice(~~i, ~~howmany, substr);
    return arr.join('');
  };

  var insert = function insert(str, i, substr) {
    return splice(str, i, 0, substr);
  };

  var replaceAll = function replaceAll(str, find, replace, ignorecase) {
    var flags = (ignorecase === true)?'gi':'g';
    var reg = new RegExp(find, flags);

    return makeString(str).replace(reg, replace);
  };

  var include = function include(str, needle) {
    if (needle === '') return true;
    return makeString(str).indexOf(needle) !== -1;
  };

  var slice = [].slice;

  var join = function join() {
    var args = slice.call(arguments),
      separator = args.shift();

    return args.join(makeString(separator));
  };

  var lines = function lines(str) {
    if (str == null) return [];
    return String(str).split(/\r\n?|\n/);
  };

  function getIndent(str) {
    var matches = str.match(/^[\s\\t]*/gm);
    var indent = matches[0].length;
    
    for (var i = 1; i < matches.length; i++) {
      indent = Math.min(matches[i].length, indent);
    }

    return indent;
  }

  var dedent = function dedent(str, pattern) {
    str = makeString(str);
    var indent = getIndent(str);
    var reg;

    if (indent === 0) return str;

    if (typeof pattern === 'string') {
      reg = new RegExp('^' + pattern, 'gm');
    } else {
      reg = new RegExp('^[ \\t]{' + indent + '}', 'gm');
    }

    return str.replace(reg, '');
  };

  var reverse = function reverse(str) {
    return chars(str).reverse().join('');
  };

  var toPositive = function toPositive(number) {
    return number < 0 ? 0 : (+number || 0);
  };

  var startsWith = function startsWith(str, starts, position) {
    str = makeString(str);
    starts = '' + starts;
    position = position == null ? 0 : Math.min(toPositive(position), str.length);
    return str.lastIndexOf(starts, position) === position;
  };

  var endsWith = function endsWith(str, ends, position) {
    str = makeString(str);
    ends = '' + ends;
    if (typeof position == 'undefined') {
      position = str.length - ends.length;
    } else {
      position = Math.min(toPositive(position), str.length) - ends.length;
    }
    return position >= 0 && str.indexOf(ends, position) === position;
  };

  var adjacent = function adjacent(str, direction) {
    str = makeString(str);
    if (str.length === 0) {
      return '';
    }
    return str.slice(0, -1) + String.fromCharCode(str.charCodeAt(str.length - 1) + direction);
  };

  var pred = function succ(str) {
    return adjacent(str, -1);
  };

  var succ = function succ(str) {
    return adjacent(str, 1);
  };

  var titleize = function titleize(str) {
    return makeString(str).toLowerCase().replace(/(?:^|\s|-)\S/g, function(c) {
      return c.toUpperCase();
    });
  };

  var camelize = function camelize(str, decapitalize$$1) {
    str = trim(str).replace(/[-_\s]+(.)?/g, function(match, c) {
      return c ? c.toUpperCase() : '';
    });

    if (decapitalize$$1 === true) {
      return decapitalize(str);
    } else {
      return str;
    }
  };

  var underscored = function underscored(str) {
    return trim(str).replace(/([a-z\d])([A-Z]+)/g, '$1_$2').replace(/[-\s]+/g, '_').toLowerCase();
  };

  var dasherize = function dasherize(str) {
    return trim(str).replace(/([A-Z])/g, '-$1').replace(/[-_\s]+/g, '-').toLowerCase();
  };

  var classify = function classify(str) {
    str = makeString(str);
    return capitalize(camelize(str.replace(/[\W_]/g, ' ')).replace(/\s/g, ''));
  };

  var humanize = function humanize(str) {
    return capitalize(trim(underscored(str).replace(/_id$/, '').replace(/_/g, ' ')));
  };

  var nativeTrimLeft = String.prototype.trimLeft;

  var ltrim = function ltrim(str, characters) {
    str = makeString(str);
    if (!characters && nativeTrimLeft) return nativeTrimLeft.call(str);
    characters = defaultToWhiteSpace(characters);
    return str.replace(new RegExp('^' + characters + '+'), '');
  };

  var nativeTrimRight = String.prototype.trimRight;

  var rtrim = function rtrim(str, characters) {
    str = makeString(str);
    if (!characters && nativeTrimRight) return nativeTrimRight.call(str);
    characters = defaultToWhiteSpace(characters);
    return str.replace(new RegExp(characters + '+$'), '');
  };

  var truncate = function truncate(str, length, truncateStr) {
    str = makeString(str);
    truncateStr = truncateStr || '...';
    length = ~~length;
    return str.length > length ? str.slice(0, length) + truncateStr : str;
  };

  /**
   * _s.prune: a more elegant version of truncate
   * prune extra chars, never leaving a half-chopped word.
   * @author github.com/rwz
   */



  var prune = function prune(str, length, pruneStr) {
    str = makeString(str);
    length = ~~length;
    pruneStr = pruneStr != null ? String(pruneStr) : '...';

    if (str.length <= length) return str;

    var tmpl = function(c) {
        return c.toUpperCase() !== c.toLowerCase() ? 'A' : ' ';
      },
      template = str.slice(0, length + 1).replace(/.(?=\W*\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'

    if (template.slice(template.length - 2).match(/\w\w/))
      template = template.replace(/\s*\S+$/, '');
    else
      template = rtrim(template.slice(0, template.length - 1));

    return (template + pruneStr).length > str.length ? str : str.slice(0, template.length) + pruneStr;
  };

  var words = function words(str, delimiter) {
    if (isBlank(str)) return [];
    return trim(str, delimiter).split(delimiter || /\s+/);
  };

  var strRepeat = function strRepeat(str, qty){
    if (qty < 1) return '';
    var result = '';
    while (qty > 0) {
      if (qty & 1) result += str;
      qty >>= 1, str += str;
    }
    return result;
  };

  var pad = function pad(str, length, padStr, type) {
    str = makeString(str);
    length = ~~length;

    var padlen = 0;

    if (!padStr)
      padStr = ' ';
    else if (padStr.length > 1)
      padStr = padStr.charAt(0);

    switch (type) {
    case 'right':
      padlen = length - str.length;
      return str + strRepeat(padStr, padlen);
    case 'both':
      padlen = length - str.length;
      return strRepeat(padStr, Math.ceil(padlen / 2)) + str + strRepeat(padStr, Math.floor(padlen / 2));
    default: // 'left'
      padlen = length - str.length;
      return strRepeat(padStr, padlen) + str;
    }
  };

  var lpad = function lpad(str, length, padStr) {
    return pad(str, length, padStr);
  };

  var rpad = function rpad(str, length, padStr) {
    return pad(str, length, padStr, 'right');
  };

  var lrpad = function lrpad(str, length, padStr) {
    return pad(str, length, padStr, 'both');
  };

  // shim for using process in browser
  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

  function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
  }
  function defaultClearTimeout () {
      throw new Error('clearTimeout has not been defined');
  }
  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;
  if (typeof global.setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
  }
  if (typeof global.clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
  }

  function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
      }
      // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
      } catch(e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
          } catch(e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
          }
      }


  }
  function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
      }
      // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
      } catch (e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
          } catch (e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
          }
      }



  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
      if (!draining || !currentQueue) {
          return;
      }
      draining = false;
      if (currentQueue.length) {
          queue = currentQueue.concat(queue);
      } else {
          queueIndex = -1;
      }
      if (queue.length) {
          drainQueue();
      }
  }

  function drainQueue() {
      if (draining) {
          return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;

      var len = queue.length;
      while(len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
              if (currentQueue) {
                  currentQueue[queueIndex].run();
              }
          }
          queueIndex = -1;
          len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
  }
  function nextTick(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
          }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
      }
  }
  // v8 likes predictible objects
  function Item(fun, array) {
      this.fun = fun;
      this.array = array;
  }
  Item.prototype.run = function () {
      this.fun.apply(null, this.array);
  };
  var title = 'browser';
  var platform = 'browser';
  var browser = true;
  var env = {};
  var argv = [];
  var version = ''; // empty string to avoid regexp issues
  var versions = {};
  var release = {};
  var config = {};

  function noop() {}

  var on = noop;
  var addListener = noop;
  var once = noop;
  var off = noop;
  var removeListener = noop;
  var removeAllListeners = noop;
  var emit = noop;

  function binding(name) {
      throw new Error('process.binding is not supported');
  }

  function cwd () { return '/' }
  function chdir (dir) {
      throw new Error('process.chdir is not supported');
  }function umask() { return 0; }

  // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
  var performance = global.performance || {};
  var performanceNow =
    performance.now        ||
    performance.mozNow     ||
    performance.msNow      ||
    performance.oNow       ||
    performance.webkitNow  ||
    function(){ return (new Date()).getTime() };

  // generate timestamp or delta
  // see http://nodejs.org/api/process.html#process_process_hrtime
  function hrtime(previousTimestamp){
    var clocktime = performanceNow.call(performance)*1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor((clocktime%1)*1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds<0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds,nanoseconds]
  }

  var startTime = new Date();
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1000;
  }

  var process$1 = {
    nextTick: nextTick,
    title: title,
    browser: browser,
    env: env,
    argv: argv,
    version: version,
    versions: versions,
    on: on,
    addListener: addListener,
    once: once,
    off: off,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    emit: emit,
    binding: binding,
    cwd: cwd,
    chdir: chdir,
    umask: umask,
    hrtime: hrtime,
    platform: platform,
    release: release,
    config: config,
    uptime: uptime
  };

  var inherits;
  if (typeof Object.create === 'function'){
    inherits = function inherits(ctor, superCtor) {
      // implementation from standard node.js 'util' module
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    inherits = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  var inherits$1 = inherits;

  // Copyright Joyent, Inc. and other Node contributors.
  var formatRegExp = /%[sdj%]/g;
  function format(f) {
    if (!isString(f)) {
      var objects = [];
      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect(arguments[i]));
      }
      return objects.join(' ');
    }

    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x) {
      if (x === '%%') return '%';
      if (i >= len) return x;
      switch (x) {
        case '%s': return String(args[i++]);
        case '%d': return Number(args[i++]);
        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }
        default:
          return x;
      }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject(x)) {
        str += ' ' + x;
      } else {
        str += ' ' + inspect(x);
      }
    }
    return str;
  }

  // Mark that a method should not be used.
  // Returns a modified function which warns once by default.
  // If --no-deprecation is set, then it is a no-op.
  function deprecate(fn, msg) {
    // Allow for deprecating things in the process of starting up.
    if (isUndefined(global.process)) {
      return function() {
        return deprecate(fn, msg).apply(this, arguments);
      };
    }

    var warned = false;
    function deprecated() {
      if (!warned) {
        {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }

    return deprecated;
  }

  var debugs = {};
  var debugEnviron;
  function debuglog(set) {
    if (isUndefined(debugEnviron))
      debugEnviron = process$1.env.NODE_DEBUG || '';
    set = set.toUpperCase();
    if (!debugs[set]) {
      if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
        var pid = 0;
        debugs[set] = function() {
          var msg = format.apply(null, arguments);
          console.error('%s %d: %s', set, pid, msg);
        };
      } else {
        debugs[set] = function() {};
      }
    }
    return debugs[set];
  }

  /**
   * Echos the value of a value. Trys to print the value out
   * in the best way possible given the different types.
   *
   * @param {Object} obj The object to print out.
   * @param {Object} opts Optional options object that alters the output.
   */
  /* legacy: obj, showHidden, depth, colors*/
  function inspect(obj, opts) {
    // default options
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    // legacy...
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];
    if (isBoolean(opts)) {
      // legacy...
      ctx.showHidden = opts;
    } else if (opts) {
      // got an "options" object
      _extend(ctx, opts);
    }
    // set default options
    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }

  // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
  inspect.colors = {
    'bold' : [1, 22],
    'italic' : [3, 23],
    'underline' : [4, 24],
    'inverse' : [7, 27],
    'white' : [37, 39],
    'grey' : [90, 39],
    'black' : [30, 39],
    'blue' : [34, 39],
    'cyan' : [36, 39],
    'green' : [32, 39],
    'magenta' : [35, 39],
    'red' : [31, 39],
    'yellow' : [33, 39]
  };

  // Don't use 'blue' not visible on cmd.exe
  inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    // "name": intentionally not styling
    'regexp': 'red'
  };


  function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];

    if (style) {
      return '\u001b[' + inspect.colors[style][0] + 'm' + str +
             '\u001b[' + inspect.colors[style][1] + 'm';
    } else {
      return str;
    }
  }


  function stylizeNoColor(str, styleType) {
    return str;
  }


  function arrayToHash(array) {
    var hash = {};

    array.forEach(function(val, idx) {
      hash[val] = true;
    });

    return hash;
  }


  function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect &&
        value &&
        isFunction(value.inspect) &&
        // Filter out the util module, it's inspect function is special
        value.inspect !== inspect &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }

    // Primitive types cannot have properties
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }

    // Look up the keys of the object.
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);

    if (ctx.showHidden) {
      keys = Object.getOwnPropertyNames(value);
    }

    // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
    if (isError(value)
        && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
      return formatError(value);
    }

    // Some type of object without properties can be shortcutted.
    if (keys.length === 0) {
      if (isFunction(value)) {
        var name = value.name ? ': ' + value.name : '';
        return ctx.stylize('[Function' + name + ']', 'special');
      }
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }
      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), 'date');
      }
      if (isError(value)) {
        return formatError(value);
      }
    }

    var base = '', array = false, braces = ['{', '}'];

    // Make Array say that they are Array
    if (isArray(value)) {
      array = true;
      braces = ['[', ']'];
    }

    // Make functions say that they are functions
    if (isFunction(value)) {
      var n = value.name ? ': ' + value.name : '';
      base = ' [Function' + n + ']';
    }

    // Make RegExps say that they are RegExps
    if (isRegExp(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    }

    // Make error with message first say the error
    if (isError(value)) {
      base = ' ' + formatError(value);
    }

    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }

    ctx.seen.push(value);

    var output;
    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
      output = keys.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }

    ctx.seen.pop();

    return reduceToSingleString(output, base, braces);
  }


  function formatPrimitive(ctx, value) {
    if (isUndefined(value))
      return ctx.stylize('undefined', 'undefined');
    if (isString(value)) {
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');
    }
    if (isNumber(value))
      return ctx.stylize('' + value, 'number');
    if (isBoolean(value))
      return ctx.stylize('' + value, 'boolean');
    // For some reason typeof null is "object", so special case here.
    if (isNull(value))
      return ctx.stylize('null', 'null');
  }


  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }


  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for (var i = 0, l = value.length; i < l; ++i) {
      if (hasOwnProperty(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            String(i), true));
      } else {
        output.push('');
      }
    }
    keys.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            key, true));
      }
    });
    return output;
  }


  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (desc.set) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
    if (!hasOwnProperty(visibleKeys, key)) {
      name = '[' + key + ']';
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str.split('\n').map(function(line) {
              return '  ' + line;
            }).join('\n').substr(2);
          } else {
            str = '\n' + str.split('\n').map(function(line) {
              return '   ' + line;
            }).join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }
    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name = JSON.stringify('' + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name.replace(/'/g, "\\'")
                   .replace(/\\"/g, '"')
                   .replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }

    return name + ': ' + str;
  }


  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function(prev, cur) {
      if (cur.indexOf('\n') >= 0) ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);

    if (length > 60) {
      return braces[0] +
             (base === '' ? '' : base + '\n ') +
             ' ' +
             output.join(',\n  ') +
             ' ' +
             braces[1];
    }

    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  }


  // NOTE: These type checking functions intentionally don't use `instanceof`
  // because it is fragile and can be easily faked with `Object.create()`.
  function isArray(ar) {
    return Array.isArray(ar);
  }

  function isBoolean(arg) {
    return typeof arg === 'boolean';
  }

  function isNull(arg) {
    return arg === null;
  }

  function isNullOrUndefined(arg) {
    return arg == null;
  }

  function isNumber(arg) {
    return typeof arg === 'number';
  }

  function isString(arg) {
    return typeof arg === 'string';
  }

  function isSymbol(arg) {
    return typeof arg === 'symbol';
  }

  function isUndefined(arg) {
    return arg === void 0;
  }

  function isRegExp(re) {
    return isObject(re) && objectToString(re) === '[object RegExp]';
  }

  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }

  function isDate(d) {
    return isObject(d) && objectToString(d) === '[object Date]';
  }

  function isError(e) {
    return isObject(e) &&
        (objectToString(e) === '[object Error]' || e instanceof Error);
  }

  function isFunction(arg) {
    return typeof arg === 'function';
  }

  function isPrimitive(arg) {
    return arg === null ||
           typeof arg === 'boolean' ||
           typeof arg === 'number' ||
           typeof arg === 'string' ||
           typeof arg === 'symbol' ||  // ES6 symbol
           typeof arg === 'undefined';
  }

  function isBuffer(maybeBuf) {
    return Buffer.isBuffer(maybeBuf);
  }

  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }


  function pad$1(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
  }


  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                'Oct', 'Nov', 'Dec'];

  // 26 Feb 16:19:34
  function timestamp() {
    var d = new Date();
    var time = [pad$1(d.getHours()),
                pad$1(d.getMinutes()),
                pad$1(d.getSeconds())].join(':');
    return [d.getDate(), months[d.getMonth()], time].join(' ');
  }


  // log is just a thin wrapper to console.log that prepends a timestamp
  function log() {
    console.log('%s - %s', timestamp(), format.apply(null, arguments));
  }

  function _extend(origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !isObject(add)) return origin;

    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  }
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var require$$0 = {
    inherits: inherits$1,
    _extend: _extend,
    log: log,
    isBuffer: isBuffer,
    isPrimitive: isPrimitive,
    isFunction: isFunction,
    isError: isError,
    isDate: isDate,
    isObject: isObject,
    isRegExp: isRegExp,
    isUndefined: isUndefined,
    isSymbol: isSymbol,
    isString: isString,
    isNumber: isNumber,
    isNullOrUndefined: isNullOrUndefined,
    isNull: isNull,
    isBoolean: isBoolean,
    isArray: isArray,
    inspect: inspect,
    deprecate: deprecate,
    format: format,
    debuglog: debuglog
  };

  /**
   * For Node.js, simply re-export the core `util.deprecate` function.
   */

  var node = require$$0.deprecate;

  var sprintf = createCommonjsModule(function (module, exports) {
  /* global window, exports, define */

  !function() {

      var re = {
          not_string: /[^s]/,
          not_bool: /[^t]/,
          not_type: /[^T]/,
          not_primitive: /[^v]/,
          number: /[diefg]/,
          numeric_arg: /[bcdiefguxX]/,
          json: /[j]/,
          not_json: /[^j]/,
          text: /^[^\x25]+/,
          modulo: /^\x25{2}/,
          placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
          key: /^([a-z_][a-z_\d]*)/i,
          key_access: /^\.([a-z_][a-z_\d]*)/i,
          index_access: /^\[(\d+)\]/,
          sign: /^[\+\-]/
      };

      function sprintf(key) {
          // `arguments` is not an array, but should be fine for this call
          return sprintf_format(sprintf_parse(key), arguments)
      }

      function vsprintf(fmt, argv) {
          return sprintf.apply(null, [fmt].concat(argv || []))
      }

      function sprintf_format(parse_tree, argv) {
          var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, match, pad, pad_character, pad_length, is_positive, sign;
          for (i = 0; i < tree_length; i++) {
              if (typeof parse_tree[i] === 'string') {
                  output += parse_tree[i];
              }
              else if (Array.isArray(parse_tree[i])) {
                  match = parse_tree[i]; // convenience purposes only
                  if (match[2]) { // keyword argument
                      arg = argv[cursor];
                      for (k = 0; k < match[2].length; k++) {
                          if (!arg.hasOwnProperty(match[2][k])) {
                              throw new Error(sprintf('[sprintf] property "%s" does not exist', match[2][k]))
                          }
                          arg = arg[match[2][k]];
                      }
                  }
                  else if (match[1]) { // positional argument (explicit)
                      arg = argv[match[1]];
                  }
                  else { // positional argument (implicit)
                      arg = argv[cursor++];
                  }

                  if (re.not_type.test(match[8]) && re.not_primitive.test(match[8]) && arg instanceof Function) {
                      arg = arg();
                  }

                  if (re.numeric_arg.test(match[8]) && (typeof arg !== 'number' && isNaN(arg))) {
                      throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))
                  }

                  if (re.number.test(match[8])) {
                      is_positive = arg >= 0;
                  }

                  switch (match[8]) {
                      case 'b':
                          arg = parseInt(arg, 10).toString(2);
                          break
                      case 'c':
                          arg = String.fromCharCode(parseInt(arg, 10));
                          break
                      case 'd':
                      case 'i':
                          arg = parseInt(arg, 10);
                          break
                      case 'j':
                          arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0);
                          break
                      case 'e':
                          arg = match[7] ? parseFloat(arg).toExponential(match[7]) : parseFloat(arg).toExponential();
                          break
                      case 'f':
                          arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
                          break
                      case 'g':
                          arg = match[7] ? String(Number(arg.toPrecision(match[7]))) : parseFloat(arg);
                          break
                      case 'o':
                          arg = (parseInt(arg, 10) >>> 0).toString(8);
                          break
                      case 's':
                          arg = String(arg);
                          arg = (match[7] ? arg.substring(0, match[7]) : arg);
                          break
                      case 't':
                          arg = String(!!arg);
                          arg = (match[7] ? arg.substring(0, match[7]) : arg);
                          break
                      case 'T':
                          arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                          arg = (match[7] ? arg.substring(0, match[7]) : arg);
                          break
                      case 'u':
                          arg = parseInt(arg, 10) >>> 0;
                          break
                      case 'v':
                          arg = arg.valueOf();
                          arg = (match[7] ? arg.substring(0, match[7]) : arg);
                          break
                      case 'x':
                          arg = (parseInt(arg, 10) >>> 0).toString(16);
                          break
                      case 'X':
                          arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                          break
                  }
                  if (re.json.test(match[8])) {
                      output += arg;
                  }
                  else {
                      if (re.number.test(match[8]) && (!is_positive || match[3])) {
                          sign = is_positive ? '+' : '-';
                          arg = arg.toString().replace(re.sign, '');
                      }
                      else {
                          sign = '';
                      }
                      pad_character = match[4] ? match[4] === '0' ? '0' : match[4].charAt(1) : ' ';
                      pad_length = match[6] - (sign + arg).length;
                      pad = match[6] ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : '';
                      output += match[5] ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg);
                  }
              }
          }
          return output
      }

      var sprintf_cache = Object.create(null);

      function sprintf_parse(fmt) {
          if (sprintf_cache[fmt]) {
              return sprintf_cache[fmt]
          }

          var _fmt = fmt, match, parse_tree = [], arg_names = 0;
          while (_fmt) {
              if ((match = re.text.exec(_fmt)) !== null) {
                  parse_tree.push(match[0]);
              }
              else if ((match = re.modulo.exec(_fmt)) !== null) {
                  parse_tree.push('%');
              }
              else if ((match = re.placeholder.exec(_fmt)) !== null) {
                  if (match[2]) {
                      arg_names |= 1;
                      var field_list = [], replacement_field = match[2], field_match = [];
                      if ((field_match = re.key.exec(replacement_field)) !== null) {
                          field_list.push(field_match[1]);
                          while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                              if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                  field_list.push(field_match[1]);
                              }
                              else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                  field_list.push(field_match[1]);
                              }
                              else {
                                  throw new SyntaxError('[sprintf] failed to parse named argument key')
                              }
                          }
                      }
                      else {
                          throw new SyntaxError('[sprintf] failed to parse named argument key')
                      }
                      match[2] = field_list;
                  }
                  else {
                      arg_names |= 2;
                  }
                  if (arg_names === 3) {
                      throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')
                  }
                  parse_tree.push(match);
              }
              else {
                  throw new SyntaxError('[sprintf] unexpected placeholder')
              }
              _fmt = _fmt.substring(match[0].length);
          }
          return sprintf_cache[fmt] = parse_tree
      }

      /**
       * export to either browser or node.js
       */
      /* eslint-disable quote-props */
      {
          exports['sprintf'] = sprintf;
          exports['vsprintf'] = vsprintf;
      }
      if (typeof window !== 'undefined') {
          window['sprintf'] = sprintf;
          window['vsprintf'] = vsprintf;
      }
      /* eslint-enable quote-props */
  }();
  });

  var sprintf$1 = node(sprintf.sprintf,
    'sprintf() will be removed in the next major release, use the sprintf-js package instead.');

  var vsprintf = node(sprintf.vsprintf,
    'vsprintf() will be removed in the next major release, use the sprintf-js package instead.');

  var toNumber = function toNumber(num, precision) {
    if (num == null) return 0;
    var factor = Math.pow(10, isFinite(precision) ? precision : 0);
    return Math.round(num * factor) / factor;
  };

  var numberFormat = function numberFormat(number, dec, dsep, tsep) {
    if (isNaN(number) || number == null) return '';

    number = number.toFixed(~~dec);
    tsep = typeof tsep == 'string' ? tsep : ',';

    var parts = number.split('.'),
      fnums = parts[0],
      decimals = parts[1] ? (dsep || '.') + parts[1] : '';

    return fnums.replace(/(\d)(?=(?:\d{3})+$)/g, '$1' + tsep) + decimals;
  };

  var strRight = function strRight(str, sep) {
    str = makeString(str);
    sep = makeString(sep);
    var pos = !sep ? -1 : str.indexOf(sep);
    return ~ pos ? str.slice(pos + sep.length, str.length) : str;
  };

  var strRightBack = function strRightBack(str, sep) {
    str = makeString(str);
    sep = makeString(sep);
    var pos = !sep ? -1 : str.lastIndexOf(sep);
    return ~ pos ? str.slice(pos + sep.length, str.length) : str;
  };

  var strLeft = function strLeft(str, sep) {
    str = makeString(str);
    sep = makeString(sep);
    var pos = !sep ? -1 : str.indexOf(sep);
    return ~ pos ? str.slice(0, pos) : str;
  };

  var strLeftBack = function strLeftBack(str, sep) {
    str = makeString(str);
    sep = makeString(sep);
    var pos = str.lastIndexOf(sep);
    return ~ pos ? str.slice(0, pos) : str;
  };

  var toSentence = function toSentence(array, separator, lastSeparator, serial) {
    separator = separator || ', ';
    lastSeparator = lastSeparator || ' and ';
    var a = array.slice(),
      lastMember = a.pop();

    if (array.length > 2 && serial) lastSeparator = rtrim(separator) + lastSeparator;

    return a.length ? a.join(separator) + lastSeparator + lastMember : lastMember;
  };

  var toSentenceSerial = function toSentenceSerial(array, sep, lastSep) {
    return toSentence(array, sep, lastSep, true);
  };

  var slugify = function slugify(str) {
    return trim(dasherize(cleanDiacritics(str).replace(/[^\w\s-]/g, '-').toLowerCase()), '-');
  };

  var surround = function surround(str, wrapper) {
    return [wrapper, str, wrapper].join('');
  };

  var quote = function quote(str, quoteChar) {
    return surround(str, quoteChar || '"');
  };

  var unquote = function unquote(str, quoteChar) {
    quoteChar = quoteChar || '"';
    if (str[0] === quoteChar && str[str.length - 1] === quoteChar)
      return str.slice(1, str.length - 1);
    else return str;
  };

  var repeat = function repeat(str, qty, separator) {
    str = makeString(str);

    qty = ~~qty;

    // using faster implementation if separator is not needed;
    if (separator == null) return strRepeat(str, qty);

    // this one is about 300x slower in Google Chrome
    /*eslint no-empty: 0*/
    for (var repeat = []; qty > 0; repeat[--qty] = str) {}
    return repeat.join(separator);
  };

  var naturalCmp = function naturalCmp(str1, str2) {
    if (str1 == str2) return 0;
    if (!str1) return -1;
    if (!str2) return 1;

    var cmpRegex = /(\.\d+|\d+|\D+)/g,
      tokens1 = String(str1).match(cmpRegex),
      tokens2 = String(str2).match(cmpRegex),
      count = Math.min(tokens1.length, tokens2.length);

    for (var i = 0; i < count; i++) {
      var a = tokens1[i],
        b = tokens2[i];

      if (a !== b) {
        var num1 = +a;
        var num2 = +b;
        if (num1 === num1 && num2 === num2) {
          return num1 > num2 ? 1 : -1;
        }
        return a < b ? -1 : 1;
      }
    }

    if (tokens1.length != tokens2.length)
      return tokens1.length - tokens2.length;

    return str1 < str2 ? -1 : 1;
  };

  /**
   * Based on the implementation here: https://github.com/hiddentao/fast-levenshtein
   */
  var levenshtein = function levenshtein(str1, str2) {
    str1 = makeString(str1);
    str2 = makeString(str2);

    // Short cut cases  
    if (str1 === str2) return 0;
    if (!str1 || !str2) return Math.max(str1.length, str2.length);

    // two rows
    var prevRow = new Array(str2.length + 1);

    // initialise previous row
    for (var i = 0; i < prevRow.length; ++i) {
      prevRow[i] = i;
    }

    // calculate current row distance from previous row
    for (i = 0; i < str1.length; ++i) {
      var nextCol = i + 1;

      for (var j = 0; j < str2.length; ++j) {
        var curCol = nextCol;

        // substution
        nextCol = prevRow[j] + ( (str1.charAt(i) === str2.charAt(j)) ? 0 : 1 );
        // insertion
        var tmp = curCol + 1;
        if (nextCol > tmp) {
          nextCol = tmp;
        }
        // deletion
        tmp = prevRow[j + 1] + 1;
        if (nextCol > tmp) {
          nextCol = tmp;
        }

        // copy current col value into previous (in preparation for next iteration)
        prevRow[j] = curCol;
      }

      // copy last col value into previous (in preparation for next iteration)
      prevRow[j] = nextCol;
    }

    return nextCol;
  };

  function boolMatch(s, matchers) {
    var i, matcher, down = s.toLowerCase();
    matchers = [].concat(matchers);
    for (i = 0; i < matchers.length; i += 1) {
      matcher = matchers[i];
      if (!matcher) continue;
      if (matcher.test && matcher.test(s)) return true;
      if (matcher.toLowerCase() === down) return true;
    }
  }

  var toBoolean = function toBoolean(str, trueValues, falseValues) {
    if (typeof str === 'number') str = '' + str;
    if (typeof str !== 'string') return !!str;
    str = trim(str);
    if (boolMatch(str, trueValues || ['true', '1'])) return true;
    if (boolMatch(str, falseValues || ['false', '0'])) return false;
  };

  var exports$1 = function() {
    var result = {};

    for (var prop in this) {
      if (!this.hasOwnProperty(prop) || prop.match(/^(?:include|contains|reverse|join|map|wrap)$/)) continue;
      result[prop] = this[prop];
    }

    return result;
  };

  // Wrap
  // wraps a string by a certain width



  var wrap = function wrap(str, options){
    str = makeString(str);
    
    options = options || {};
    
    var width = options.width || 75;
    var seperator = options.seperator || '\n';
    var cut = options.cut || false;
    var preserveSpaces = options.preserveSpaces || false;
    var trailingSpaces = options.trailingSpaces || false;
    
    var result;
    
    if(width <= 0){
      return str;
    }
    
    else if(!cut){
    
      var words = str.split(' ');
      var current_column = 0;
      result = '';
    
      while(words.length > 0){
        
        // if adding a space and the next word would cause this line to be longer than width...
        if(1 + words[0].length + current_column > width){
          //start a new line if this line is not already empty
          if(current_column > 0){
            // add a space at the end of the line is preserveSpaces is true
            if (preserveSpaces){
              result += ' ';
              current_column++;
            }
            // fill the rest of the line with spaces if trailingSpaces option is true
            else if(trailingSpaces){
              while(current_column < width){
                result += ' ';
                current_column++;
              }            
            }
            //start new line
            result += seperator;
            current_column = 0;
          }
        }
    
        // if not at the begining of the line, add a space in front of the word
        if(current_column > 0){
          result += ' ';
          current_column++;
        }
    
        // tack on the next word, update current column, a pop words array
        result += words[0];
        current_column += words[0].length;
        words.shift();
    
      }
    
      // fill the rest of the line with spaces if trailingSpaces option is true
      if(trailingSpaces){
        while(current_column < width){
          result += ' ';
          current_column++;
        }            
      }
    
      return result;
    
    }
    
    else {
    
      var index = 0;
      result = '';
    
      // walk through each character and add seperators where appropriate
      while(index < str.length){
        if(index % width == 0 && index > 0){
          result += seperator;
        }
        result += str.charAt(index);
        index++;
      }
    
      // fill the rest of the line with spaces if trailingSpaces option is true
      if(trailingSpaces){
        while(index % width > 0){
          result += ' ';
          index++;
        }            
      }
      
      return result;
    }
  };

  var map = function(str, callback) {
    str = makeString(str);

    if (str.length === 0 || typeof callback !== 'function') return str;

    return str.replace(/./g, callback);
  };

  function s(value) {
    /* jshint validthis: true */
    if (!(this instanceof s)) return new s(value);
    this._wrapped = value;
  }

  s.VERSION = '3.3.4';

  s.isBlank          = isBlank;
  s.stripTags        = stripTags;
  s.capitalize       = capitalize;
  s.decapitalize     = decapitalize;
  s.chop             = chop;
  s.trim             = trim;
  s.clean            = clean;
  s.cleanDiacritics  = cleanDiacritics;
  s.count            = count;
  s.chars            = chars;
  s.swapCase         = swapCase;
  s.escapeHTML       = escapeHTML;
  s.unescapeHTML     = unescapeHTML;
  s.splice           = splice;
  s.insert           = insert;
  s.replaceAll       = replaceAll;
  s.include          = include;
  s.join             = join;
  s.lines            = lines;
  s.dedent           = dedent;
  s.reverse          = reverse;
  s.startsWith       = startsWith;
  s.endsWith         = endsWith;
  s.pred             = pred;
  s.succ             = succ;
  s.titleize         = titleize;
  s.camelize         = camelize;
  s.underscored      = underscored;
  s.dasherize        = dasherize;
  s.classify         = classify;
  s.humanize         = humanize;
  s.ltrim            = ltrim;
  s.rtrim            = rtrim;
  s.truncate         = truncate;
  s.prune            = prune;
  s.words            = words;
  s.pad              = pad;
  s.lpad             = lpad;
  s.rpad             = rpad;
  s.lrpad            = lrpad;
  s.sprintf          = sprintf$1;
  s.vsprintf         = vsprintf;
  s.toNumber         = toNumber;
  s.numberFormat     = numberFormat;
  s.strRight         = strRight;
  s.strRightBack     = strRightBack;
  s.strLeft          = strLeft;
  s.strLeftBack      = strLeftBack;
  s.toSentence       = toSentence;
  s.toSentenceSerial = toSentenceSerial;
  s.slugify          = slugify;
  s.surround         = surround;
  s.quote            = quote;
  s.unquote          = unquote;
  s.repeat           = repeat;
  s.naturalCmp       = naturalCmp;
  s.levenshtein      = levenshtein;
  s.toBoolean        = toBoolean;
  s.exports          = exports$1;
  s.escapeRegExp     = escapeRegExp;
  s.wrap             = wrap;
  s.map              = map;

  // Aliases
  s.strip     = s.trim;
  s.lstrip    = s.ltrim;
  s.rstrip    = s.rtrim;
  s.center    = s.lrpad;
  s.rjust     = s.lpad;
  s.ljust     = s.rpad;
  s.contains  = s.include;
  s.q         = s.quote;
  s.toBool    = s.toBoolean;
  s.camelcase = s.camelize;
  s.mapChars  = s.map;


  // Implement chaining
  s.prototype = {
    value: function value() {
      return this._wrapped;
    }
  };

  function fn2method(key, fn) {
    if (typeof fn !== 'function') return;
    s.prototype[key] = function() {
      var args = [this._wrapped].concat(Array.prototype.slice.call(arguments));
      var res = fn.apply(null, args);
      // if the result is non-string stop the chain and return the value
      return typeof res === 'string' ? new s(res) : res;
    };
  }

  // Copy functions to instance methods for chaining
  for (var key$1 in s) fn2method(key$1, s[key$1]);

  fn2method('tap', function tap(string, fn) {
    return fn(string);
  });

  function prototype2method(methodName) {
    fn2method(methodName, function(context) {
      var args = Array.prototype.slice.call(arguments, 1);
      return String.prototype[methodName].apply(context, args);
    });
  }

  var prototypeMethods = [
    'toUpperCase',
    'toLowerCase',
    'split',
    'replace',
    'slice',
    'substring',
    'substr',
    'concat'
  ];

  for (var method in prototypeMethods) prototype2method(prototypeMethods[method]);


  var underscore_string = s;

  var xregexpAll = createCommonjsModule(function (module, exports) {
  (function(f){{module.exports=f();}})(function(){return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof commonjsRequire=="function"&&commonjsRequire;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r);}return n[o].exports}var i=typeof commonjsRequire=="function"&&commonjsRequire;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
  /*!
   * XRegExp.build 3.2.0
   * <xregexp.com>
   * Steven Levithan (c) 2012-2017 MIT License
   * Inspired by Lea Verou's RegExp.create <lea.verou.me>
   */

  module.exports = function(XRegExp) {

      var REGEX_DATA = 'xregexp';
      var subParts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
      var parts = XRegExp.union([/\({{([\w$]+)}}\)|{{([\w$]+)}}/, subParts], 'g', {
          conjunction: 'or'
      });

      /**
       * Strips a leading `^` and trailing unescaped `$`, if both are present.
       *
       * @private
       * @param {String} pattern Pattern to process.
       * @returns {String} Pattern with edge anchors removed.
       */
      function deanchor(pattern) {
          // Allow any number of empty noncapturing groups before/after anchors, because regexes
          // built/generated by XRegExp sometimes include them
          var leadingAnchor = /^(?:\(\?:\))*\^/;
          var trailingAnchor = /\$(?:\(\?:\))*$/;

          if (
              leadingAnchor.test(pattern) &&
              trailingAnchor.test(pattern) &&
              // Ensure that the trailing `$` isn't escaped
              trailingAnchor.test(pattern.replace(/\\[\s\S]/g, ''))
          ) {
              return pattern.replace(leadingAnchor, '').replace(trailingAnchor, '');
          }

          return pattern;
      }

      /**
       * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.
       *
       * @private
       * @param {String|RegExp} value Value to convert.
       * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not
       *   already a regex generated by XRegExp
       * @returns {RegExp} XRegExp object with XRegExp syntax applied.
       */
      function asXRegExp(value, addFlagX) {
          var flags = addFlagX ? 'x' : '';
          return XRegExp.isRegExp(value) ?
              (value[REGEX_DATA] && value[REGEX_DATA].captureNames ?
                  // Don't recompile, to preserve capture names
                  value :
                  // Recompile as XRegExp
                  XRegExp(value.source, flags)
              ) :
              // Compile string as XRegExp
              XRegExp(value, flags);
      }

      /**
       * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in
       * the outer pattern and provided subpatterns are automatically renumbered to work correctly.
       * Native flags used by provided subpatterns are ignored in favor of the `flags` argument.
       *
       * @memberOf XRegExp
       * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows
       *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within
       *   character classes.
       * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A
       *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.
       * @param {String} [flags] Any combination of XRegExp flags.
       * @returns {RegExp} Regex with interpolated subpatterns.
       * @example
       *
       * var time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {
       *   hours: XRegExp.build('{{h12}} : | {{h24}}', {
       *     h12: /1[0-2]|0?[1-9]/,
       *     h24: /2[0-3]|[01][0-9]/
       *   }, 'x'),
       *   minutes: /^[0-5][0-9]$/
       * });
       * time.test('10:59'); // -> true
       * XRegExp.exec('10:59', time).minutes; // -> '59'
       */
      XRegExp.build = function(pattern, subs, flags) {
          flags = flags || '';
          // Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how
          // some browsers convert `RegExp('\n')` to a regex that contains the literal characters `\`
          // and `n`. See more details at <https://github.com/slevithan/xregexp/pull/163>.
          var addFlagX = flags.indexOf('x') > -1;
          var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern);
          // Add flags within a leading mode modifier to the overall pattern's flags
          if (inlineFlags) {
              flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);
          }

          var data = {};
          for (var p in subs) {
              if (subs.hasOwnProperty(p)) {
                  // Passing to XRegExp enables extended syntax and ensures independent validity,
                  // lest an unescaped `(`, `)`, `[`, or trailing `\` breaks the `(?:)` wrapper. For
                  // subpatterns provided as native regexes, it dies on octals and adds the property
                  // used to hold extended regex instance data, for simplicity.
                  var sub = asXRegExp(subs[p], addFlagX);
                  data[p] = {
                      // Deanchoring allows embedding independently useful anchored regexes. If you
                      // really need to keep your anchors, double them (i.e., `^^...$$`).
                      pattern: deanchor(sub.source),
                      names: sub[REGEX_DATA].captureNames || []
                  };
              }
          }

          // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;
          // helps keep this simple. Named captures will be put back.
          var patternAsRegex = asXRegExp(pattern, addFlagX);

          // 'Caps' is short for 'captures'
          var numCaps = 0;
          var numPriorCaps;
          var numOuterCaps = 0;
          var outerCapsMap = [0];
          var outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];
          var output = patternAsRegex.source.replace(parts, function($0, $1, $2, $3, $4) {
              var subName = $1 || $2;
              var capName;
              var intro;
              var localCapIndex;
              // Named subpattern
              if (subName) {
                  if (!data.hasOwnProperty(subName)) {
                      throw new ReferenceError('Undefined property ' + $0);
                  }
                  // Named subpattern was wrapped in a capturing group
                  if ($1) {
                      capName = outerCapNames[numOuterCaps];
                      outerCapsMap[++numOuterCaps] = ++numCaps;
                      // If it's a named group, preserve the name. Otherwise, use the subpattern name
                      // as the capture name
                      intro = '(?<' + (capName || subName) + '>';
                  } else {
                      intro = '(?:';
                  }
                  numPriorCaps = numCaps;
                  return intro + data[subName].pattern.replace(subParts, function(match, paren, backref) {
                      // Capturing group
                      if (paren) {
                          capName = data[subName].names[numCaps - numPriorCaps];
                          ++numCaps;
                          // If the current capture has a name, preserve the name
                          if (capName) {
                              return '(?<' + capName + '>';
                          }
                      // Backreference
                      } else if (backref) {
                          localCapIndex = +backref - 1;
                          // Rewrite the backreference
                          return data[subName].names[localCapIndex] ?
                              // Need to preserve the backreference name in case using flag `n`
                              '\\k<' + data[subName].names[localCapIndex] + '>' :
                              '\\' + (+backref + numPriorCaps);
                      }
                      return match;
                  }) + ')';
              }
              // Capturing group
              if ($3) {
                  capName = outerCapNames[numOuterCaps];
                  outerCapsMap[++numOuterCaps] = ++numCaps;
                  // If the current capture has a name, preserve the name
                  if (capName) {
                      return '(?<' + capName + '>';
                  }
              // Backreference
              } else if ($4) {
                  localCapIndex = +$4 - 1;
                  // Rewrite the backreference
                  return outerCapNames[localCapIndex] ?
                      // Need to preserve the backreference name in case using flag `n`
                      '\\k<' + outerCapNames[localCapIndex] + '>' :
                      '\\' + outerCapsMap[+$4];
              }
              return $0;
          });

          return XRegExp(output, flags);
      };

  };

  },{}],2:[function(require,module,exports){
  /*!
   * XRegExp.matchRecursive 3.2.0
   * <xregexp.com>
   * Steven Levithan (c) 2009-2017 MIT License
   */

  module.exports = function(XRegExp) {

      /**
       * Returns a match detail object composed of the provided values.
       *
       * @private
       */
      function row(name, value, start, end) {
          return {
              name: name,
              value: value,
              start: start,
              end: end
          };
      }

      /**
       * Returns an array of match strings between outermost left and right delimiters, or an array of
       * objects with detailed match parts and position data. An error is thrown if delimiters are
       * unbalanced within the data.
       *
       * @memberOf XRegExp
       * @param {String} str String to search.
       * @param {String} left Left delimiter as an XRegExp pattern.
       * @param {String} right Right delimiter as an XRegExp pattern.
       * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.
       * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.
       * @returns {Array} Array of matches, or an empty array.
       * @example
       *
       * // Basic usage
       * var str = '(t((e))s)t()(ing)';
       * XRegExp.matchRecursive(str, '\\(', '\\)', 'g');
       * // -> ['t((e))s', '', 'ing']
       *
       * // Extended information mode with valueNames
       * str = 'Here is <div> <div>an</div></div> example';
       * XRegExp.matchRecursive(str, '<div\\s*>', '</div>', 'gi', {
       *   valueNames: ['between', 'left', 'match', 'right']
       * });
       * // -> [
       * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},
       * // {name: 'left',    value: '<div>',          start: 8,  end: 13},
       * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},
       * // {name: 'right',   value: '</div>',         start: 27, end: 33},
       * // {name: 'between', value: ' example',       start: 33, end: 41}
       * // ]
       *
       * // Omitting unneeded parts with null valueNames, and using escapeChar
       * str = '...{1}.\\{{function(x,y){return {y:x}}}';
       * XRegExp.matchRecursive(str, '{', '}', 'g', {
       *   valueNames: ['literal', null, 'value', null],
       *   escapeChar: '\\'
       * });
       * // -> [
       * // {name: 'literal', value: '...',  start: 0, end: 3},
       * // {name: 'value',   value: '1',    start: 4, end: 5},
       * // {name: 'literal', value: '.\\{', start: 6, end: 9},
       * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}
       * // ]
       *
       * // Sticky mode via flag y
       * str = '<1><<<2>>><3>4<5>';
       * XRegExp.matchRecursive(str, '<', '>', 'gy');
       * // -> ['1', '<<2>>', '3']
       */
      XRegExp.matchRecursive = function(str, left, right, flags, options) {
          flags = flags || '';
          options = options || {};
          var global = flags.indexOf('g') > -1;
          var sticky = flags.indexOf('y') > -1;
          // Flag `y` is controlled internally
          var basicFlags = flags.replace(/y/g, '');
          var escapeChar = options.escapeChar;
          var vN = options.valueNames;
          var output = [];
          var openTokens = 0;
          var delimStart = 0;
          var delimEnd = 0;
          var lastOuterEnd = 0;
          var outerStart;
          var innerStart;
          var leftMatch;
          var rightMatch;
          var esc;
          left = XRegExp(left, basicFlags);
          right = XRegExp(right, basicFlags);

          if (escapeChar) {
              if (escapeChar.length > 1) {
                  throw new Error('Cannot use more than one escape character');
              }
              escapeChar = XRegExp.escape(escapeChar);
              // Example of concatenated `esc` regex:
              // `escapeChar`: '%'
              // `left`: '<'
              // `right`: '>'
              // Regex is: /(?:%[\S\s]|(?:(?!<|>)[^%])+)+/
              esc = new RegExp(
                  '(?:' + escapeChar + '[\\S\\s]|(?:(?!' +
                      // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.
                      // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax
                      // transformation resulting from those flags was already applied to `left` and
                      // `right` when they were passed through the XRegExp constructor above.
                      XRegExp.union([left, right], '', {conjunction: 'or'}).source +
                      ')[^' + escapeChar + '])+)+',
                  // Flags `gy` not needed here
                  flags.replace(/[^imu]+/g, '')
              );
          }

          while (true) {
              // If using an escape character, advance to the delimiter's next starting position,
              // skipping any escaped characters in between
              if (escapeChar) {
                  delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;
              }
              leftMatch = XRegExp.exec(str, left, delimEnd);
              rightMatch = XRegExp.exec(str, right, delimEnd);
              // Keep the leftmost match only
              if (leftMatch && rightMatch) {
                  if (leftMatch.index <= rightMatch.index) {
                      rightMatch = null;
                  } else {
                      leftMatch = null;
                  }
              }
              // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):
              // LM | RM | OT | Result
              // 1  | 0  | 1  | loop
              // 1  | 0  | 0  | loop
              // 0  | 1  | 1  | loop
              // 0  | 1  | 0  | throw
              // 0  | 0  | 1  | throw
              // 0  | 0  | 0  | break
              // The paths above don't include the sticky mode special case. The loop ends after the
              // first completed match if not `global`.
              if (leftMatch || rightMatch) {
                  delimStart = (leftMatch || rightMatch).index;
                  delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
              } else if (!openTokens) {
                  break;
              }
              if (sticky && !openTokens && delimStart > lastOuterEnd) {
                  break;
              }
              if (leftMatch) {
                  if (!openTokens) {
                      outerStart = delimStart;
                      innerStart = delimEnd;
                  }
                  ++openTokens;
              } else if (rightMatch && openTokens) {
                  if (!--openTokens) {
                      if (vN) {
                          if (vN[0] && outerStart > lastOuterEnd) {
                              output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
                          }
                          if (vN[1]) {
                              output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
                          }
                          if (vN[2]) {
                              output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
                          }
                          if (vN[3]) {
                              output.push(row(vN[3], str.slice(delimStart, delimEnd), delimStart, delimEnd));
                          }
                      } else {
                          output.push(str.slice(innerStart, delimStart));
                      }
                      lastOuterEnd = delimEnd;
                      if (!global) {
                          break;
                      }
                  }
              } else {
                  throw new Error('Unbalanced delimiter found in string');
              }
              // If the delimiter matched an empty string, avoid an infinite loop
              if (delimStart === delimEnd) {
                  ++delimEnd;
              }
          }

          if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {
              output.push(row(vN[0], str.slice(lastOuterEnd), lastOuterEnd, str.length));
          }

          return output;
      };

  };

  },{}],3:[function(require,module,exports){
  /*!
   * XRegExp Unicode Base 3.2.0
   * <xregexp.com>
   * Steven Levithan (c) 2008-2017 MIT License
   */

  module.exports = function(XRegExp) {

      /**
       * Adds base support for Unicode matching:
       * - Adds syntax `\p{..}` for matching Unicode tokens. Tokens can be inverted using `\P{..}` or
       *   `\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the
       *   braces for token names that are a single letter (e.g. `\pL` or `PL`).
       * - Adds flag A (astral), which enables 21-bit Unicode support.
       * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.
       *
       * Unicode Base relies on externally provided Unicode character data. Official addons are
       * available to provide data for Unicode categories, scripts, blocks, and properties.
       *
       * @requires XRegExp
       */

      // ==--------------------------==
      // Private stuff
      // ==--------------------------==

      // Storage for Unicode data
      var unicode = {};

      // Reuse utils
      var dec = XRegExp._dec;
      var hex = XRegExp._hex;
      var pad4 = XRegExp._pad4;

      // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed
      function normalize(name) {
          return name.replace(/[- _]+/g, '').toLowerCase();
      }

      // Gets the decimal code of a literal code unit, \xHH, \uHHHH, or a backslash-escaped literal
      function charCode(chr) {
          var esc = /^\\[xu](.+)/.exec(chr);
          return esc ?
              dec(esc[1]) :
              chr.charCodeAt(chr.charAt(0) === '\\' ? 1 : 0);
      }

      // Inverts a list of ordered BMP characters and ranges
      function invertBmp(range) {
          var output = '';
          var lastEnd = -1;

          XRegExp.forEach(
              range,
              /(\\x..|\\u....|\\?[\s\S])(?:-(\\x..|\\u....|\\?[\s\S]))?/,
              function(m) {
                  var start = charCode(m[1]);
                  if (start > (lastEnd + 1)) {
                      output += '\\u' + pad4(hex(lastEnd + 1));
                      if (start > (lastEnd + 2)) {
                          output += '-\\u' + pad4(hex(start - 1));
                      }
                  }
                  lastEnd = charCode(m[2] || m[1]);
              }
          );

          if (lastEnd < 0xFFFF) {
              output += '\\u' + pad4(hex(lastEnd + 1));
              if (lastEnd < 0xFFFE) {
                  output += '-\\uFFFF';
              }
          }

          return output;
      }

      // Generates an inverted BMP range on first use
      function cacheInvertedBmp(slug) {
          var prop = 'b!';
          return (
              unicode[slug][prop] ||
              (unicode[slug][prop] = invertBmp(unicode[slug].bmp))
          );
      }

      // Combines and optionally negates BMP and astral data
      function buildAstral(slug, isNegated) {
          var item = unicode[slug];
          var combined = '';

          if (item.bmp && !item.isBmpLast) {
              combined = '[' + item.bmp + ']' + (item.astral ? '|' : '');
          }
          if (item.astral) {
              combined += item.astral;
          }
          if (item.isBmpLast && item.bmp) {
              combined += (item.astral ? '|' : '') + '[' + item.bmp + ']';
          }

          // Astral Unicode tokens always match a code point, never a code unit
          return isNegated ?
              '(?:(?!' + combined + ')(?:[\uD800-\uDBFF][\uDC00-\uDFFF]|[\0-\uFFFF]))' :
              '(?:' + combined + ')';
      }

      // Builds a complete astral pattern on first use
      function cacheAstral(slug, isNegated) {
          var prop = isNegated ? 'a!' : 'a=';
          return (
              unicode[slug][prop] ||
              (unicode[slug][prop] = buildAstral(slug, isNegated))
          );
      }

      // ==--------------------------==
      // Core functionality
      // ==--------------------------==

      /*
       * Add astral mode (flag A) and Unicode token syntax: `\p{..}`, `\P{..}`, `\p{^..}`, `\pC`.
       */
      XRegExp.addToken(
          // Use `*` instead of `+` to avoid capturing `^` as the token name in `\p{^}`
          /\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/,
          function(match, scope, flags) {
              var ERR_DOUBLE_NEG = 'Invalid double negation ';
              var ERR_UNKNOWN_NAME = 'Unknown Unicode token ';
              var ERR_UNKNOWN_REF = 'Unicode token missing data ';
              var ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';
              var ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes';
              // Negated via \P{..} or \p{^..}
              var isNegated = match[1] === 'P' || !!match[2];
              // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A
              var isAstralMode = flags.indexOf('A') > -1;
              // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\p{}`
              var slug = normalize(match[4] || match[3]);
              // Token data object
              var item = unicode[slug];

              if (match[1] === 'P' && match[2]) {
                  throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);
              }
              if (!unicode.hasOwnProperty(slug)) {
                  throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);
              }

              // Switch to the negated form of the referenced Unicode token
              if (item.inverseOf) {
                  slug = normalize(item.inverseOf);
                  if (!unicode.hasOwnProperty(slug)) {
                      throw new ReferenceError(ERR_UNKNOWN_REF + match[0] + ' -> ' + item.inverseOf);
                  }
                  item = unicode[slug];
                  isNegated = !isNegated;
              }

              if (!(item.bmp || isAstralMode)) {
                  throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);
              }
              if (isAstralMode) {
                  if (scope === 'class') {
                      throw new SyntaxError(ERR_ASTRAL_IN_CLASS);
                  }

                  return cacheAstral(slug, isNegated);
              }

              return scope === 'class' ?
                  (isNegated ? cacheInvertedBmp(slug) : item.bmp) :
                  (isNegated ? '[^' : '[') + item.bmp + ']';
          },
          {
              scope: 'all',
              optionalFlags: 'A',
              leadChar: '\\'
          }
      );

      /**
       * Adds to the list of Unicode tokens that XRegExp regexes can match via `\p` or `\P`.
       *
       * @memberOf XRegExp
       * @param {Array} data Objects with named character ranges. Each object may have properties
       *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are
       *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If
       *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,
       *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are
       *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and
       *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan
       *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and
       *   `astral` data should be a combination of literal characters and `\xHH` or `\uHHHH` escape
       *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be
       *   escaped, apart from range-creating hyphens. The `astral` data can additionally use
       *   character classes and alternation, and should use surrogate pairs to represent astral code
       *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is
       *   defined as the exact inverse of another token.
       * @example
       *
       * // Basic use
       * XRegExp.addUnicodeData([{
       *   name: 'XDigit',
       *   alias: 'Hexadecimal',
       *   bmp: '0-9A-Fa-f'
       * }]);
       * XRegExp('\\p{XDigit}:\\p{Hexadecimal}+').test('0:3D'); // -> true
       */
      XRegExp.addUnicodeData = function(data) {
          var ERR_NO_NAME = 'Unicode token requires name';
          var ERR_NO_DATA = 'Unicode token has no character data ';
          var item;

          for (var i = 0; i < data.length; ++i) {
              item = data[i];
              if (!item.name) {
                  throw new Error(ERR_NO_NAME);
              }
              if (!(item.inverseOf || item.bmp || item.astral)) {
                  throw new Error(ERR_NO_DATA + item.name);
              }
              unicode[normalize(item.name)] = item;
              if (item.alias) {
                  unicode[normalize(item.alias)] = item;
              }
          }

          // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
          // flags might now produce different results
          XRegExp.cache.flush('patterns');
      };

      /**
       * @ignore
       *
       * Return a reference to the internal Unicode definition structure for the given Unicode
       * Property if the given name is a legal Unicode Property for use in XRegExp `\p` or `\P` regex
       * constructs.
       *
       * @memberOf XRegExp
       * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),
       *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode
       *   Properties and Property Aliases.
       * @returns {Object} Reference to definition structure when the name matches a Unicode Property.
       *
       * @note
       * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.
       *
       * @note
       * This method is *not* part of the officially documented API and may change or be removed in
       * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode
       * structures set up by XRegExp.
       */
      XRegExp._getUnicodeProperty = function(name) {
          var slug = normalize(name);
          return unicode[slug];
      };

  };

  },{}],4:[function(require,module,exports){
  /*!
   * XRegExp Unicode Blocks 3.2.0
   * <xregexp.com>
   * Steven Levithan (c) 2010-2017 MIT License
   * Unicode data by Mathias Bynens <mathiasbynens.be>
   */

  module.exports = function(XRegExp) {

      /**
       * Adds support for all Unicode blocks. Block names use the prefix 'In'. E.g.,
       * `\p{InBasicLatin}`. Token names are case insensitive, and any spaces, hyphens, and
       * underscores are ignored.
       *
       * Uses Unicode 9.0.0.
       *
       * @requires XRegExp, Unicode Base
       */

      if (!XRegExp.addUnicodeData) {
          throw new ReferenceError('Unicode Base must be loaded before Unicode Blocks');
      }

      XRegExp.addUnicodeData([
          {
              name: 'InAdlam',
              astral: '\uD83A[\uDD00-\uDD5F]'
          },
          {
              name: 'InAegean_Numbers',
              astral: '\uD800[\uDD00-\uDD3F]'
          },
          {
              name: 'InAhom',
              astral: '\uD805[\uDF00-\uDF3F]'
          },
          {
              name: 'InAlchemical_Symbols',
              astral: '\uD83D[\uDF00-\uDF7F]'
          },
          {
              name: 'InAlphabetic_Presentation_Forms',
              bmp: '\uFB00-\uFB4F'
          },
          {
              name: 'InAnatolian_Hieroglyphs',
              astral: '\uD811[\uDC00-\uDE7F]'
          },
          {
              name: 'InAncient_Greek_Musical_Notation',
              astral: '\uD834[\uDE00-\uDE4F]'
          },
          {
              name: 'InAncient_Greek_Numbers',
              astral: '\uD800[\uDD40-\uDD8F]'
          },
          {
              name: 'InAncient_Symbols',
              astral: '\uD800[\uDD90-\uDDCF]'
          },
          {
              name: 'InArabic',
              bmp: '\u0600-\u06FF'
          },
          {
              name: 'InArabic_Extended_A',
              bmp: '\u08A0-\u08FF'
          },
          {
              name: 'InArabic_Mathematical_Alphabetic_Symbols',
              astral: '\uD83B[\uDE00-\uDEFF]'
          },
          {
              name: 'InArabic_Presentation_Forms_A',
              bmp: '\uFB50-\uFDFF'
          },
          {
              name: 'InArabic_Presentation_Forms_B',
              bmp: '\uFE70-\uFEFF'
          },
          {
              name: 'InArabic_Supplement',
              bmp: '\u0750-\u077F'
          },
          {
              name: 'InArmenian',
              bmp: '\u0530-\u058F'
          },
          {
              name: 'InArrows',
              bmp: '\u2190-\u21FF'
          },
          {
              name: 'InAvestan',
              astral: '\uD802[\uDF00-\uDF3F]'
          },
          {
              name: 'InBalinese',
              bmp: '\u1B00-\u1B7F'
          },
          {
              name: 'InBamum',
              bmp: '\uA6A0-\uA6FF'
          },
          {
              name: 'InBamum_Supplement',
              astral: '\uD81A[\uDC00-\uDE3F]'
          },
          {
              name: 'InBasic_Latin',
              bmp: '\0-\x7F'
          },
          {
              name: 'InBassa_Vah',
              astral: '\uD81A[\uDED0-\uDEFF]'
          },
          {
              name: 'InBatak',
              bmp: '\u1BC0-\u1BFF'
          },
          {
              name: 'InBengali',
              bmp: '\u0980-\u09FF'
          },
          {
              name: 'InBhaiksuki',
              astral: '\uD807[\uDC00-\uDC6F]'
          },
          {
              name: 'InBlock_Elements',
              bmp: '\u2580-\u259F'
          },
          {
              name: 'InBopomofo',
              bmp: '\u3100-\u312F'
          },
          {
              name: 'InBopomofo_Extended',
              bmp: '\u31A0-\u31BF'
          },
          {
              name: 'InBox_Drawing',
              bmp: '\u2500-\u257F'
          },
          {
              name: 'InBrahmi',
              astral: '\uD804[\uDC00-\uDC7F]'
          },
          {
              name: 'InBraille_Patterns',
              bmp: '\u2800-\u28FF'
          },
          {
              name: 'InBuginese',
              bmp: '\u1A00-\u1A1F'
          },
          {
              name: 'InBuhid',
              bmp: '\u1740-\u175F'
          },
          {
              name: 'InByzantine_Musical_Symbols',
              astral: '\uD834[\uDC00-\uDCFF]'
          },
          {
              name: 'InCJK_Compatibility',
              bmp: '\u3300-\u33FF'
          },
          {
              name: 'InCJK_Compatibility_Forms',
              bmp: '\uFE30-\uFE4F'
          },
          {
              name: 'InCJK_Compatibility_Ideographs',
              bmp: '\uF900-\uFAFF'
          },
          {
              name: 'InCJK_Compatibility_Ideographs_Supplement',
              astral: '\uD87E[\uDC00-\uDE1F]'
          },
          {
              name: 'InCJK_Radicals_Supplement',
              bmp: '\u2E80-\u2EFF'
          },
          {
              name: 'InCJK_Strokes',
              bmp: '\u31C0-\u31EF'
          },
          {
              name: 'InCJK_Symbols_and_Punctuation',
              bmp: '\u3000-\u303F'
          },
          {
              name: 'InCJK_Unified_Ideographs',
              bmp: '\u4E00-\u9FFF'
          },
          {
              name: 'InCJK_Unified_Ideographs_Extension_A',
              bmp: '\u3400-\u4DBF'
          },
          {
              name: 'InCJK_Unified_Ideographs_Extension_B',
              astral: '[\uD840-\uD868][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDF]'
          },
          {
              name: 'InCJK_Unified_Ideographs_Extension_C',
              astral: '\uD869[\uDF00-\uDFFF]|[\uD86A-\uD86C][\uDC00-\uDFFF]|\uD86D[\uDC00-\uDF3F]'
          },
          {
              name: 'InCJK_Unified_Ideographs_Extension_D',
              astral: '\uD86D[\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1F]'
          },
          {
              name: 'InCJK_Unified_Ideographs_Extension_E',
              astral: '\uD86E[\uDC20-\uDFFF]|[\uD86F-\uD872][\uDC00-\uDFFF]|\uD873[\uDC00-\uDEAF]'
          },
          {
              name: 'InCarian',
              astral: '\uD800[\uDEA0-\uDEDF]'
          },
          {
              name: 'InCaucasian_Albanian',
              astral: '\uD801[\uDD30-\uDD6F]'
          },
          {
              name: 'InChakma',
              astral: '\uD804[\uDD00-\uDD4F]'
          },
          {
              name: 'InCham',
              bmp: '\uAA00-\uAA5F'
          },
          {
              name: 'InCherokee',
              bmp: '\u13A0-\u13FF'
          },
          {
              name: 'InCherokee_Supplement',
              bmp: '\uAB70-\uABBF'
          },
          {
              name: 'InCombining_Diacritical_Marks',
              bmp: '\u0300-\u036F'
          },
          {
              name: 'InCombining_Diacritical_Marks_Extended',
              bmp: '\u1AB0-\u1AFF'
          },
          {
              name: 'InCombining_Diacritical_Marks_Supplement',
              bmp: '\u1DC0-\u1DFF'
          },
          {
              name: 'InCombining_Diacritical_Marks_for_Symbols',
              bmp: '\u20D0-\u20FF'
          },
          {
              name: 'InCombining_Half_Marks',
              bmp: '\uFE20-\uFE2F'
          },
          {
              name: 'InCommon_Indic_Number_Forms',
              bmp: '\uA830-\uA83F'
          },
          {
              name: 'InControl_Pictures',
              bmp: '\u2400-\u243F'
          },
          {
              name: 'InCoptic',
              bmp: '\u2C80-\u2CFF'
          },
          {
              name: 'InCoptic_Epact_Numbers',
              astral: '\uD800[\uDEE0-\uDEFF]'
          },
          {
              name: 'InCounting_Rod_Numerals',
              astral: '\uD834[\uDF60-\uDF7F]'
          },
          {
              name: 'InCuneiform',
              astral: '\uD808[\uDC00-\uDFFF]'
          },
          {
              name: 'InCuneiform_Numbers_and_Punctuation',
              astral: '\uD809[\uDC00-\uDC7F]'
          },
          {
              name: 'InCurrency_Symbols',
              bmp: '\u20A0-\u20CF'
          },
          {
              name: 'InCypriot_Syllabary',
              astral: '\uD802[\uDC00-\uDC3F]'
          },
          {
              name: 'InCyrillic',
              bmp: '\u0400-\u04FF'
          },
          {
              name: 'InCyrillic_Extended_A',
              bmp: '\u2DE0-\u2DFF'
          },
          {
              name: 'InCyrillic_Extended_B',
              bmp: '\uA640-\uA69F'
          },
          {
              name: 'InCyrillic_Extended_C',
              bmp: '\u1C80-\u1C8F'
          },
          {
              name: 'InCyrillic_Supplement',
              bmp: '\u0500-\u052F'
          },
          {
              name: 'InDeseret',
              astral: '\uD801[\uDC00-\uDC4F]'
          },
          {
              name: 'InDevanagari',
              bmp: '\u0900-\u097F'
          },
          {
              name: 'InDevanagari_Extended',
              bmp: '\uA8E0-\uA8FF'
          },
          {
              name: 'InDingbats',
              bmp: '\u2700-\u27BF'
          },
          {
              name: 'InDomino_Tiles',
              astral: '\uD83C[\uDC30-\uDC9F]'
          },
          {
              name: 'InDuployan',
              astral: '\uD82F[\uDC00-\uDC9F]'
          },
          {
              name: 'InEarly_Dynastic_Cuneiform',
              astral: '\uD809[\uDC80-\uDD4F]'
          },
          {
              name: 'InEgyptian_Hieroglyphs',
              astral: '\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F]'
          },
          {
              name: 'InElbasan',
              astral: '\uD801[\uDD00-\uDD2F]'
          },
          {
              name: 'InEmoticons',
              astral: '\uD83D[\uDE00-\uDE4F]'
          },
          {
              name: 'InEnclosed_Alphanumeric_Supplement',
              astral: '\uD83C[\uDD00-\uDDFF]'
          },
          {
              name: 'InEnclosed_Alphanumerics',
              bmp: '\u2460-\u24FF'
          },
          {
              name: 'InEnclosed_CJK_Letters_and_Months',
              bmp: '\u3200-\u32FF'
          },
          {
              name: 'InEnclosed_Ideographic_Supplement',
              astral: '\uD83C[\uDE00-\uDEFF]'
          },
          {
              name: 'InEthiopic',
              bmp: '\u1200-\u137F'
          },
          {
              name: 'InEthiopic_Extended',
              bmp: '\u2D80-\u2DDF'
          },
          {
              name: 'InEthiopic_Extended_A',
              bmp: '\uAB00-\uAB2F'
          },
          {
              name: 'InEthiopic_Supplement',
              bmp: '\u1380-\u139F'
          },
          {
              name: 'InGeneral_Punctuation',
              bmp: '\u2000-\u206F'
          },
          {
              name: 'InGeometric_Shapes',
              bmp: '\u25A0-\u25FF'
          },
          {
              name: 'InGeometric_Shapes_Extended',
              astral: '\uD83D[\uDF80-\uDFFF]'
          },
          {
              name: 'InGeorgian',
              bmp: '\u10A0-\u10FF'
          },
          {
              name: 'InGeorgian_Supplement',
              bmp: '\u2D00-\u2D2F'
          },
          {
              name: 'InGlagolitic',
              bmp: '\u2C00-\u2C5F'
          },
          {
              name: 'InGlagolitic_Supplement',
              astral: '\uD838[\uDC00-\uDC2F]'
          },
          {
              name: 'InGothic',
              astral: '\uD800[\uDF30-\uDF4F]'
          },
          {
              name: 'InGrantha',
              astral: '\uD804[\uDF00-\uDF7F]'
          },
          {
              name: 'InGreek_Extended',
              bmp: '\u1F00-\u1FFF'
          },
          {
              name: 'InGreek_and_Coptic',
              bmp: '\u0370-\u03FF'
          },
          {
              name: 'InGujarati',
              bmp: '\u0A80-\u0AFF'
          },
          {
              name: 'InGurmukhi',
              bmp: '\u0A00-\u0A7F'
          },
          {
              name: 'InHalfwidth_and_Fullwidth_Forms',
              bmp: '\uFF00-\uFFEF'
          },
          {
              name: 'InHangul_Compatibility_Jamo',
              bmp: '\u3130-\u318F'
          },
          {
              name: 'InHangul_Jamo',
              bmp: '\u1100-\u11FF'
          },
          {
              name: 'InHangul_Jamo_Extended_A',
              bmp: '\uA960-\uA97F'
          },
          {
              name: 'InHangul_Jamo_Extended_B',
              bmp: '\uD7B0-\uD7FF'
          },
          {
              name: 'InHangul_Syllables',
              bmp: '\uAC00-\uD7AF'
          },
          {
              name: 'InHanunoo',
              bmp: '\u1720-\u173F'
          },
          {
              name: 'InHatran',
              astral: '\uD802[\uDCE0-\uDCFF]'
          },
          {
              name: 'InHebrew',
              bmp: '\u0590-\u05FF'
          },
          {
              name: 'InHigh_Private_Use_Surrogates',
              bmp: '\uDB80-\uDBFF'
          },
          {
              name: 'InHigh_Surrogates',
              bmp: '\uD800-\uDB7F'
          },
          {
              name: 'InHiragana',
              bmp: '\u3040-\u309F'
          },
          {
              name: 'InIPA_Extensions',
              bmp: '\u0250-\u02AF'
          },
          {
              name: 'InIdeographic_Description_Characters',
              bmp: '\u2FF0-\u2FFF'
          },
          {
              name: 'InIdeographic_Symbols_and_Punctuation',
              astral: '\uD81B[\uDFE0-\uDFFF]'
          },
          {
              name: 'InImperial_Aramaic',
              astral: '\uD802[\uDC40-\uDC5F]'
          },
          {
              name: 'InInscriptional_Pahlavi',
              astral: '\uD802[\uDF60-\uDF7F]'
          },
          {
              name: 'InInscriptional_Parthian',
              astral: '\uD802[\uDF40-\uDF5F]'
          },
          {
              name: 'InJavanese',
              bmp: '\uA980-\uA9DF'
          },
          {
              name: 'InKaithi',
              astral: '\uD804[\uDC80-\uDCCF]'
          },
          {
              name: 'InKana_Supplement',
              astral: '\uD82C[\uDC00-\uDCFF]'
          },
          {
              name: 'InKanbun',
              bmp: '\u3190-\u319F'
          },
          {
              name: 'InKangxi_Radicals',
              bmp: '\u2F00-\u2FDF'
          },
          {
              name: 'InKannada',
              bmp: '\u0C80-\u0CFF'
          },
          {
              name: 'InKatakana',
              bmp: '\u30A0-\u30FF'
          },
          {
              name: 'InKatakana_Phonetic_Extensions',
              bmp: '\u31F0-\u31FF'
          },
          {
              name: 'InKayah_Li',
              bmp: '\uA900-\uA92F'
          },
          {
              name: 'InKharoshthi',
              astral: '\uD802[\uDE00-\uDE5F]'
          },
          {
              name: 'InKhmer',
              bmp: '\u1780-\u17FF'
          },
          {
              name: 'InKhmer_Symbols',
              bmp: '\u19E0-\u19FF'
          },
          {
              name: 'InKhojki',
              astral: '\uD804[\uDE00-\uDE4F]'
          },
          {
              name: 'InKhudawadi',
              astral: '\uD804[\uDEB0-\uDEFF]'
          },
          {
              name: 'InLao',
              bmp: '\u0E80-\u0EFF'
          },
          {
              name: 'InLatin_Extended_Additional',
              bmp: '\u1E00-\u1EFF'
          },
          {
              name: 'InLatin_Extended_A',
              bmp: '\u0100-\u017F'
          },
          {
              name: 'InLatin_Extended_B',
              bmp: '\u0180-\u024F'
          },
          {
              name: 'InLatin_Extended_C',
              bmp: '\u2C60-\u2C7F'
          },
          {
              name: 'InLatin_Extended_D',
              bmp: '\uA720-\uA7FF'
          },
          {
              name: 'InLatin_Extended_E',
              bmp: '\uAB30-\uAB6F'
          },
          {
              name: 'InLatin_1_Supplement',
              bmp: '\x80-\xFF'
          },
          {
              name: 'InLepcha',
              bmp: '\u1C00-\u1C4F'
          },
          {
              name: 'InLetterlike_Symbols',
              bmp: '\u2100-\u214F'
          },
          {
              name: 'InLimbu',
              bmp: '\u1900-\u194F'
          },
          {
              name: 'InLinear_A',
              astral: '\uD801[\uDE00-\uDF7F]'
          },
          {
              name: 'InLinear_B_Ideograms',
              astral: '\uD800[\uDC80-\uDCFF]'
          },
          {
              name: 'InLinear_B_Syllabary',
              astral: '\uD800[\uDC00-\uDC7F]'
          },
          {
              name: 'InLisu',
              bmp: '\uA4D0-\uA4FF'
          },
          {
              name: 'InLow_Surrogates',
              bmp: '\uDC00-\uDFFF'
          },
          {
              name: 'InLycian',
              astral: '\uD800[\uDE80-\uDE9F]'
          },
          {
              name: 'InLydian',
              astral: '\uD802[\uDD20-\uDD3F]'
          },
          {
              name: 'InMahajani',
              astral: '\uD804[\uDD50-\uDD7F]'
          },
          {
              name: 'InMahjong_Tiles',
              astral: '\uD83C[\uDC00-\uDC2F]'
          },
          {
              name: 'InMalayalam',
              bmp: '\u0D00-\u0D7F'
          },
          {
              name: 'InMandaic',
              bmp: '\u0840-\u085F'
          },
          {
              name: 'InManichaean',
              astral: '\uD802[\uDEC0-\uDEFF]'
          },
          {
              name: 'InMarchen',
              astral: '\uD807[\uDC70-\uDCBF]'
          },
          {
              name: 'InMathematical_Alphanumeric_Symbols',
              astral: '\uD835[\uDC00-\uDFFF]'
          },
          {
              name: 'InMathematical_Operators',
              bmp: '\u2200-\u22FF'
          },
          {
              name: 'InMeetei_Mayek',
              bmp: '\uABC0-\uABFF'
          },
          {
              name: 'InMeetei_Mayek_Extensions',
              bmp: '\uAAE0-\uAAFF'
          },
          {
              name: 'InMende_Kikakui',
              astral: '\uD83A[\uDC00-\uDCDF]'
          },
          {
              name: 'InMeroitic_Cursive',
              astral: '\uD802[\uDDA0-\uDDFF]'
          },
          {
              name: 'InMeroitic_Hieroglyphs',
              astral: '\uD802[\uDD80-\uDD9F]'
          },
          {
              name: 'InMiao',
              astral: '\uD81B[\uDF00-\uDF9F]'
          },
          {
              name: 'InMiscellaneous_Mathematical_Symbols_A',
              bmp: '\u27C0-\u27EF'
          },
          {
              name: 'InMiscellaneous_Mathematical_Symbols_B',
              bmp: '\u2980-\u29FF'
          },
          {
              name: 'InMiscellaneous_Symbols',
              bmp: '\u2600-\u26FF'
          },
          {
              name: 'InMiscellaneous_Symbols_and_Arrows',
              bmp: '\u2B00-\u2BFF'
          },
          {
              name: 'InMiscellaneous_Symbols_and_Pictographs',
              astral: '\uD83C[\uDF00-\uDFFF]|\uD83D[\uDC00-\uDDFF]'
          },
          {
              name: 'InMiscellaneous_Technical',
              bmp: '\u2300-\u23FF'
          },
          {
              name: 'InModi',
              astral: '\uD805[\uDE00-\uDE5F]'
          },
          {
              name: 'InModifier_Tone_Letters',
              bmp: '\uA700-\uA71F'
          },
          {
              name: 'InMongolian',
              bmp: '\u1800-\u18AF'
          },
          {
              name: 'InMongolian_Supplement',
              astral: '\uD805[\uDE60-\uDE7F]'
          },
          {
              name: 'InMro',
              astral: '\uD81A[\uDE40-\uDE6F]'
          },
          {
              name: 'InMultani',
              astral: '\uD804[\uDE80-\uDEAF]'
          },
          {
              name: 'InMusical_Symbols',
              astral: '\uD834[\uDD00-\uDDFF]'
          },
          {
              name: 'InMyanmar',
              bmp: '\u1000-\u109F'
          },
          {
              name: 'InMyanmar_Extended_A',
              bmp: '\uAA60-\uAA7F'
          },
          {
              name: 'InMyanmar_Extended_B',
              bmp: '\uA9E0-\uA9FF'
          },
          {
              name: 'InNKo',
              bmp: '\u07C0-\u07FF'
          },
          {
              name: 'InNabataean',
              astral: '\uD802[\uDC80-\uDCAF]'
          },
          {
              name: 'InNew_Tai_Lue',
              bmp: '\u1980-\u19DF'
          },
          {
              name: 'InNewa',
              astral: '\uD805[\uDC00-\uDC7F]'
          },
          {
              name: 'InNumber_Forms',
              bmp: '\u2150-\u218F'
          },
          {
              name: 'InOgham',
              bmp: '\u1680-\u169F'
          },
          {
              name: 'InOl_Chiki',
              bmp: '\u1C50-\u1C7F'
          },
          {
              name: 'InOld_Hungarian',
              astral: '\uD803[\uDC80-\uDCFF]'
          },
          {
              name: 'InOld_Italic',
              astral: '\uD800[\uDF00-\uDF2F]'
          },
          {
              name: 'InOld_North_Arabian',
              astral: '\uD802[\uDE80-\uDE9F]'
          },
          {
              name: 'InOld_Permic',
              astral: '\uD800[\uDF50-\uDF7F]'
          },
          {
              name: 'InOld_Persian',
              astral: '\uD800[\uDFA0-\uDFDF]'
          },
          {
              name: 'InOld_South_Arabian',
              astral: '\uD802[\uDE60-\uDE7F]'
          },
          {
              name: 'InOld_Turkic',
              astral: '\uD803[\uDC00-\uDC4F]'
          },
          {
              name: 'InOptical_Character_Recognition',
              bmp: '\u2440-\u245F'
          },
          {
              name: 'InOriya',
              bmp: '\u0B00-\u0B7F'
          },
          {
              name: 'InOrnamental_Dingbats',
              astral: '\uD83D[\uDE50-\uDE7F]'
          },
          {
              name: 'InOsage',
              astral: '\uD801[\uDCB0-\uDCFF]'
          },
          {
              name: 'InOsmanya',
              astral: '\uD801[\uDC80-\uDCAF]'
          },
          {
              name: 'InPahawh_Hmong',
              astral: '\uD81A[\uDF00-\uDF8F]'
          },
          {
              name: 'InPalmyrene',
              astral: '\uD802[\uDC60-\uDC7F]'
          },
          {
              name: 'InPau_Cin_Hau',
              astral: '\uD806[\uDEC0-\uDEFF]'
          },
          {
              name: 'InPhags_pa',
              bmp: '\uA840-\uA87F'
          },
          {
              name: 'InPhaistos_Disc',
              astral: '\uD800[\uDDD0-\uDDFF]'
          },
          {
              name: 'InPhoenician',
              astral: '\uD802[\uDD00-\uDD1F]'
          },
          {
              name: 'InPhonetic_Extensions',
              bmp: '\u1D00-\u1D7F'
          },
          {
              name: 'InPhonetic_Extensions_Supplement',
              bmp: '\u1D80-\u1DBF'
          },
          {
              name: 'InPlaying_Cards',
              astral: '\uD83C[\uDCA0-\uDCFF]'
          },
          {
              name: 'InPrivate_Use_Area',
              bmp: '\uE000-\uF8FF'
          },
          {
              name: 'InPsalter_Pahlavi',
              astral: '\uD802[\uDF80-\uDFAF]'
          },
          {
              name: 'InRejang',
              bmp: '\uA930-\uA95F'
          },
          {
              name: 'InRumi_Numeral_Symbols',
              astral: '\uD803[\uDE60-\uDE7F]'
          },
          {
              name: 'InRunic',
              bmp: '\u16A0-\u16FF'
          },
          {
              name: 'InSamaritan',
              bmp: '\u0800-\u083F'
          },
          {
              name: 'InSaurashtra',
              bmp: '\uA880-\uA8DF'
          },
          {
              name: 'InSharada',
              astral: '\uD804[\uDD80-\uDDDF]'
          },
          {
              name: 'InShavian',
              astral: '\uD801[\uDC50-\uDC7F]'
          },
          {
              name: 'InShorthand_Format_Controls',
              astral: '\uD82F[\uDCA0-\uDCAF]'
          },
          {
              name: 'InSiddham',
              astral: '\uD805[\uDD80-\uDDFF]'
          },
          {
              name: 'InSinhala',
              bmp: '\u0D80-\u0DFF'
          },
          {
              name: 'InSinhala_Archaic_Numbers',
              astral: '\uD804[\uDDE0-\uDDFF]'
          },
          {
              name: 'InSmall_Form_Variants',
              bmp: '\uFE50-\uFE6F'
          },
          {
              name: 'InSora_Sompeng',
              astral: '\uD804[\uDCD0-\uDCFF]'
          },
          {
              name: 'InSpacing_Modifier_Letters',
              bmp: '\u02B0-\u02FF'
          },
          {
              name: 'InSpecials',
              bmp: '\uFFF0-\uFFFF'
          },
          {
              name: 'InSundanese',
              bmp: '\u1B80-\u1BBF'
          },
          {
              name: 'InSundanese_Supplement',
              bmp: '\u1CC0-\u1CCF'
          },
          {
              name: 'InSuperscripts_and_Subscripts',
              bmp: '\u2070-\u209F'
          },
          {
              name: 'InSupplemental_Arrows_A',
              bmp: '\u27F0-\u27FF'
          },
          {
              name: 'InSupplemental_Arrows_B',
              bmp: '\u2900-\u297F'
          },
          {
              name: 'InSupplemental_Arrows_C',
              astral: '\uD83E[\uDC00-\uDCFF]'
          },
          {
              name: 'InSupplemental_Mathematical_Operators',
              bmp: '\u2A00-\u2AFF'
          },
          {
              name: 'InSupplemental_Punctuation',
              bmp: '\u2E00-\u2E7F'
          },
          {
              name: 'InSupplemental_Symbols_and_Pictographs',
              astral: '\uD83E[\uDD00-\uDDFF]'
          },
          {
              name: 'InSupplementary_Private_Use_Area_A',
              astral: '[\uDB80-\uDBBF][\uDC00-\uDFFF]'
          },
          {
              name: 'InSupplementary_Private_Use_Area_B',
              astral: '[\uDBC0-\uDBFF][\uDC00-\uDFFF]'
          },
          {
              name: 'InSutton_SignWriting',
              astral: '\uD836[\uDC00-\uDEAF]'
          },
          {
              name: 'InSyloti_Nagri',
              bmp: '\uA800-\uA82F'
          },
          {
              name: 'InSyriac',
              bmp: '\u0700-\u074F'
          },
          {
              name: 'InTagalog',
              bmp: '\u1700-\u171F'
          },
          {
              name: 'InTagbanwa',
              bmp: '\u1760-\u177F'
          },
          {
              name: 'InTags',
              astral: '\uDB40[\uDC00-\uDC7F]'
          },
          {
              name: 'InTai_Le',
              bmp: '\u1950-\u197F'
          },
          {
              name: 'InTai_Tham',
              bmp: '\u1A20-\u1AAF'
          },
          {
              name: 'InTai_Viet',
              bmp: '\uAA80-\uAADF'
          },
          {
              name: 'InTai_Xuan_Jing_Symbols',
              astral: '\uD834[\uDF00-\uDF5F]'
          },
          {
              name: 'InTakri',
              astral: '\uD805[\uDE80-\uDECF]'
          },
          {
              name: 'InTamil',
              bmp: '\u0B80-\u0BFF'
          },
          {
              name: 'InTangut',
              astral: '[\uD81C-\uD821][\uDC00-\uDFFF]'
          },
          {
              name: 'InTangut_Components',
              astral: '\uD822[\uDC00-\uDEFF]'
          },
          {
              name: 'InTelugu',
              bmp: '\u0C00-\u0C7F'
          },
          {
              name: 'InThaana',
              bmp: '\u0780-\u07BF'
          },
          {
              name: 'InThai',
              bmp: '\u0E00-\u0E7F'
          },
          {
              name: 'InTibetan',
              bmp: '\u0F00-\u0FFF'
          },
          {
              name: 'InTifinagh',
              bmp: '\u2D30-\u2D7F'
          },
          {
              name: 'InTirhuta',
              astral: '\uD805[\uDC80-\uDCDF]'
          },
          {
              name: 'InTransport_and_Map_Symbols',
              astral: '\uD83D[\uDE80-\uDEFF]'
          },
          {
              name: 'InUgaritic',
              astral: '\uD800[\uDF80-\uDF9F]'
          },
          {
              name: 'InUnified_Canadian_Aboriginal_Syllabics',
              bmp: '\u1400-\u167F'
          },
          {
              name: 'InUnified_Canadian_Aboriginal_Syllabics_Extended',
              bmp: '\u18B0-\u18FF'
          },
          {
              name: 'InVai',
              bmp: '\uA500-\uA63F'
          },
          {
              name: 'InVariation_Selectors',
              bmp: '\uFE00-\uFE0F'
          },
          {
              name: 'InVariation_Selectors_Supplement',
              astral: '\uDB40[\uDD00-\uDDEF]'
          },
          {
              name: 'InVedic_Extensions',
              bmp: '\u1CD0-\u1CFF'
          },
          {
              name: 'InVertical_Forms',
              bmp: '\uFE10-\uFE1F'
          },
          {
              name: 'InWarang_Citi',
              astral: '\uD806[\uDCA0-\uDCFF]'
          },
          {
              name: 'InYi_Radicals',
              bmp: '\uA490-\uA4CF'
          },
          {
              name: 'InYi_Syllables',
              bmp: '\uA000-\uA48F'
          },
          {
              name: 'InYijing_Hexagram_Symbols',
              bmp: '\u4DC0-\u4DFF'
          }
      ]);

  };

  },{}],5:[function(require,module,exports){
  /*!
   * XRegExp Unicode Categories 3.2.0
   * <xregexp.com>
   * Steven Levithan (c) 2010-2017 MIT License
   * Unicode data by Mathias Bynens <mathiasbynens.be>
   */

  module.exports = function(XRegExp) {

      /**
       * Adds support for Unicode's general categories. E.g., `\p{Lu}` or `\p{Uppercase Letter}`. See
       * category descriptions in UAX #44 <http://unicode.org/reports/tr44/#GC_Values_Table>. Token
       * names are case insensitive, and any spaces, hyphens, and underscores are ignored.
       *
       * Uses Unicode 9.0.0.
       *
       * @requires XRegExp, Unicode Base
       */

      if (!XRegExp.addUnicodeData) {
          throw new ReferenceError('Unicode Base must be loaded before Unicode Categories');
      }

      XRegExp.addUnicodeData([
          {
              name: 'C',
              alias: 'Other',
              isBmpLast: true,
              bmp: '\0-\x1F\x7F-\x9F\xAD\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u0560\u0588\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u0605\u061C\u061D\u06DD\u070E\u070F\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08B5\u08BE-\u08D3\u08E2\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0AFA-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D00\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D50-\u0D53\u0D64\u0D65\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180E\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ABF-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C89-\u1CBF\u1CC8-\u1CCF\u1CF7\u1CFA-\u1CFF\u1DF6-\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u200B-\u200F\u202A-\u202E\u2060-\u206F\u2072\u2073\u208F\u209D-\u209F\u20BF-\u20CF\u20F1-\u20FF\u218C-\u218F\u23FF\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2BEB\u2BF0-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E45-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FD6-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7AF\uA7B8-\uA7F6\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C6-\uA8CD\uA8DA-\uA8DF\uA8FE\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB66-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD-\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF',
              astral: '\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2F\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE34-\uDE37\uDE3B-\uDE3E\uDE48-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD00-\uDE5F\uDE7F-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCBD\uDCC2-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD44-\uDD4F\uDD77-\uDD7F\uDDCE\uDDCF\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF3B\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5A\uDC5C\uDC5E-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEB8-\uDEBF\uDECA-\uDEFF\uDF1A-\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD806[\uDC00-\uDC9F\uDCF3-\uDCFE\uDD00-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD823-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83F\uD874-\uD87D\uD87F-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDEFF\uDF45-\uDF4F\uDF7F-\uDF8E\uDFA0-\uDFDF\uDFE1-\uDFFF]|\uD821[\uDFED-\uDFFF]|\uD822[\uDEF3-\uDFFF]|\uD82C[\uDC02-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA0-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDD73-\uDD7A\uDDE9-\uDDFF\uDE46-\uDEFF\uDF57-\uDF5F\uDF72-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4B-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD6F\uDDAD-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF]|\uD83D[\uDED3-\uDEDF\uDEED-\uDEEF\uDEF7-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDD0F\uDD1F\uDD28-\uDD2F\uDD31\uDD32\uDD3F\uDD4C-\uDD4F\uDD5F-\uDD7F\uDD92-\uDDBF\uDDC1-\uDFFF]|\uD869[\uDED7-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]'
          },
          {
              name: 'Cc',
              alias: 'Control',
              bmp: '\0-\x1F\x7F-\x9F'
          },
          {
              name: 'Cf',
              alias: 'Format',
              bmp: '\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB',
              astral: '\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]'
          },
          {
              name: 'Cn',
              alias: 'Unassigned',
              bmp: '\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u0560\u0588\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u05FF\u061D\u070E\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08B5\u08BE-\u08D3\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0AFA-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C04\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D00\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D50-\u0D53\u0D64\u0D65\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ABF-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C89-\u1CBF\u1CC8-\u1CCF\u1CF7\u1CFA-\u1CFF\u1DF6-\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u2065\u2072\u2073\u208F\u209D-\u209F\u20BF-\u20CF\u20F1-\u20FF\u218C-\u218F\u23FF\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2BEB\u2BF0-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E45-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FD6-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7AF\uA7B8-\uA7F6\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C6-\uA8CD\uA8DA-\uA8DF\uA8FE\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB66-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD\uFEFE\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFF8\uFFFE\uFFFF',
              astral: '\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2F\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE34-\uDE37\uDE3B-\uDE3E\uDE48-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD00-\uDE5F\uDE7F-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCC2-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD44-\uDD4F\uDD77-\uDD7F\uDDCE\uDDCF\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF3B\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5A\uDC5C\uDC5E-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEB8-\uDEBF\uDECA-\uDEFF\uDF1A-\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD806[\uDC00-\uDC9F\uDCF3-\uDCFE\uDD00-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD823-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83F\uD874-\uD87D\uD87F-\uDB3F\uDB41-\uDB7F][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDEFF\uDF45-\uDF4F\uDF7F-\uDF8E\uDFA0-\uDFDF\uDFE1-\uDFFF]|\uD821[\uDFED-\uDFFF]|\uD822[\uDEF3-\uDFFF]|\uD82C[\uDC02-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA4-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDDE9-\uDDFF\uDE46-\uDEFF\uDF57-\uDF5F\uDF72-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4B-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD6F\uDDAD-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF]|\uD83D[\uDED3-\uDEDF\uDEED-\uDEEF\uDEF7-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDD0F\uDD1F\uDD28-\uDD2F\uDD31\uDD32\uDD3F\uDD4C-\uDD4F\uDD5F-\uDD7F\uDD92-\uDDBF\uDDC1-\uDFFF]|\uD869[\uDED7-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uDB40[\uDC00\uDC02-\uDC1F\uDC80-\uDCFF\uDDF0-\uDFFF]|[\uDBBF\uDBFF][\uDFFE\uDFFF]'
          },
          {
              name: 'Co',
              alias: 'Private_Use',
              bmp: '\uE000-\uF8FF',
              astral: '[\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uDBBF\uDBFF][\uDC00-\uDFFD]'
          },
          {
              name: 'Cs',
              alias: 'Surrogate',
              bmp: '\uD800-\uDFFF'
          },
          {
              name: 'L',
              alias: 'Letter',
              bmp: 'A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
              astral: '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]'
          },
          {
              name: 'Ll',
              alias: 'Lowercase_Letter',
              bmp: 'a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A',
              astral: '\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]'
          },
          {
              name: 'Lm',
              alias: 'Modifier_Letter',
              bmp: '\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F',
              astral: '\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]'
          },
          {
              name: 'Lo',
              alias: 'Other_Letter',
              bmp: '\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
              astral: '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]'
          },
          {
              name: 'Lt',
              alias: 'Titlecase_Letter',
              bmp: '\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC'
          },
          {
              name: 'Lu',
              alias: 'Uppercase_Letter',
              bmp: 'A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A',
              astral: '\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]'
          },
          {
              name: 'M',
              alias: 'Mark',
              bmp: '\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F',
              astral: '\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDCA-\uDDCC\uDE2C-\uDE37\uDE3E\uDEDF-\uDEEA\uDF00-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC35-\uDC46\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDEAB-\uDEB7\uDF1D-\uDF2B]|\uD807[\uDC2F-\uDC36\uDC38-\uDC3F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]'
          },
          {
              name: 'Mc',
              alias: 'Spacing_Mark',
              bmp: '\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BE-\u09C0\u09C7\u09C8\u09CB\u09CC\u09D7\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD7\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0-\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0D02\u0D03\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D57\u0D82\u0D83\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DF2\u0DF3\u0F3E\u0F3F\u0F7F\u102B\u102C\u1031\u1038\u103B\u103C\u1056\u1057\u1062-\u1064\u1067-\u106D\u1083\u1084\u1087-\u108C\u108F\u109A-\u109C\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1B04\u1B35\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF2\u1CF3\u302E\u302F\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BD-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAA7B\uAA7D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC',
              astral: '\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3E\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB0-\uDCB2\uDCB9\uDCBB-\uDCBE\uDCC1\uDDAF-\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF20\uDF21\uDF26]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4]|\uD81B[\uDF51-\uDF7E]|\uD834[\uDD65\uDD66\uDD6D-\uDD72]'
          },
          {
              name: 'Me',
              alias: 'Enclosing_Mark',
              bmp: '\u0488\u0489\u1ABE\u20DD-\u20E0\u20E2-\u20E4\uA670-\uA672'
          },
          {
              name: 'Mn',
              alias: 'Nonspacing_Mark',
              bmp: '\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D01\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F',
              astral: '\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDCA-\uDDCC\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]'
          },
          {
              name: 'N',
              alias: 'Number',
              bmp: '0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D58-\u0D5E\u0D66-\u0D78\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19',
              astral: '\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE47\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2]|\uD807[\uDC50-\uDC6C]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD834[\uDF60-\uDF71]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83C[\uDD00-\uDD0C]'
          },
          {
              name: 'Nd',
              alias: 'Decimal_Number',
              bmp: '0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19',
              astral: '\uD801[\uDCA0-\uDCA9]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9]|\uD807[\uDC50-\uDC59]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDD50-\uDD59]'
          },
          {
              name: 'Nl',
              alias: 'Letter_Number',
              bmp: '\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF',
              astral: '\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]|\uD809[\uDC00-\uDC6E]'
          },
          {
              name: 'No',
              alias: 'Other_Number',
              bmp: '\xB2\xB3\xB9\xBC-\xBE\u09F4-\u09F9\u0B72-\u0B77\u0BF0-\u0BF2\u0C78-\u0C7E\u0D58-\u0D5E\u0D70-\u0D78\u0F2A-\u0F33\u1369-\u137C\u17F0-\u17F9\u19DA\u2070\u2074-\u2079\u2080-\u2089\u2150-\u215F\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA830-\uA835',
              astral: '\uD800[\uDD07-\uDD33\uDD75-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE47\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E]|\uD804[\uDC52-\uDC65\uDDE1-\uDDF4]|\uD805[\uDF3A\uDF3B]|\uD806[\uDCEA-\uDCF2]|\uD807[\uDC5A-\uDC6C]|\uD81A[\uDF5B-\uDF61]|\uD834[\uDF60-\uDF71]|\uD83A[\uDCC7-\uDCCF]|\uD83C[\uDD00-\uDD0C]'
          },
          {
              name: 'P',
              alias: 'Punctuation',
              bmp: '\x21-\x23\x25-\\x2A\x2C-\x2F\x3A\x3B\\x3F\x40\\x5B-\\x5D\x5F\\x7B\x7D\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65',
              astral: '\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]'
          },
          {
              name: 'Pc',
              alias: 'Connector_Punctuation',
              bmp: '\x5F\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F'
          },
          {
              name: 'Pd',
              alias: 'Dash_Punctuation',
              bmp: '\\x2D\u058A\u05BE\u1400\u1806\u2010-\u2015\u2E17\u2E1A\u2E3A\u2E3B\u2E40\u301C\u3030\u30A0\uFE31\uFE32\uFE58\uFE63\uFF0D'
          },
          {
              name: 'Pe',
              alias: 'Close_Punctuation',
              bmp: '\\x29\\x5D\x7D\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u2309\u230B\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3E\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63'
          },
          {
              name: 'Pf',
              alias: 'Final_Punctuation',
              bmp: '\xBB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21'
          },
          {
              name: 'Pi',
              alias: 'Initial_Punctuation',
              bmp: '\xAB\u2018\u201B\u201C\u201F\u2039\u2E02\u2E04\u2E09\u2E0C\u2E1C\u2E20'
          },
          {
              name: 'Po',
              alias: 'Other_Punctuation',
              bmp: '\x21-\x23\x25-\x27\\x2A\x2C\\x2E\x2F\x3A\x3B\\x3F\x40\\x5C\xA1\xA7\xB6\xB7\xBF\u037E\u0387\u055A-\u055F\u0589\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u166D\u166E\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u1805\u1807-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2016\u2017\u2020-\u2027\u2030-\u2038\u203B-\u203E\u2041-\u2043\u2047-\u2051\u2053\u2055-\u205E\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E06-\u2E08\u2E0B\u2E0E-\u2E16\u2E18\u2E19\u2E1B\u2E1E\u2E1F\u2E2A-\u2E2E\u2E30-\u2E39\u2E3C-\u2E3F\u2E41\u2E43\u2E44\u3001-\u3003\u303D\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFE10-\uFE16\uFE19\uFE30\uFE45\uFE46\uFE49-\uFE4C\uFE50-\uFE52\uFE54-\uFE57\uFE5F-\uFE61\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF07\uFF0A\uFF0C\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3C\uFF61\uFF64\uFF65',
              astral: '\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]'
          },
          {
              name: 'Ps',
              alias: 'Open_Punctuation',
              bmp: '\\x28\\x5B\\x7B\u0F3A\u0F3C\u169B\u201A\u201E\u2045\u207D\u208D\u2308\u230A\u2329\u2768\u276A\u276C\u276E\u2770\u2772\u2774\u27C5\u27E6\u27E8\u27EA\u27EC\u27EE\u2983\u2985\u2987\u2989\u298B\u298D\u298F\u2991\u2993\u2995\u2997\u29D8\u29DA\u29FC\u2E22\u2E24\u2E26\u2E28\u2E42\u3008\u300A\u300C\u300E\u3010\u3014\u3016\u3018\u301A\u301D\uFD3F\uFE17\uFE35\uFE37\uFE39\uFE3B\uFE3D\uFE3F\uFE41\uFE43\uFE47\uFE59\uFE5B\uFE5D\uFF08\uFF3B\uFF5B\uFF5F\uFF62'
          },
          {
              name: 'S',
              alias: 'Symbol',
              bmp: '\\x24\\x2B\x3C-\x3E\\x5E\x60\\x7C\x7E\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20BE\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u23FE\u2400-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u32FE\u3300-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uFB29\uFBB2-\uFBC1\uFDFC\uFDFD\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD',
              astral: '\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD83B[\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDDAC\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED2\uDEE0-\uDEEC\uDEF0-\uDEF6\uDF00-\uDF73\uDF80-\uDFD4]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD1E\uDD20-\uDD27\uDD30\uDD33-\uDD3E\uDD40-\uDD4B\uDD50-\uDD5E\uDD80-\uDD91\uDDC0]'
          },
          {
              name: 'Sc',
              alias: 'Currency_Symbol',
              bmp: '\\x24\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20BE\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6'
          },
          {
              name: 'Sk',
              alias: 'Modifier_Symbol',
              bmp: '\\x5E\x60\xA8\xAF\xB4\xB8\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u309B\u309C\uA700-\uA716\uA720\uA721\uA789\uA78A\uAB5B\uFBB2-\uFBC1\uFF3E\uFF40\uFFE3',
              astral: '\uD83C[\uDFFB-\uDFFF]'
          },
          {
              name: 'Sm',
              alias: 'Math_Symbol',
              bmp: '\\x2B\x3C-\x3E\\x7C\x7E\xAC\xB1\xD7\xF7\u03F6\u0606-\u0608\u2044\u2052\u207A-\u207C\u208A-\u208C\u2118\u2140-\u2144\u214B\u2190-\u2194\u219A\u219B\u21A0\u21A3\u21A6\u21AE\u21CE\u21CF\u21D2\u21D4\u21F4-\u22FF\u2320\u2321\u237C\u239B-\u23B3\u23DC-\u23E1\u25B7\u25C1\u25F8-\u25FF\u266F\u27C0-\u27C4\u27C7-\u27E5\u27F0-\u27FF\u2900-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2AFF\u2B30-\u2B44\u2B47-\u2B4C\uFB29\uFE62\uFE64-\uFE66\uFF0B\uFF1C-\uFF1E\uFF5C\uFF5E\uFFE2\uFFE9-\uFFEC',
              astral: '\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD83B[\uDEF0\uDEF1]'
          },
          {
              name: 'So',
              alias: 'Other_Symbol',
              bmp: '\xA6\xA9\xAE\xB0\u0482\u058D\u058E\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u09FA\u0B70\u0BF3-\u0BF8\u0BFA\u0C7F\u0D4F\u0D79\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116\u2117\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u214A\u214C\u214D\u214F\u218A\u218B\u2195-\u2199\u219C-\u219F\u21A1\u21A2\u21A4\u21A5\u21A7-\u21AD\u21AF-\u21CD\u21D0\u21D1\u21D3\u21D5-\u21F3\u2300-\u2307\u230C-\u231F\u2322-\u2328\u232B-\u237B\u237D-\u239A\u23B4-\u23DB\u23E2-\u23FE\u2400-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u25B6\u25B8-\u25C0\u25C2-\u25F7\u2600-\u266E\u2670-\u2767\u2794-\u27BF\u2800-\u28FF\u2B00-\u2B2F\u2B45\u2B46\u2B4D-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u32FE\u3300-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA828-\uA82B\uA836\uA837\uA839\uAA77-\uAA79\uFDFD\uFFE4\uFFE8\uFFED\uFFEE\uFFFC\uFFFD',
              astral: '\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDDAC\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFA]|\uD83D[\uDC00-\uDED2\uDEE0-\uDEEC\uDEF0-\uDEF6\uDF00-\uDF73\uDF80-\uDFD4]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD1E\uDD20-\uDD27\uDD30\uDD33-\uDD3E\uDD40-\uDD4B\uDD50-\uDD5E\uDD80-\uDD91\uDDC0]'
          },
          {
              name: 'Z',
              alias: 'Separator',
              bmp: '\x20\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000'
          },
          {
              name: 'Zl',
              alias: 'Line_Separator',
              bmp: '\u2028'
          },
          {
              name: 'Zp',
              alias: 'Paragraph_Separator',
              bmp: '\u2029'
          },
          {
              name: 'Zs',
              alias: 'Space_Separator',
              bmp: '\x20\xA0\u1680\u2000-\u200A\u202F\u205F\u3000'
          }
      ]);

  };

  },{}],6:[function(require,module,exports){
  /*!
   * XRegExp Unicode Properties 3.2.0
   * <xregexp.com>
   * Steven Levithan (c) 2012-2017 MIT License
   * Unicode data by Mathias Bynens <mathiasbynens.be>
   */

  module.exports = function(XRegExp) {

      /**
       * Adds properties to meet the UTS #18 Level 1 RL1.2 requirements for Unicode regex support. See
       * <http://unicode.org/reports/tr18/#RL1.2>. Following are definitions of these properties from
       * UAX #44 <http://unicode.org/reports/tr44/>:
       *
       * - Alphabetic
       *   Characters with the Alphabetic property. Generated from: Lowercase + Uppercase + Lt + Lm +
       *   Lo + Nl + Other_Alphabetic.
       *
       * - Default_Ignorable_Code_Point
       *   For programmatic determination of default ignorable code points. New characters that should
       *   be ignored in rendering (unless explicitly supported) will be assigned in these ranges,
       *   permitting programs to correctly handle the default rendering of such characters when not
       *   otherwise supported.
       *
       * - Lowercase
       *   Characters with the Lowercase property. Generated from: Ll + Other_Lowercase.
       *
       * - Noncharacter_Code_Point
       *   Code points permanently reserved for internal use.
       *
       * - Uppercase
       *   Characters with the Uppercase property. Generated from: Lu + Other_Uppercase.
       *
       * - White_Space
       *   Spaces, separator characters and other control characters which should be treated by
       *   programming languages as "white space" for the purpose of parsing elements.
       *
       * The properties ASCII, Any, and Assigned are also included but are not defined in UAX #44. UTS
       * #18 RL1.2 additionally requires support for Unicode scripts and general categories. These are
       * included in XRegExp's Unicode Categories and Unicode Scripts addons.
       *
       * Token names are case insensitive, and any spaces, hyphens, and underscores are ignored.
       *
       * Uses Unicode 9.0.0.
       *
       * @requires XRegExp, Unicode Base
       */

      if (!XRegExp.addUnicodeData) {
          throw new ReferenceError('Unicode Base must be loaded before Unicode Properties');
      }

      var unicodeData = [
          {
              name: 'ASCII',
              bmp: '\0-\x7F'
          },
          {
              name: 'Alphabetic',
              bmp: 'A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0345\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05B0-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0657\u0659-\u065F\u066E-\u06D3\u06D5-\u06DC\u06E1-\u06E8\u06ED-\u06EF\u06FA-\u06FC\u06FF\u0710-\u073F\u074D-\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0817\u081A-\u082C\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08DF\u08E3-\u08E9\u08F0-\u093B\u093D-\u094C\u094E-\u0950\u0955-\u0963\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C4\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09F0\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A42\u0A47\u0A48\u0A4B\u0A4C\u0A51\u0A59-\u0A5C\u0A5E\u0A70-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC5\u0AC7-\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0-\u0AE3\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D-\u0B44\u0B47\u0B48\u0B4B\u0B4C\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4C\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCC\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E46\u0E4D\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0ECD\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F71-\u0F81\u0F88-\u0F97\u0F99-\u0FBC\u1000-\u1036\u1038\u103B-\u103F\u1050-\u1062\u1065-\u1068\u106E-\u1086\u108E\u109C\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1713\u1720-\u1733\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17B3\u17B6-\u17C8\u17D7\u17DC\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u1938\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A1B\u1A20-\u1A5E\u1A61-\u1A74\u1AA7\u1B00-\u1B33\u1B35-\u1B43\u1B45-\u1B4B\u1B80-\u1BA9\u1BAC-\u1BAF\u1BBA-\u1BE5\u1BE7-\u1BF1\u1C00-\u1C35\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1D00-\u1DBF\u1DE7-\u1DF4\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u24B6-\u24E9\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA674-\uA67B\uA67F-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA827\uA840-\uA873\uA880-\uA8C3\uA8C5\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA92A\uA930-\uA952\uA960-\uA97C\uA980-\uA9B2\uA9B4-\uA9BF\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA60-\uAA76\uAA7A\uAA7E-\uAABE\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
              astral: '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC45\uDC82-\uDCB8\uDCD0-\uDCE8\uDD00-\uDD32\uDD50-\uDD72\uDD76\uDD80-\uDDBF\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE34\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEE8\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D-\uDF44\uDF47\uDF48\uDF4B\uDF4C\uDF50\uDF57\uDF5D-\uDF63]|\uD805[\uDC00-\uDC41\uDC43-\uDC45\uDC47-\uDC4A\uDC80-\uDCC1\uDCC4\uDCC5\uDCC7\uDD80-\uDDB5\uDDB8-\uDDBE\uDDD8-\uDDDD\uDE00-\uDE3E\uDE40\uDE44\uDE80-\uDEB5\uDF00-\uDF19\uDF1D-\uDF2A]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC3E\uDC40\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF36\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9E]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD47]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]'
          },
          {
              name: 'Any',
              isBmpLast: true,
              bmp: '\0-\uFFFF',
              astral: '[\uD800-\uDBFF][\uDC00-\uDFFF]'
          },
          {
              name: 'Default_Ignorable_Code_Point',
              bmp: '\xAD\u034F\u061C\u115F\u1160\u17B4\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8',
              astral: '\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|[\uDB40-\uDB43][\uDC00-\uDFFF]'
          },
          {
              name: 'Lowercase',
              bmp: 'a-z\xAA\xB5\xBA\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02B8\u02C0\u02C1\u02E0-\u02E4\u0345\u0371\u0373\u0377\u037A-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1DBF\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u2071\u207F\u2090-\u209C\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2170-\u217F\u2184\u24D0-\u24E9\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7D\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B-\uA69D\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7F8-\uA7FA\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A',
              astral: '\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]'
          },
          {
              name: 'Noncharacter_Code_Point',
              bmp: '\uFDD0-\uFDEF\uFFFE\uFFFF',
              astral: '[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]'
          },
          {
              name: 'Uppercase',
              bmp: 'A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2160-\u216F\u2183\u24B6-\u24CF\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A',
              astral: '\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]'
          },
          {
              name: 'White_Space',
              bmp: '\x09-\x0D\x20\x85\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000'
          }
      ];

      // Add non-generated data
      unicodeData.push({
          name: 'Assigned',
          // Since this is defined as the inverse of Unicode category Cn (Unassigned), the Unicode
          // Categories addon is required to use this property
          inverseOf: 'Cn'
      });

      XRegExp.addUnicodeData(unicodeData);

  };

  },{}],7:[function(require,module,exports){
  /*!
   * XRegExp Unicode Scripts 3.2.0
   * <xregexp.com>
   * Steven Levithan (c) 2010-2017 MIT License
   * Unicode data by Mathias Bynens <mathiasbynens.be>
   */

  module.exports = function(XRegExp) {

      /**
       * Adds support for all Unicode scripts. E.g., `\p{Latin}`. Token names are case insensitive,
       * and any spaces, hyphens, and underscores are ignored.
       *
       * Uses Unicode 9.0.0.
       *
       * @requires XRegExp, Unicode Base
       */

      if (!XRegExp.addUnicodeData) {
          throw new ReferenceError('Unicode Base must be loaded before Unicode Scripts');
      }

      XRegExp.addUnicodeData([
          {
              name: 'Adlam',
              astral: '\uD83A[\uDD00-\uDD4A\uDD50-\uDD59\uDD5E\uDD5F]'
          },
          {
              name: 'Ahom',
              astral: '\uD805[\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF3F]'
          },
          {
              name: 'Anatolian_Hieroglyphs',
              astral: '\uD811[\uDC00-\uDE46]'
          },
          {
              name: 'Arabic',
              bmp: '\u0600-\u0604\u0606-\u060B\u060D-\u061A\u061E\u0620-\u063F\u0641-\u064A\u0656-\u066F\u0671-\u06DC\u06DE-\u06FF\u0750-\u077F\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u08FF\uFB50-\uFBC1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFD\uFE70-\uFE74\uFE76-\uFEFC',
              astral: '\uD803[\uDE60-\uDE7E]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB\uDEF0\uDEF1]'
          },
          {
              name: 'Armenian',
              bmp: '\u0531-\u0556\u0559-\u055F\u0561-\u0587\u058A\u058D-\u058F\uFB13-\uFB17'
          },
          {
              name: 'Avestan',
              astral: '\uD802[\uDF00-\uDF35\uDF39-\uDF3F]'
          },
          {
              name: 'Balinese',
              bmp: '\u1B00-\u1B4B\u1B50-\u1B7C'
          },
          {
              name: 'Bamum',
              bmp: '\uA6A0-\uA6F7',
              astral: '\uD81A[\uDC00-\uDE38]'
          },
          {
              name: 'Bassa_Vah',
              astral: '\uD81A[\uDED0-\uDEED\uDEF0-\uDEF5]'
          },
          {
              name: 'Batak',
              bmp: '\u1BC0-\u1BF3\u1BFC-\u1BFF'
          },
          {
              name: 'Bengali',
              bmp: '\u0980-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FB'
          },
          {
              name: 'Bhaiksuki',
              astral: '\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC45\uDC50-\uDC6C]'
          },
          {
              name: 'Bopomofo',
              bmp: '\u02EA\u02EB\u3105-\u312D\u31A0-\u31BA'
          },
          {
              name: 'Brahmi',
              astral: '\uD804[\uDC00-\uDC4D\uDC52-\uDC6F\uDC7F]'
          },
          {
              name: 'Braille',
              bmp: '\u2800-\u28FF'
          },
          {
              name: 'Buginese',
              bmp: '\u1A00-\u1A1B\u1A1E\u1A1F'
          },
          {
              name: 'Buhid',
              bmp: '\u1740-\u1753'
          },
          {
              name: 'Canadian_Aboriginal',
              bmp: '\u1400-\u167F\u18B0-\u18F5'
          },
          {
              name: 'Carian',
              astral: '\uD800[\uDEA0-\uDED0]'
          },
          {
              name: 'Caucasian_Albanian',
              astral: '\uD801[\uDD30-\uDD63\uDD6F]'
          },
          {
              name: 'Chakma',
              astral: '\uD804[\uDD00-\uDD34\uDD36-\uDD43]'
          },
          {
              name: 'Cham',
              bmp: '\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAA5F'
          },
          {
              name: 'Cherokee',
              bmp: '\u13A0-\u13F5\u13F8-\u13FD\uAB70-\uABBF'
          },
          {
              name: 'Common',
              bmp: '\0-\x40\\x5B-\x60\\x7B-\xA9\xAB-\xB9\xBB-\xBF\xD7\xF7\u02B9-\u02DF\u02E5-\u02E9\u02EC-\u02FF\u0374\u037E\u0385\u0387\u0589\u0605\u060C\u061B\u061C\u061F\u0640\u06DD\u08E2\u0964\u0965\u0E3F\u0FD5-\u0FD8\u10FB\u16EB-\u16ED\u1735\u1736\u1802\u1803\u1805\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u2000-\u200B\u200E-\u2064\u2066-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20BE\u2100-\u2125\u2127-\u2129\u212C-\u2131\u2133-\u214D\u214F-\u215F\u2189-\u218B\u2190-\u23FE\u2400-\u2426\u2440-\u244A\u2460-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD1\u2BEC-\u2BEF\u2E00-\u2E44\u2FF0-\u2FFB\u3000-\u3004\u3006\u3008-\u3020\u3030-\u3037\u303C-\u303F\u309B\u309C\u30A0\u30FB\u30FC\u3190-\u319F\u31C0-\u31E3\u3220-\u325F\u327F-\u32CF\u3358-\u33FF\u4DC0-\u4DFF\uA700-\uA721\uA788-\uA78A\uA830-\uA839\uA92E\uA9CF\uAB5B\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFF70\uFF9E\uFF9F\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD',
              astral: '\uD800[\uDD00-\uDD02\uDD07-\uDD33\uDD37-\uDD3F\uDD90-\uDD9B\uDDD0-\uDDFC\uDEE1-\uDEFB]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD66\uDD6A-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDF00-\uDF56\uDF60-\uDF71]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDFCB\uDFCE-\uDFFF]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD00-\uDD0C\uDD10-\uDD2E\uDD30-\uDD6B\uDD70-\uDDAC\uDDE6-\uDDFF\uDE01\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED2\uDEE0-\uDEEC\uDEF0-\uDEF6\uDF00-\uDF73\uDF80-\uDFD4]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD10-\uDD1E\uDD20-\uDD27\uDD30\uDD33-\uDD3E\uDD40-\uDD4B\uDD50-\uDD5E\uDD80-\uDD91\uDDC0]|\uDB40[\uDC01\uDC20-\uDC7F]'
          },
          {
              name: 'Coptic',
              bmp: '\u03E2-\u03EF\u2C80-\u2CF3\u2CF9-\u2CFF'
          },
          {
              name: 'Cuneiform',
              astral: '\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC70-\uDC74\uDC80-\uDD43]'
          },
          {
              name: 'Cypriot',
              astral: '\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F]'
          },
          {
              name: 'Cyrillic',
              bmp: '\u0400-\u0484\u0487-\u052F\u1C80-\u1C88\u1D2B\u1D78\u2DE0-\u2DFF\uA640-\uA69F\uFE2E\uFE2F'
          },
          {
              name: 'Deseret',
              astral: '\uD801[\uDC00-\uDC4F]'
          },
          {
              name: 'Devanagari',
              bmp: '\u0900-\u0950\u0953-\u0963\u0966-\u097F\uA8E0-\uA8FD'
          },
          {
              name: 'Duployan',
              astral: '\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9C-\uDC9F]'
          },
          {
              name: 'Egyptian_Hieroglyphs',
              astral: '\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]'
          },
          {
              name: 'Elbasan',
              astral: '\uD801[\uDD00-\uDD27]'
          },
          {
              name: 'Ethiopic',
              bmp: '\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E'
          },
          {
              name: 'Georgian',
              bmp: '\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u10FF\u2D00-\u2D25\u2D27\u2D2D'
          },
          {
              name: 'Glagolitic',
              bmp: '\u2C00-\u2C2E\u2C30-\u2C5E',
              astral: '\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]'
          },
          {
              name: 'Gothic',
              astral: '\uD800[\uDF30-\uDF4A]'
          },
          {
              name: 'Grantha',
              astral: '\uD804[\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]'
          },
          {
              name: 'Greek',
              bmp: '\u0370-\u0373\u0375-\u0377\u037A-\u037D\u037F\u0384\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03E1\u03F0-\u03FF\u1D26-\u1D2A\u1D5D-\u1D61\u1D66-\u1D6A\u1DBF\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u2126\uAB65',
              astral: '\uD800[\uDD40-\uDD8E\uDDA0]|\uD834[\uDE00-\uDE45]'
          },
          {
              name: 'Gujarati',
              bmp: '\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9'
          },
          {
              name: 'Gurmukhi',
              bmp: '\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75'
          },
          {
              name: 'Han',
              bmp: '\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u3005\u3007\u3021-\u3029\u3038-\u303B\u3400-\u4DB5\u4E00-\u9FD5\uF900-\uFA6D\uFA70-\uFAD9',
              astral: '[\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]'
          },
          {
              name: 'Hangul',
              bmp: '\u1100-\u11FF\u302E\u302F\u3131-\u318E\u3200-\u321E\u3260-\u327E\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC'
          },
          {
              name: 'Hanunoo',
              bmp: '\u1720-\u1734'
          },
          {
              name: 'Hatran',
              astral: '\uD802[\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDCFF]'
          },
          {
              name: 'Hebrew',
              bmp: '\u0591-\u05C7\u05D0-\u05EA\u05F0-\u05F4\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFB4F'
          },
          {
              name: 'Hiragana',
              bmp: '\u3041-\u3096\u309D-\u309F',
              astral: '\uD82C\uDC01|\uD83C\uDE00'
          },
          {
              name: 'Imperial_Aramaic',
              astral: '\uD802[\uDC40-\uDC55\uDC57-\uDC5F]'
          },
          {
              name: 'Inherited',
              bmp: '\u0300-\u036F\u0485\u0486\u064B-\u0655\u0670\u0951\u0952\u1AB0-\u1ABE\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u200C\u200D\u20D0-\u20F0\u302A-\u302D\u3099\u309A\uFE00-\uFE0F\uFE20-\uFE2D',
              astral: '\uD800[\uDDFD\uDEE0]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD]|\uDB40[\uDD00-\uDDEF]'
          },
          {
              name: 'Inscriptional_Pahlavi',
              astral: '\uD802[\uDF60-\uDF72\uDF78-\uDF7F]'
          },
          {
              name: 'Inscriptional_Parthian',
              astral: '\uD802[\uDF40-\uDF55\uDF58-\uDF5F]'
          },
          {
              name: 'Javanese',
              bmp: '\uA980-\uA9CD\uA9D0-\uA9D9\uA9DE\uA9DF'
          },
          {
              name: 'Kaithi',
              astral: '\uD804[\uDC80-\uDCC1]'
          },
          {
              name: 'Kannada',
              bmp: '\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2'
          },
          {
              name: 'Katakana',
              bmp: '\u30A1-\u30FA\u30FD-\u30FF\u31F0-\u31FF\u32D0-\u32FE\u3300-\u3357\uFF66-\uFF6F\uFF71-\uFF9D',
              astral: '\uD82C\uDC00'
          },
          {
              name: 'Kayah_Li',
              bmp: '\uA900-\uA92D\uA92F'
          },
          {
              name: 'Kharoshthi',
              astral: '\uD802[\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F-\uDE47\uDE50-\uDE58]'
          },
          {
              name: 'Khmer',
              bmp: '\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u19E0-\u19FF'
          },
          {
              name: 'Khojki',
              astral: '\uD804[\uDE00-\uDE11\uDE13-\uDE3E]'
          },
          {
              name: 'Khudawadi',
              astral: '\uD804[\uDEB0-\uDEEA\uDEF0-\uDEF9]'
          },
          {
              name: 'Lao',
              bmp: '\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF'
          },
          {
              name: 'Latin',
              bmp: 'A-Za-z\xAA\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02E0-\u02E4\u1D00-\u1D25\u1D2C-\u1D5C\u1D62-\u1D65\u1D6B-\u1D77\u1D79-\u1DBE\u1E00-\u1EFF\u2071\u207F\u2090-\u209C\u212A\u212B\u2132\u214E\u2160-\u2188\u2C60-\u2C7F\uA722-\uA787\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA7FF\uAB30-\uAB5A\uAB5C-\uAB64\uFB00-\uFB06\uFF21-\uFF3A\uFF41-\uFF5A'
          },
          {
              name: 'Lepcha',
              bmp: '\u1C00-\u1C37\u1C3B-\u1C49\u1C4D-\u1C4F'
          },
          {
              name: 'Limbu',
              bmp: '\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u194F'
          },
          {
              name: 'Linear_A',
              astral: '\uD801[\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]'
          },
          {
              name: 'Linear_B',
              astral: '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA]'
          },
          {
              name: 'Lisu',
              bmp: '\uA4D0-\uA4FF'
          },
          {
              name: 'Lycian',
              astral: '\uD800[\uDE80-\uDE9C]'
          },
          {
              name: 'Lydian',
              astral: '\uD802[\uDD20-\uDD39\uDD3F]'
          },
          {
              name: 'Mahajani',
              astral: '\uD804[\uDD50-\uDD76]'
          },
          {
              name: 'Malayalam',
              bmp: '\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4F\u0D54-\u0D63\u0D66-\u0D7F'
          },
          {
              name: 'Mandaic',
              bmp: '\u0840-\u085B\u085E'
          },
          {
              name: 'Manichaean',
              astral: '\uD802[\uDEC0-\uDEE6\uDEEB-\uDEF6]'
          },
          {
              name: 'Marchen',
              astral: '\uD807[\uDC70-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]'
          },
          {
              name: 'Meetei_Mayek',
              bmp: '\uAAE0-\uAAF6\uABC0-\uABED\uABF0-\uABF9'
          },
          {
              name: 'Mende_Kikakui',
              astral: '\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6]'
          },
          {
              name: 'Meroitic_Cursive',
              astral: '\uD802[\uDDA0-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDDFF]'
          },
          {
              name: 'Meroitic_Hieroglyphs',
              astral: '\uD802[\uDD80-\uDD9F]'
          },
          {
              name: 'Miao',
              astral: '\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]'
          },
          {
              name: 'Modi',
              astral: '\uD805[\uDE00-\uDE44\uDE50-\uDE59]'
          },
          {
              name: 'Mongolian',
              bmp: '\u1800\u1801\u1804\u1806-\u180E\u1810-\u1819\u1820-\u1877\u1880-\u18AA',
              astral: '\uD805[\uDE60-\uDE6C]'
          },
          {
              name: 'Mro',
              astral: '\uD81A[\uDE40-\uDE5E\uDE60-\uDE69\uDE6E\uDE6F]'
          },
          {
              name: 'Multani',
              astral: '\uD804[\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA9]'
          },
          {
              name: 'Myanmar',
              bmp: '\u1000-\u109F\uA9E0-\uA9FE\uAA60-\uAA7F'
          },
          {
              name: 'Nabataean',
              astral: '\uD802[\uDC80-\uDC9E\uDCA7-\uDCAF]'
          },
          {
              name: 'New_Tai_Lue',
              bmp: '\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE\u19DF'
          },
          {
              name: 'Newa',
              astral: '\uD805[\uDC00-\uDC59\uDC5B\uDC5D]'
          },
          {
              name: 'Nko',
              bmp: '\u07C0-\u07FA'
          },
          {
              name: 'Ogham',
              bmp: '\u1680-\u169C'
          },
          {
              name: 'Ol_Chiki',
              bmp: '\u1C50-\u1C7F'
          },
          {
              name: 'Old_Hungarian',
              astral: '\uD803[\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDCFF]'
          },
          {
              name: 'Old_Italic',
              astral: '\uD800[\uDF00-\uDF23]'
          },
          {
              name: 'Old_North_Arabian',
              astral: '\uD802[\uDE80-\uDE9F]'
          },
          {
              name: 'Old_Permic',
              astral: '\uD800[\uDF50-\uDF7A]'
          },
          {
              name: 'Old_Persian',
              astral: '\uD800[\uDFA0-\uDFC3\uDFC8-\uDFD5]'
          },
          {
              name: 'Old_South_Arabian',
              astral: '\uD802[\uDE60-\uDE7F]'
          },
          {
              name: 'Old_Turkic',
              astral: '\uD803[\uDC00-\uDC48]'
          },
          {
              name: 'Oriya',
              bmp: '\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77'
          },
          {
              name: 'Osage',
              astral: '\uD801[\uDCB0-\uDCD3\uDCD8-\uDCFB]'
          },
          {
              name: 'Osmanya',
              astral: '\uD801[\uDC80-\uDC9D\uDCA0-\uDCA9]'
          },
          {
              name: 'Pahawh_Hmong',
              astral: '\uD81A[\uDF00-\uDF45\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]'
          },
          {
              name: 'Palmyrene',
              astral: '\uD802[\uDC60-\uDC7F]'
          },
          {
              name: 'Pau_Cin_Hau',
              astral: '\uD806[\uDEC0-\uDEF8]'
          },
          {
              name: 'Phags_Pa',
              bmp: '\uA840-\uA877'
          },
          {
              name: 'Phoenician',
              astral: '\uD802[\uDD00-\uDD1B\uDD1F]'
          },
          {
              name: 'Psalter_Pahlavi',
              astral: '\uD802[\uDF80-\uDF91\uDF99-\uDF9C\uDFA9-\uDFAF]'
          },
          {
              name: 'Rejang',
              bmp: '\uA930-\uA953\uA95F'
          },
          {
              name: 'Runic',
              bmp: '\u16A0-\u16EA\u16EE-\u16F8'
          },
          {
              name: 'Samaritan',
              bmp: '\u0800-\u082D\u0830-\u083E'
          },
          {
              name: 'Saurashtra',
              bmp: '\uA880-\uA8C5\uA8CE-\uA8D9'
          },
          {
              name: 'Sharada',
              astral: '\uD804[\uDD80-\uDDCD\uDDD0-\uDDDF]'
          },
          {
              name: 'Shavian',
              astral: '\uD801[\uDC50-\uDC7F]'
          },
          {
              name: 'Siddham',
              astral: '\uD805[\uDD80-\uDDB5\uDDB8-\uDDDD]'
          },
          {
              name: 'SignWriting',
              astral: '\uD836[\uDC00-\uDE8B\uDE9B-\uDE9F\uDEA1-\uDEAF]'
          },
          {
              name: 'Sinhala',
              bmp: '\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4',
              astral: '\uD804[\uDDE1-\uDDF4]'
          },
          {
              name: 'Sora_Sompeng',
              astral: '\uD804[\uDCD0-\uDCE8\uDCF0-\uDCF9]'
          },
          {
              name: 'Sundanese',
              bmp: '\u1B80-\u1BBF\u1CC0-\u1CC7'
          },
          {
              name: 'Syloti_Nagri',
              bmp: '\uA800-\uA82B'
          },
          {
              name: 'Syriac',
              bmp: '\u0700-\u070D\u070F-\u074A\u074D-\u074F'
          },
          {
              name: 'Tagalog',
              bmp: '\u1700-\u170C\u170E-\u1714'
          },
          {
              name: 'Tagbanwa',
              bmp: '\u1760-\u176C\u176E-\u1770\u1772\u1773'
          },
          {
              name: 'Tai_Le',
              bmp: '\u1950-\u196D\u1970-\u1974'
          },
          {
              name: 'Tai_Tham',
              bmp: '\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD'
          },
          {
              name: 'Tai_Viet',
              bmp: '\uAA80-\uAAC2\uAADB-\uAADF'
          },
          {
              name: 'Takri',
              astral: '\uD805[\uDE80-\uDEB7\uDEC0-\uDEC9]'
          },
          {
              name: 'Tamil',
              bmp: '\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA'
          },
          {
              name: 'Tangut',
              astral: '\uD81B\uDFE0|[\uD81C-\uD820][\uDC00-\uDFFF]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]'
          },
          {
              name: 'Telugu',
              bmp: '\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7F'
          },
          {
              name: 'Thaana',
              bmp: '\u0780-\u07B1'
          },
          {
              name: 'Thai',
              bmp: '\u0E01-\u0E3A\u0E40-\u0E5B'
          },
          {
              name: 'Tibetan',
              bmp: '\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FD4\u0FD9\u0FDA'
          },
          {
              name: 'Tifinagh',
              bmp: '\u2D30-\u2D67\u2D6F\u2D70\u2D7F'
          },
          {
              name: 'Tirhuta',
              astral: '\uD805[\uDC80-\uDCC7\uDCD0-\uDCD9]'
          },
          {
              name: 'Ugaritic',
              astral: '\uD800[\uDF80-\uDF9D\uDF9F]'
          },
          {
              name: 'Vai',
              bmp: '\uA500-\uA62B'
          },
          {
              name: 'Warang_Citi',
              astral: '\uD806[\uDCA0-\uDCF2\uDCFF]'
          },
          {
              name: 'Yi',
              bmp: '\uA000-\uA48C\uA490-\uA4C6'
          }
      ]);

  };

  },{}],8:[function(require,module,exports){
  var XRegExp = require('./xregexp');

  require('./addons/build')(XRegExp);
  require('./addons/matchrecursive')(XRegExp);
  require('./addons/unicode-base')(XRegExp);
  require('./addons/unicode-blocks')(XRegExp);
  require('./addons/unicode-categories')(XRegExp);
  require('./addons/unicode-properties')(XRegExp);
  require('./addons/unicode-scripts')(XRegExp);

  module.exports = XRegExp;

  },{"./addons/build":1,"./addons/matchrecursive":2,"./addons/unicode-base":3,"./addons/unicode-blocks":4,"./addons/unicode-categories":5,"./addons/unicode-properties":6,"./addons/unicode-scripts":7,"./xregexp":9}],9:[function(require,module,exports){

  /**
   * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and
   * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to
   * make your client-side grepping simpler and more powerful, while freeing you from related
   * cross-browser inconsistencies.
   */

  // ==--------------------------==
  // Private stuff
  // ==--------------------------==

  // Property name used for extended regex instance data
  var REGEX_DATA = 'xregexp';
  // Optional features that can be installed and uninstalled
  var features = {
      astral: false,
      natives: false
  };
  // Native methods to use and restore ('native' is an ES3 reserved keyword)
  var nativ = {
      exec: RegExp.prototype.exec,
      test: RegExp.prototype.test,
      match: String.prototype.match,
      replace: String.prototype.replace,
      split: String.prototype.split
  };
  // Storage for fixed/extended native methods
  var fixed = {};
  // Storage for regexes cached by `XRegExp.cache`
  var regexCache = {};
  // Storage for pattern details cached by the `XRegExp` constructor
  var patternCache = {};
  // Storage for regex syntax tokens added internally or by `XRegExp.addToken`
  var tokens = [];
  // Token scopes
  var defaultScope = 'default';
  var classScope = 'class';
  // Regexes that match native regex syntax, including octals
  var nativeTokens = {
      // Any native multicharacter token in default scope, or any single character
      'default': /\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|\(\?(?:[:=!]|<[=!])|[?*+]\?|{\d+(?:,\d*)?}\??|[\s\S]/,
      // Any native multicharacter token in character class scope, or any single character
      'class': /\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|[\s\S]/
  };
  // Any backreference or dollar-prefixed character in replacement strings
  var replacementToken = /\$(?:{([\w$]+)}|(\d\d?|[\s\S]))/g;
  // Check for correct `exec` handling of nonparticipating capturing groups
  var correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined;
  // Check for ES6 `flags` prop support
  var hasFlagsProp = /x/.flags !== undefined;
  // Shortcut to `Object.prototype.toString`
  var toString = {}.toString;

  function hasNativeFlag(flag) {
      // Can't check based on the presence of properties/getters since browsers might support such
      // properties even when they don't support the corresponding flag in regex construction (tested
      // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`
      // throws an error)
      var isSupported = true;
      try {
      } catch (exception) {
          isSupported = false;
      }
      return isSupported;
  }
  // Check for ES6 `u` flag support
  var hasNativeU = hasNativeFlag('u');
  // Check for ES6 `y` flag support
  var hasNativeY = hasNativeFlag('y');
  // Tracker for known flags, including addon flags
  var registeredFlags = {
      g: true,
      i: true,
      m: true,
      u: hasNativeU,
      y: hasNativeY
  };

  /**
   * Attaches extended data and `XRegExp.prototype` properties to a regex object.
   *
   * @private
   * @param {RegExp} regex Regex to augment.
   * @param {Array} captureNames Array with capture names, or `null`.
   * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.
   * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.
   * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal
   *   operations, and never exposed to users. For internal-only regexes, we can improve perf by
   *   skipping some operations like attaching `XRegExp.prototype` properties.
   * @returns {RegExp} Augmented regex.
   */
  function augment(regex, captureNames, xSource, xFlags, isInternalOnly) {
      var p;

      regex[REGEX_DATA] = {
          captureNames: captureNames
      };

      if (isInternalOnly) {
          return regex;
      }

      // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value
      if (regex.__proto__) {
          regex.__proto__ = XRegExp.prototype;
      } else {
          for (p in XRegExp.prototype) {
              // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this
              // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`
              // extensions exist on `regex.prototype` anyway
              regex[p] = XRegExp.prototype[p];
          }
      }

      regex[REGEX_DATA].source = xSource;
      // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order
      regex[REGEX_DATA].flags = xFlags ? xFlags.split('').sort().join('') : xFlags;

      return regex;
  }

  /**
   * Removes any duplicate characters from the provided string.
   *
   * @private
   * @param {String} str String to remove duplicate characters from.
   * @returns {String} String with any duplicate characters removed.
   */
  function clipDuplicates(str) {
      return nativ.replace.call(str, /([\s\S])(?=[\s\S]*\1)/g, '');
  }

  /**
   * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`
   * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing
   * flags g and y while copying the regex.
   *
   * @private
   * @param {RegExp} regex Regex to copy.
   * @param {Object} [options] Options object with optional properties:
   *   - `addG` {Boolean} Add flag g while copying the regex.
   *   - `addY` {Boolean} Add flag y while copying the regex.
   *   - `removeG` {Boolean} Remove flag g while copying the regex.
   *   - `removeY` {Boolean} Remove flag y while copying the regex.
   *   - `isInternalOnly` {Boolean} Whether the copied regex will be used only for internal
   *     operations, and never exposed to users. For internal-only regexes, we can improve perf by
   *     skipping some operations like attaching `XRegExp.prototype` properties.
   *   - `source` {String} Overrides `<regex>.source`, for special cases.
   * @returns {RegExp} Copy of the provided regex, possibly with modified flags.
   */
  function copyRegex(regex, options) {
      if (!XRegExp.isRegExp(regex)) {
          throw new TypeError('Type RegExp expected');
      }

      var xData = regex[REGEX_DATA] || {};
      var flags = getNativeFlags(regex);
      var flagsToAdd = '';
      var flagsToRemove = '';
      var xregexpSource = null;
      var xregexpFlags = null;

      options = options || {};

      if (options.removeG) {flagsToRemove += 'g';}
      if (options.removeY) {flagsToRemove += 'y';}
      if (flagsToRemove) {
          flags = nativ.replace.call(flags, new RegExp('[' + flagsToRemove + ']+', 'g'), '');
      }

      if (options.addG) {flagsToAdd += 'g';}
      if (options.addY) {flagsToAdd += 'y';}
      if (flagsToAdd) {
          flags = clipDuplicates(flags + flagsToAdd);
      }

      if (!options.isInternalOnly) {
          if (xData.source !== undefined) {
              xregexpSource = xData.source;
          }
          // null or undefined; don't want to add to `flags` if the previous value was null, since
          // that indicates we're not tracking original precompilation flags
          if (xData.flags != null) {
              // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never
              // removed for non-internal regexes, so don't need to handle it
              xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags;
          }
      }

      // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid
      // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and
      // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the
      // translation to native regex syntax
      regex = augment(
          new RegExp(options.source || regex.source, flags),
          hasNamedCapture(regex) ? xData.captureNames.slice(0) : null,
          xregexpSource,
          xregexpFlags,
          options.isInternalOnly
      );

      return regex;
  }

  /**
   * Converts hexadecimal to decimal.
   *
   * @private
   * @param {String} hex
   * @returns {Number}
   */
  function dec(hex) {
      return parseInt(hex, 16);
  }

  /**
   * Returns a pattern that can be used in a native RegExp in place of an ignorable token such as an
   * inline comment or whitespace with flag x. This is used directly as a token handler function
   * passed to `XRegExp.addToken`.
   *
   * @private
   * @param {String} match Match arg of `XRegExp.addToken` handler
   * @param {String} scope Scope arg of `XRegExp.addToken` handler
   * @param {String} flags Flags arg of `XRegExp.addToken` handler
   * @returns {String} Either '' or '(?:)', depending on which is needed in the context of the match.
   */
  function getContextualTokenSeparator(match, scope, flags) {
      if (
          // No need to separate tokens if at the beginning or end of a group
          match.input.charAt(match.index - 1) === '(' ||
          match.input.charAt(match.index + match[0].length) === ')' ||
          // Avoid separating tokens when the following token is a quantifier
          isPatternNext(match.input, match.index + match[0].length, flags, '[?*+]|{\\d+(?:,\\d*)?}')
      ) {
          return '';
      }
      // Keep tokens separated. This avoids e.g. inadvertedly changing `\1 1` or `\1(?#)1` to `\11`.
      // This also ensures all tokens remain as discrete atoms, e.g. it avoids converting the syntax
      // error `(? :` into `(?:`.
      return '(?:)';
  }

  /**
   * Returns native `RegExp` flags used by a regex object.
   *
   * @private
   * @param {RegExp} regex Regex to check.
   * @returns {String} Native flags in use.
   */
  function getNativeFlags(regex) {
      return hasFlagsProp ?
          regex.flags :
          // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation
          // with an empty string) allows this to continue working predictably when
          // `XRegExp.proptotype.toString` is overridden
          nativ.exec.call(/\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];
  }

  /**
   * Determines whether a regex has extended instance data used to track capture names.
   *
   * @private
   * @param {RegExp} regex Regex to check.
   * @returns {Boolean} Whether the regex uses named capture.
   */
  function hasNamedCapture(regex) {
      return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);
  }

  /**
   * Converts decimal to hexadecimal.
   *
   * @private
   * @param {Number|String} dec
   * @returns {String}
   */
  function hex(dec) {
      return parseInt(dec, 10).toString(16);
  }

  /**
   * Returns the first index at which a given value can be found in an array.
   *
   * @private
   * @param {Array} array Array to search.
   * @param {*} value Value to locate in the array.
   * @returns {Number} Zero-based index at which the item is found, or -1.
   */
  function indexOf(array, value) {
      var len = array.length;
      var i;

      for (i = 0; i < len; ++i) {
          if (array[i] === value) {
              return i;
          }
      }

      return -1;
  }

  /**
   * Checks whether the next nonignorable token after the specified position matches the
   * `needlePattern`
   *
   * @private
   * @param {String} pattern Pattern to search within.
   * @param {Number} pos Index in `pattern` to search at.
   * @param {String} flags Flags used by the pattern.
   * @param {String} needlePattern Pattern to match the next token against.
   * @returns {Boolean} Whether the next nonignorable token matches `needlePattern`
   */
  function isPatternNext(pattern, pos, flags, needlePattern) {
      var inlineCommentPattern = '\\(\\?#[^)]*\\)';
      var lineCommentPattern = '#[^#\\n]*';
      var patternsToIgnore = flags.indexOf('x') > -1 ?
          // Ignore any leading whitespace, line comments, and inline comments
          ['\\s', lineCommentPattern, inlineCommentPattern] :
          // Ignore any leading inline comments
          [inlineCommentPattern];
      return nativ.test.call(
          new RegExp('^(?:' + patternsToIgnore.join('|') + ')*(?:' + needlePattern + ')'),
          pattern.slice(pos)
      );
  }

  /**
   * Determines whether a value is of the specified type, by resolving its internal [[Class]].
   *
   * @private
   * @param {*} value Object to check.
   * @param {String} type Type to check for, in TitleCase.
   * @returns {Boolean} Whether the object matches the type.
   */
  function isType(value, type) {
      return toString.call(value) === '[object ' + type + ']';
  }

  /**
   * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.
   *
   * @private
   * @param {String} str
   * @returns {String}
   */
  function pad4(str) {
      while (str.length < 4) {
          str = '0' + str;
      }
      return str;
  }

  /**
   * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads
   * the flag preparation logic from the `XRegExp` constructor.
   *
   * @private
   * @param {String} pattern Regex pattern, possibly with a leading mode modifier.
   * @param {String} flags Any combination of flags.
   * @returns {Object} Object with properties `pattern` and `flags`.
   */
  function prepareFlags(pattern, flags) {
      var i;

      // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags
      if (clipDuplicates(flags) !== flags) {
          throw new SyntaxError('Invalid duplicate regex flag ' + flags);
      }

      // Strip and apply a leading mode modifier with any combination of flags except g or y
      pattern = nativ.replace.call(pattern, /^\(\?([\w$]+)\)/, function($0, $1) {
          if (nativ.test.call(/[gy]/, $1)) {
              throw new SyntaxError('Cannot use flag g or y in mode modifier ' + $0);
          }
          // Allow duplicate flags within the mode modifier
          flags = clipDuplicates(flags + $1);
          return '';
      });

      // Throw on unknown native or nonnative flags
      for (i = 0; i < flags.length; ++i) {
          if (!registeredFlags[flags.charAt(i)]) {
              throw new SyntaxError('Unknown regex flag ' + flags.charAt(i));
          }
      }

      return {
          pattern: pattern,
          flags: flags
      };
  }

  /**
   * Prepares an options object from the given value.
   *
   * @private
   * @param {String|Object} value Value to convert to an options object.
   * @returns {Object} Options object.
   */
  function prepareOptions(value) {
      var options = {};

      if (isType(value, 'String')) {
          XRegExp.forEach(value, /[^\s,]+/, function(match) {
              options[match] = true;
          });

          return options;
      }

      return value;
  }

  /**
   * Registers a flag so it doesn't throw an 'unknown flag' error.
   *
   * @private
   * @param {String} flag Single-character flag to register.
   */
  function registerFlag(flag) {
      if (!/^[\w$]$/.test(flag)) {
          throw new Error('Flag must be a single character A-Za-z0-9_$');
      }

      registeredFlags[flag] = true;
  }

  /**
   * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified
   * position, until a match is found.
   *
   * @private
   * @param {String} pattern Original pattern from which an XRegExp object is being built.
   * @param {String} flags Flags being used to construct the regex.
   * @param {Number} pos Position to search for tokens within `pattern`.
   * @param {Number} scope Regex scope to apply: 'default' or 'class'.
   * @param {Object} context Context object to use for token handler functions.
   * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.
   */
  function runTokens(pattern, flags, pos, scope, context) {
      var i = tokens.length;
      var leadChar = pattern.charAt(pos);
      var result = null;
      var match;
      var t;

      // Run in reverse insertion order
      while (i--) {
          t = tokens[i];
          if (
              (t.leadChar && t.leadChar !== leadChar) ||
              (t.scope !== scope && t.scope !== 'all') ||
              (t.flag && flags.indexOf(t.flag) === -1)
          ) {
              continue;
          }

          match = XRegExp.exec(pattern, t.regex, pos, 'sticky');
          if (match) {
              result = {
                  matchLength: match[0].length,
                  output: t.handler.call(context, match, scope, flags),
                  reparse: t.reparse
              };
              // Finished with token tests
              break;
          }
      }

      return result;
  }

  /**
   * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to
   * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if
   * the Unicode Base addon is not available, since flag A is registered by that addon.
   *
   * @private
   * @param {Boolean} on `true` to enable; `false` to disable.
   */
  function setAstral(on) {
      features.astral = on;
  }

  /**
   * Enables or disables native method overrides.
   *
   * @private
   * @param {Boolean} on `true` to enable; `false` to disable.
   */
  function setNatives(on) {
      RegExp.prototype.exec = (on ? fixed : nativ).exec;
      RegExp.prototype.test = (on ? fixed : nativ).test;
      String.prototype.match = (on ? fixed : nativ).match;
      String.prototype.replace = (on ? fixed : nativ).replace;
      String.prototype.split = (on ? fixed : nativ).split;

      features.natives = on;
  }

  /**
   * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow
   * the ES5 abstract operation `ToObject`.
   *
   * @private
   * @param {*} value Object to check and return.
   * @returns {*} The provided object.
   */
  function toObject(value) {
      // null or undefined
      if (value == null) {
          throw new TypeError('Cannot convert null or undefined to object');
      }

      return value;
  }

  // ==--------------------------==
  // Constructor
  // ==--------------------------==

  /**
   * Creates an extended regular expression object for matching text with a pattern. Differs from a
   * native regular expression in that additional syntax and flags are supported. The returned object
   * is in fact a native `RegExp` and works with all native methods.
   *
   * @class XRegExp
   * @constructor
   * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.
   * @param {String} [flags] Any combination of flags.
   *   Native flags:
   *     - `g` - global
   *     - `i` - ignore case
   *     - `m` - multiline anchors
   *     - `u` - unicode (ES6)
   *     - `y` - sticky (Firefox 3+, ES6)
   *   Additional XRegExp flags:
   *     - `n` - explicit capture
   *     - `s` - dot matches all (aka singleline)
   *     - `x` - free-spacing and line comments (aka extended)
   *     - `A` - astral (requires the Unicode Base addon)
   *   Flags cannot be provided when constructing one `RegExp` from another.
   * @returns {RegExp} Extended regular expression object.
   * @example
   *
   * // With named capture and flag x
   * XRegExp('(?<year>  [0-9]{4} ) -?  # year  \n\
   *          (?<month> [0-9]{2} ) -?  # month \n\
   *          (?<day>   [0-9]{2} )     # day   ', 'x');
   *
   * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)
   * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and
   * // have fresh `lastIndex` properties (set to zero).
   * XRegExp(/regex/);
   */
  function XRegExp(pattern, flags) {
      if (XRegExp.isRegExp(pattern)) {
          if (flags !== undefined) {
              throw new TypeError('Cannot supply flags when copying a RegExp');
          }
          return copyRegex(pattern);
      }

      // Copy the argument behavior of `RegExp`
      pattern = pattern === undefined ? '' : String(pattern);
      flags = flags === undefined ? '' : String(flags);

      if (XRegExp.isInstalled('astral') && flags.indexOf('A') === -1) {
          // This causes an error to be thrown if the Unicode Base addon is not available
          flags += 'A';
      }

      if (!patternCache[pattern]) {
          patternCache[pattern] = {};
      }

      if (!patternCache[pattern][flags]) {
          var context = {
              hasNamedCapture: false,
              captureNames: []
          };
          var scope = defaultScope;
          var output = '';
          var pos = 0;
          var result;

          // Check for flag-related errors, and strip/apply flags in a leading mode modifier
          var applied = prepareFlags(pattern, flags);
          var appliedPattern = applied.pattern;
          var appliedFlags = applied.flags;

          // Use XRegExp's tokens to translate the pattern to a native regex pattern.
          // `appliedPattern.length` may change on each iteration if tokens use `reparse`
          while (pos < appliedPattern.length) {
              do {
                  // Check for custom tokens at the current position
                  result = runTokens(appliedPattern, appliedFlags, pos, scope, context);
                  // If the matched token used the `reparse` option, splice its output into the
                  // pattern before running tokens again at the same position
                  if (result && result.reparse) {
                      appliedPattern = appliedPattern.slice(0, pos) +
                          result.output +
                          appliedPattern.slice(pos + result.matchLength);
                  }
              } while (result && result.reparse);

              if (result) {
                  output += result.output;
                  pos += (result.matchLength || 1);
              } else {
                  // Get the native token at the current position
                  var token = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky')[0];
                  output += token;
                  pos += token.length;
                  if (token === '[' && scope === defaultScope) {
                      scope = classScope;
                  } else if (token === ']' && scope === classScope) {
                      scope = defaultScope;
                  }
              }
          }

          patternCache[pattern][flags] = {
              // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty
              // groups are sometimes inserted during regex transpilation in order to keep tokens
              // separated. However, more than one empty group in a row is never needed.
              pattern: nativ.replace.call(output, /(?:\(\?:\))+/g, '(?:)'),
              // Strip all but native flags
              flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),
              // `context.captureNames` has an item for each capturing group, even if unnamed
              captures: context.hasNamedCapture ? context.captureNames : null
          };
      }

      var generated = patternCache[pattern][flags];
      return augment(
          new RegExp(generated.pattern, generated.flags),
          generated.captures,
          pattern,
          flags
      );
  }

  // Add `RegExp.prototype` to the prototype chain
  XRegExp.prototype = new RegExp();

  // ==--------------------------==
  // Public properties
  // ==--------------------------==

  /**
   * The XRegExp version number as a string containing three dot-separated parts. For example,
   * '2.0.0-beta-3'.
   *
   * @static
   * @memberOf XRegExp
   * @type String
   */
  XRegExp.version = '3.2.0';

  // ==--------------------------==
  // Public methods
  // ==--------------------------==

  // Intentionally undocumented; used in tests and addons
  XRegExp._clipDuplicates = clipDuplicates;
  XRegExp._hasNativeFlag = hasNativeFlag;
  XRegExp._dec = dec;
  XRegExp._hex = hex;
  XRegExp._pad4 = pad4;

  /**
   * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to
   * create XRegExp addons. If more than one token can match the same string, the last added wins.
   *
   * @memberOf XRegExp
   * @param {RegExp} regex Regex object that matches the new token.
   * @param {Function} handler Function that returns a new pattern string (using native regex syntax)
   *   to replace the matched token within all future XRegExp regexes. Has access to persistent
   *   properties of the regex being built, through `this`. Invoked with three arguments:
   *   - The match array, with named backreference properties.
   *   - The regex scope where the match was found: 'default' or 'class'.
   *   - The flags used by the regex, including any flags in a leading mode modifier.
   *   The handler function becomes part of the XRegExp construction process, so be careful not to
   *   construct XRegExps within the function or you will trigger infinite recursion.
   * @param {Object} [options] Options object with optional properties:
   *   - `scope` {String} Scope where the token applies: 'default', 'class', or 'all'.
   *   - `flag` {String} Single-character flag that triggers the token. This also registers the
   *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.
   *   - `optionalFlags` {String} Any custom flags checked for within the token `handler` that are
   *     not required to trigger the token. This registers the flags, to prevent XRegExp from
   *     throwing an 'unknown flag' error when any of the flags are used.
   *   - `reparse` {Boolean} Whether the `handler` function's output should not be treated as
   *     final, and instead be reparseable by other tokens (including the current token). Allows
   *     token chaining or deferring.
   *   - `leadChar` {String} Single character that occurs at the beginning of any successful match
   *     of the token (not always applicable). This doesn't change the behavior of the token unless
   *     you provide an erroneous value. However, providing it can increase the token's performance
   *     since the token can be skipped at any positions where this character doesn't appear.
   * @example
   *
   * // Basic usage: Add \a for the ALERT control code
   * XRegExp.addToken(
   *   /\\a/,
   *   function() {return '\\x07';},
   *   {scope: 'all'}
   * );
   * XRegExp('\\a[\\a-\\n]+').test('\x07\n\x07'); // -> true
   *
   * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.
   * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of
   * // character classes only)
   * XRegExp.addToken(
   *   /([?*+]|{\d+(?:,\d*)?})(\??)/,
   *   function(match) {return match[1] + (match[2] ? '' : '?');},
   *   {flag: 'U'}
   * );
   * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'
   * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'
   */
  XRegExp.addToken = function(regex, handler, options) {
      options = options || {};
      var optionalFlags = options.optionalFlags;
      var i;

      if (options.flag) {
          registerFlag(options.flag);
      }

      if (optionalFlags) {
          optionalFlags = nativ.split.call(optionalFlags, '');
          for (i = 0; i < optionalFlags.length; ++i) {
              registerFlag(optionalFlags[i]);
          }
      }

      // Add to the private list of syntax tokens
      tokens.push({
          regex: copyRegex(regex, {
              addG: true,
              addY: hasNativeY,
              isInternalOnly: true
          }),
          handler: handler,
          scope: options.scope || defaultScope,
          flag: options.flag,
          reparse: options.reparse,
          leadChar: options.leadChar
      });

      // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags
      // might now produce different results
      XRegExp.cache.flush('patterns');
  };

  /**
   * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with
   * the same pattern and flag combination, the cached copy of the regex is returned.
   *
   * @memberOf XRegExp
   * @param {String} pattern Regex pattern string.
   * @param {String} [flags] Any combination of XRegExp flags.
   * @returns {RegExp} Cached XRegExp object.
   * @example
   *
   * while (match = XRegExp.cache('.', 'gs').exec(str)) {
   *   // The regex is compiled once only
   * }
   */
  XRegExp.cache = function(pattern, flags) {
      if (!regexCache[pattern]) {
          regexCache[pattern] = {};
      }
      return regexCache[pattern][flags] || (
          regexCache[pattern][flags] = XRegExp(pattern, flags)
      );
  };

  // Intentionally undocumented; used in tests
  XRegExp.cache.flush = function(cacheName) {
      if (cacheName === 'patterns') {
          // Flush the pattern cache used by the `XRegExp` constructor
          patternCache = {};
      } else {
          // Flush the regex cache populated by `XRegExp.cache`
          regexCache = {};
      }
  };

  /**
   * Escapes any regular expression metacharacters, for use when matching literal strings. The result
   * can safely be used at any point within a regex that uses any flags.
   *
   * @memberOf XRegExp
   * @param {String} str String to escape.
   * @returns {String} String with regex metacharacters escaped.
   * @example
   *
   * XRegExp.escape('Escaped? <.>');
   * // -> 'Escaped\?\ <\.>'
   */
  XRegExp.escape = function(str) {
      return nativ.replace.call(toObject(str), /[-\[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
  };

  /**
   * Executes a regex search in a specified string. Returns a match array or `null`. If the provided
   * regex uses named capture, named backreference properties are included on the match array.
   * Optional `pos` and `sticky` arguments specify the search start position, and whether the match
   * must start at the specified position only. The `lastIndex` property of the provided regex is not
   * used, but is updated for compatibility. Also fixes browser bugs compared to the native
   * `RegExp.prototype.exec` and can be used reliably cross-browser.
   *
   * @memberOf XRegExp
   * @param {String} str String to search.
   * @param {RegExp} regex Regex to search with.
   * @param {Number} [pos=0] Zero-based index at which to start the search.
   * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
   *   only. The string `'sticky'` is accepted as an alternative to `true`.
   * @returns {Array} Match array with named backreference properties, or `null`.
   * @example
   *
   * // Basic use, with named backreference
   * var match = XRegExp.exec('U+2620', XRegExp('U\\+(?<hex>[0-9A-F]{4})'));
   * match.hex; // -> '2620'
   *
   * // With pos and sticky, in a loop
   * var pos = 2, result = [], match;
   * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\d)>/, pos, 'sticky')) {
   *   result.push(match[1]);
   *   pos = match.index + match[0].length;
   * }
   * // result -> ['2', '3', '4']
   */
  XRegExp.exec = function(str, regex, pos, sticky) {
      var cacheKey = 'g';
      var addY = false;
      var fakeY = false;
      var match;
      var r2;

      addY = hasNativeY && !!(sticky || (regex.sticky && sticky !== false));
      if (addY) {
          cacheKey += 'y';
      } else if (sticky) {
          // Simulate sticky matching by appending an empty capture to the original regex. The
          // resulting regex will succeed no matter what at the current index (set with `lastIndex`),
          // and will not search the rest of the subject string. We'll know that the original regex
          // has failed if that last capture is `''` rather than `undefined` (i.e., if that last
          // capture participated in the match).
          fakeY = true;
          cacheKey += 'FakeY';
      }

      regex[REGEX_DATA] = regex[REGEX_DATA] || {};

      // Shares cached copies with `XRegExp.match`/`replace`
      r2 = regex[REGEX_DATA][cacheKey] || (
          regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
              addG: true,
              addY: addY,
              source: fakeY ? regex.source + '|()' : undefined,
              removeY: sticky === false,
              isInternalOnly: true
          })
      );

      pos = pos || 0;
      r2.lastIndex = pos;

      // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.
      match = fixed.exec.call(r2, str);

      // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means
      // the original regexp failed (see above).
      if (fakeY && match && match.pop() === '') {
          match = null;
      }

      if (regex.global) {
          regex.lastIndex = match ? r2.lastIndex : 0;
      }

      return match;
  };

  /**
   * Executes a provided function once per regex match. Searches always start at the beginning of the
   * string and continue until the end, regardless of the state of the regex's `global` property and
   * initial `lastIndex`.
   *
   * @memberOf XRegExp
   * @param {String} str String to search.
   * @param {RegExp} regex Regex to search with.
   * @param {Function} callback Function to execute for each match. Invoked with four arguments:
   *   - The match array, with named backreference properties.
   *   - The zero-based match index.
   *   - The string being traversed.
   *   - The regex object being used to traverse the string.
   * @example
   *
   * // Extracts every other digit from a string
   * var evens = [];
   * XRegExp.forEach('1a2345', /\d/, function(match, i) {
   *   if (i % 2) evens.push(+match[0]);
   * });
   * // evens -> [2, 4]
   */
  XRegExp.forEach = function(str, regex, callback) {
      var pos = 0;
      var i = -1;
      var match;

      while ((match = XRegExp.exec(str, regex, pos))) {
          // Because `regex` is provided to `callback`, the function could use the deprecated/
          // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`
          // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,
          // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of
          // regexes, mutating the regex will not have any effect on the iteration or matched strings,
          // which is a nice side effect that brings extra safety.
          callback(match, ++i, str, regex);

          pos = match.index + (match[0].length || 1);
      }
  };

  /**
   * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with
   * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native
   * regexes are not recompiled using XRegExp syntax.
   *
   * @memberOf XRegExp
   * @param {RegExp} regex Regex to globalize.
   * @returns {RegExp} Copy of the provided regex with flag `g` added.
   * @example
   *
   * var globalCopy = XRegExp.globalize(/regex/);
   * globalCopy.global; // -> true
   */
  XRegExp.globalize = function(regex) {
      return copyRegex(regex, {addG: true});
  };

  /**
   * Installs optional features according to the specified options. Can be undone using
   * `XRegExp.uninstall`.
   *
   * @memberOf XRegExp
   * @param {Object|String} options Options object or string.
   * @example
   *
   * // With an options object
   * XRegExp.install({
   *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)
   *   astral: true,
   *
   *   // DEPRECATED: Overrides native regex methods with fixed/extended versions
   *   natives: true
   * });
   *
   * // With an options string
   * XRegExp.install('astral natives');
   */
  XRegExp.install = function(options) {
      options = prepareOptions(options);

      if (!features.astral && options.astral) {
          setAstral(true);
      }

      if (!features.natives && options.natives) {
          setNatives(true);
      }
  };

  /**
   * Checks whether an individual optional feature is installed.
   *
   * @memberOf XRegExp
   * @param {String} feature Name of the feature to check. One of:
   *   - `astral`
   *   - `natives`
   * @returns {Boolean} Whether the feature is installed.
   * @example
   *
   * XRegExp.isInstalled('astral');
   */
  XRegExp.isInstalled = function(feature) {
      return !!(features[feature]);
  };

  /**
   * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes
   * created in another frame, when `instanceof` and `constructor` checks would fail.
   *
   * @memberOf XRegExp
   * @param {*} value Object to check.
   * @returns {Boolean} Whether the object is a `RegExp` object.
   * @example
   *
   * XRegExp.isRegExp('string'); // -> false
   * XRegExp.isRegExp(/regex/i); // -> true
   * XRegExp.isRegExp(RegExp('^', 'm')); // -> true
   * XRegExp.isRegExp(XRegExp('(?s).')); // -> true
   */
  XRegExp.isRegExp = function(value) {
      return toString.call(value) === '[object RegExp]';
      //return isType(value, 'RegExp');
  };

  /**
   * Returns the first matched string, or in global mode, an array containing all matched strings.
   * This is essentially a more convenient re-implementation of `String.prototype.match` that gives
   * the result types you actually want (string instead of `exec`-style array in match-first mode,
   * and an empty array instead of `null` when no matches are found in match-all mode). It also lets
   * you override flag g and ignore `lastIndex`, and fixes browser bugs.
   *
   * @memberOf XRegExp
   * @param {String} str String to search.
   * @param {RegExp} regex Regex to search with.
   * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to
   *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,
   *   `scope` is 'all'.
   * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all
   *   mode: Array of all matched strings, or an empty array.
   * @example
   *
   * // Match first
   * XRegExp.match('abc', /\w/); // -> 'a'
   * XRegExp.match('abc', /\w/g, 'one'); // -> 'a'
   * XRegExp.match('abc', /x/g, 'one'); // -> null
   *
   * // Match all
   * XRegExp.match('abc', /\w/g); // -> ['a', 'b', 'c']
   * XRegExp.match('abc', /\w/, 'all'); // -> ['a', 'b', 'c']
   * XRegExp.match('abc', /x/, 'all'); // -> []
   */
  XRegExp.match = function(str, regex, scope) {
      var global = (regex.global && scope !== 'one') || scope === 'all';
      var cacheKey = ((global ? 'g' : '') + (regex.sticky ? 'y' : '')) || 'noGY';
      var result;
      var r2;

      regex[REGEX_DATA] = regex[REGEX_DATA] || {};

      // Shares cached copies with `XRegExp.exec`/`replace`
      r2 = regex[REGEX_DATA][cacheKey] || (
          regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
              addG: !!global,
              removeG: scope === 'one',
              isInternalOnly: true
          })
      );

      result = nativ.match.call(toObject(str), r2);

      if (regex.global) {
          regex.lastIndex = (
              (scope === 'one' && result) ?
                  // Can't use `r2.lastIndex` since `r2` is nonglobal in this case
                  (result.index + result[0].length) : 0
          );
      }

      return global ? (result || []) : (result && result[0]);
  };

  /**
   * Retrieves the matches from searching a string using a chain of regexes that successively search
   * within previous matches. The provided `chain` array can contain regexes and or objects with
   * `regex` and `backref` properties. When a backreference is specified, the named or numbered
   * backreference is passed forward to the next regex or returned.
   *
   * @memberOf XRegExp
   * @param {String} str String to search.
   * @param {Array} chain Regexes that each search for matches within preceding results.
   * @returns {Array} Matches by the last regex in the chain, or an empty array.
   * @example
   *
   * // Basic usage; matches numbers within <b> tags
   * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [
   *   XRegExp('(?is)<b>.*?</b>'),
   *   /\d+/
   * ]);
   * // -> ['2', '4', '56']
   *
   * // Passing forward and returning specific backreferences
   * html = '<a href="http://xregexp.com/api/">XRegExp</a>\
   *         <a href="http://www.google.com/">Google</a>';
   * XRegExp.matchChain(html, [
   *   {regex: /<a href="([^"]+)">/i, backref: 1},
   *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}
   * ]);
   * // -> ['xregexp.com', 'www.google.com']
   */
  XRegExp.matchChain = function(str, chain) {
      return (function recurseChain(values, level) {
          var item = chain[level].regex ? chain[level] : {regex: chain[level]};
          var matches = [];

          function addMatch(match) {
              if (item.backref) {
                  // Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold the
                  // `undefined`s for backreferences to nonparticipating capturing groups. In such
                  // cases, a `hasOwnProperty` or `in` check on its own would inappropriately throw
                  // the exception, so also check if the backreference is a number that is within the
                  // bounds of the array.
                  if (!(match.hasOwnProperty(item.backref) || +item.backref < match.length)) {
                      throw new ReferenceError('Backreference to undefined group: ' + item.backref);
                  }

                  matches.push(match[item.backref] || '');
              } else {
                  matches.push(match[0]);
              }
          }

          for (var i = 0; i < values.length; ++i) {
              XRegExp.forEach(values[i], item.regex, addMatch);
          }

          return ((level === chain.length - 1) || !matches.length) ?
              matches :
              recurseChain(matches, level + 1);
      }([str], 0));
  };

  /**
   * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string
   * or regex, and the replacement can be a string or a function to be called for each match. To
   * perform a global search and replace, use the optional `scope` argument or include flag g if using
   * a regex. Replacement strings can use `${n}` for named and numbered backreferences. Replacement
   * functions can use named backreferences via `arguments[0].name`. Also fixes browser bugs compared
   * to the native `String.prototype.replace` and can be used reliably cross-browser.
   *
   * @memberOf XRegExp
   * @param {String} str String to search.
   * @param {RegExp|String} search Search pattern to be replaced.
   * @param {String|Function} replacement Replacement string or a function invoked to create it.
   *   Replacement strings can include special replacement syntax:
   *     - $$ - Inserts a literal $ character.
   *     - $&, $0 - Inserts the matched substring.
   *     - $` - Inserts the string that precedes the matched substring (left context).
   *     - $' - Inserts the string that follows the matched substring (right context).
   *     - $n, $nn - Where n/nn are digits referencing an existent capturing group, inserts
   *       backreference n/nn.
   *     - ${n} - Where n is a name or any number of digits that reference an existent capturing
   *       group, inserts backreference n.
   *   Replacement functions are invoked with three or more arguments:
   *     - The matched substring (corresponds to $& above). Named backreferences are accessible as
   *       properties of this first argument.
   *     - 0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).
   *     - The zero-based index of the match within the total search string.
   *     - The total string being searched.
   * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not
   *   explicitly specified and using a regex with flag g, `scope` is 'all'.
   * @returns {String} New string with one or all matches replaced.
   * @example
   *
   * // Regex search, using named backreferences in replacement string
   * var name = XRegExp('(?<first>\\w+) (?<last>\\w+)');
   * XRegExp.replace('John Smith', name, '${last}, ${first}');
   * // -> 'Smith, John'
   *
   * // Regex search, using named backreferences in replacement function
   * XRegExp.replace('John Smith', name, function(match) {
   *   return match.last + ', ' + match.first;
   * });
   * // -> 'Smith, John'
   *
   * // String search, with replace-all
   * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');
   * // -> 'XRegExp builds XRegExps'
   */
  XRegExp.replace = function(str, search, replacement, scope) {
      var isRegex = XRegExp.isRegExp(search);
      var global = (search.global && scope !== 'one') || scope === 'all';
      var cacheKey = ((global ? 'g' : '') + (search.sticky ? 'y' : '')) || 'noGY';
      var s2 = search;
      var result;

      if (isRegex) {
          search[REGEX_DATA] = search[REGEX_DATA] || {};

          // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s
          // `lastIndex` isn't updated *during* replacement iterations
          s2 = search[REGEX_DATA][cacheKey] || (
              search[REGEX_DATA][cacheKey] = copyRegex(search, {
                  addG: !!global,
                  removeG: scope === 'one',
                  isInternalOnly: true
              })
          );
      } else if (global) {
          s2 = new RegExp(XRegExp.escape(String(search)), 'g');
      }

      // Fixed `replace` required for named backreferences, etc.
      result = fixed.replace.call(toObject(str), s2, replacement);

      if (isRegex && search.global) {
          // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
          search.lastIndex = 0;
      }

      return result;
  };

  /**
   * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an
   * array of replacement details. Later replacements operate on the output of earlier replacements.
   * Replacement details are accepted as an array with a regex or string to search for, the
   * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp
   * replacement text syntax, which supports named backreference properties via `${name}`.
   *
   * @memberOf XRegExp
   * @param {String} str String to search.
   * @param {Array} replacements Array of replacement detail arrays.
   * @returns {String} New string with all replacements.
   * @example
   *
   * str = XRegExp.replaceEach(str, [
   *   [XRegExp('(?<name>a)'), 'z${name}'],
   *   [/b/gi, 'y'],
   *   [/c/g, 'x', 'one'], // scope 'one' overrides /g
   *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g
   *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings
   *   [/f/g, function($0) {
   *     return $0.toUpperCase();
   *   }]
   * ]);
   */
  XRegExp.replaceEach = function(str, replacements) {
      var i;
      var r;

      for (i = 0; i < replacements.length; ++i) {
          r = replacements[i];
          str = XRegExp.replace(str, r[0], r[1], r[2]);
      }

      return str;
  };

  /**
   * Splits a string into an array of strings using a regex or string separator. Matches of the
   * separator are not included in the result array. However, if `separator` is a regex that contains
   * capturing groups, backreferences are spliced into the result each time `separator` is matched.
   * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
   * cross-browser.
   *
   * @memberOf XRegExp
   * @param {String} str String to split.
   * @param {RegExp|String} separator Regex or string to use for separating the string.
   * @param {Number} [limit] Maximum number of items to include in the result array.
   * @returns {Array} Array of substrings.
   * @example
   *
   * // Basic use
   * XRegExp.split('a b c', ' ');
   * // -> ['a', 'b', 'c']
   *
   * // With limit
   * XRegExp.split('a b c', ' ', 2);
   * // -> ['a', 'b']
   *
   * // Backreferences in result array
   * XRegExp.split('..word1..', /([a-z]+)(\d+)/i);
   * // -> ['..', 'word', '1', '..']
   */
  XRegExp.split = function(str, separator, limit) {
      return fixed.split.call(toObject(str), separator, limit);
  };

  /**
   * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and
   * `sticky` arguments specify the search start position, and whether the match must start at the
   * specified position only. The `lastIndex` property of the provided regex is not used, but is
   * updated for compatibility. Also fixes browser bugs compared to the native
   * `RegExp.prototype.test` and can be used reliably cross-browser.
   *
   * @memberOf XRegExp
   * @param {String} str String to search.
   * @param {RegExp} regex Regex to search with.
   * @param {Number} [pos=0] Zero-based index at which to start the search.
   * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
   *   only. The string `'sticky'` is accepted as an alternative to `true`.
   * @returns {Boolean} Whether the regex matched the provided value.
   * @example
   *
   * // Basic use
   * XRegExp.test('abc', /c/); // -> true
   *
   * // With pos and sticky
   * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false
   * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true
   */
  XRegExp.test = function(str, regex, pos, sticky) {
      // Do this the easy way :-)
      return !!XRegExp.exec(str, regex, pos, sticky);
  };

  /**
   * Uninstalls optional features according to the specified options. All optional features start out
   * uninstalled, so this is used to undo the actions of `XRegExp.install`.
   *
   * @memberOf XRegExp
   * @param {Object|String} options Options object or string.
   * @example
   *
   * // With an options object
   * XRegExp.uninstall({
   *   // Disables support for astral code points in Unicode addons
   *   astral: true,
   *
   *   // DEPRECATED: Restores native regex methods
   *   natives: true
   * });
   *
   * // With an options string
   * XRegExp.uninstall('astral natives');
   */
  XRegExp.uninstall = function(options) {
      options = prepareOptions(options);

      if (features.astral && options.astral) {
          setAstral(false);
      }

      if (features.natives && options.natives) {
          setNatives(false);
      }
  };

  /**
   * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as
   * regex objects or strings. Metacharacters are escaped in patterns provided as strings.
   * Backreferences in provided regex objects are automatically renumbered to work correctly within
   * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the
   * `flags` argument.
   *
   * @memberOf XRegExp
   * @param {Array} patterns Regexes and strings to combine.
   * @param {String} [flags] Any combination of XRegExp flags.
   * @param {Object} [options] Options object with optional properties:
   *   - `conjunction` {String} Type of conjunction to use: 'or' (default) or 'none'.
   * @returns {RegExp} Union of the provided regexes and strings.
   * @example
   *
   * XRegExp.union(['a+b*c', /(dogs)\1/, /(cats)\1/], 'i');
   * // -> /a\+b\*c|(dogs)\1|(cats)\2/i
   *
   * XRegExp.union([/man/, /bear/, /pig/], 'i', {conjunction: 'none'});
   * // -> /manbearpig/i
   */
  XRegExp.union = function(patterns, flags, options) {
      options = options || {};
      var conjunction = options.conjunction || 'or';
      var numCaptures = 0;
      var numPriorCaptures;
      var captureNames;

      function rewrite(match, paren, backref) {
          var name = captureNames[numCaptures - numPriorCaptures];

          // Capturing group
          if (paren) {
              ++numCaptures;
              // If the current capture has a name, preserve the name
              if (name) {
                  return '(?<' + name + '>';
              }
          // Backreference
          } else if (backref) {
              // Rewrite the backreference
              return '\\' + (+backref + numPriorCaptures);
          }

          return match;
      }

      if (!(isType(patterns, 'Array') && patterns.length)) {
          throw new TypeError('Must provide a nonempty array of patterns to merge');
      }

      var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
      var output = [];
      var pattern;
      for (var i = 0; i < patterns.length; ++i) {
          pattern = patterns[i];

          if (XRegExp.isRegExp(pattern)) {
              numPriorCaptures = numCaptures;
              captureNames = (pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames) || [];

              // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are
              // independently valid; helps keep this simple. Named captures are put back
              output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));
          } else {
              output.push(XRegExp.escape(pattern));
          }
      }

      var separator = conjunction === 'none' ? '' : '|';
      return XRegExp(output.join(separator), flags);
  };

  // ==--------------------------==
  // Fixed/extended native methods
  // ==--------------------------==

  /**
   * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
   * bugs in the native `RegExp.prototype.exec`. Calling `XRegExp.install('natives')` uses this to
   * override the native method. Use via `XRegExp.exec` without overriding natives.
   *
   * @memberOf RegExp
   * @param {String} str String to search.
   * @returns {Array} Match array with named backreference properties, or `null`.
   */
  fixed.exec = function(str) {
      var origLastIndex = this.lastIndex;
      var match = nativ.exec.apply(this, arguments);
      var name;
      var r2;
      var i;

      if (match) {
          // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing
          // groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9
          // in standards mode follows the spec.
          if (!correctExecNpcg && match.length > 1 && indexOf(match, '') > -1) {
              r2 = copyRegex(this, {
                  removeG: true,
                  isInternalOnly: true
              });
              // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed
              // matching due to characters outside the match
              nativ.replace.call(String(str).slice(match.index), r2, function() {
                  var len = arguments.length;
                  var i;
                  // Skip index 0 and the last 2
                  for (i = 1; i < len - 2; ++i) {
                      if (arguments[i] === undefined) {
                          match[i] = undefined;
                      }
                  }
              });
          }

          // Attach named capture properties
          if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {
              // Skip index 0
              for (i = 1; i < match.length; ++i) {
                  name = this[REGEX_DATA].captureNames[i - 1];
                  if (name) {
                      match[name] = match[i];
                  }
              }
          }

          // Fix browsers that increment `lastIndex` after zero-length matches
          if (this.global && !match[0].length && (this.lastIndex > match.index)) {
              this.lastIndex = match.index;
          }
      }

      if (!this.global) {
          // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
          this.lastIndex = origLastIndex;
      }

      return match;
  };

  /**
   * Fixes browser bugs in the native `RegExp.prototype.test`. Calling `XRegExp.install('natives')`
   * uses this to override the native method.
   *
   * @memberOf RegExp
   * @param {String} str String to search.
   * @returns {Boolean} Whether the regex matched the provided value.
   */
  fixed.test = function(str) {
      // Do this the easy way :-)
      return !!fixed.exec.call(this, str);
  };

  /**
   * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
   * bugs in the native `String.prototype.match`. Calling `XRegExp.install('natives')` uses this to
   * override the native method.
   *
   * @memberOf String
   * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.
   * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,
   *   the result of calling `regex.exec(this)`.
   */
  fixed.match = function(regex) {
      var result;

      if (!XRegExp.isRegExp(regex)) {
          // Use the native `RegExp` rather than `XRegExp`
          regex = new RegExp(regex);
      } else if (regex.global) {
          result = nativ.match.apply(this, arguments);
          // Fixes IE bug
          regex.lastIndex = 0;

          return result;
      }

      return fixed.exec.call(regex, toObject(this));
  };

  /**
   * Adds support for `${n}` tokens for named and numbered backreferences in replacement text, and
   * provides named backreferences to replacement functions as `arguments[0].name`. Also fixes browser
   * bugs in replacement text syntax when performing a replacement using a nonregex search value, and
   * the value of a replacement regex's `lastIndex` property during replacement iterations and upon
   * completion. Calling `XRegExp.install('natives')` uses this to override the native method. Note
   * that this doesn't support SpiderMonkey's proprietary third (`flags`) argument. Use via
   * `XRegExp.replace` without overriding natives.
   *
   * @memberOf String
   * @param {RegExp|String} search Search pattern to be replaced.
   * @param {String|Function} replacement Replacement string or a function invoked to create it.
   * @returns {String} New string with one or all matches replaced.
   */
  fixed.replace = function(search, replacement) {
      var isRegex = XRegExp.isRegExp(search);
      var origLastIndex;
      var captureNames;
      var result;

      if (isRegex) {
          if (search[REGEX_DATA]) {
              captureNames = search[REGEX_DATA].captureNames;
          }
          // Only needed if `search` is nonglobal
          origLastIndex = search.lastIndex;
      } else {
          search += ''; // Type-convert
      }

      // Don't use `typeof`; some older browsers return 'function' for regex objects
      if (isType(replacement, 'Function')) {
          // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement
          // functions isn't type-converted to a string
          result = nativ.replace.call(String(this), search, function() {
              var args = arguments;
              var i;
              if (captureNames) {
                  // Change the `arguments[0]` string primitive to a `String` object that can store
                  // properties. This really does need to use `String` as a constructor
                  args[0] = new String(args[0]);
                  // Store named backreferences on the first argument
                  for (i = 0; i < captureNames.length; ++i) {
                      if (captureNames[i]) {
                          args[0][captureNames[i]] = args[i + 1];
                      }
                  }
              }
              // Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox, Safari
              // bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)
              if (isRegex && search.global) {
                  search.lastIndex = args[args.length - 2] + args[0].length;
              }
              // ES6 specs the context for replacement functions as `undefined`
              return replacement.apply(undefined, args);
          });
      } else {
          // Ensure that the last value of `args` will be a string when given nonstring `this`,
          // while still throwing on null or undefined context
          result = nativ.replace.call(this == null ? this : String(this), search, function() {
              // Keep this function's `arguments` available through closure
              var args = arguments;
              return nativ.replace.call(String(replacement), replacementToken, function($0, $1, $2) {
                  var n;
                  // Named or numbered backreference with curly braces
                  if ($1) {
                      // XRegExp behavior for `${n}`:
                      // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the
                      //    entire match. Any number of leading zeros may be used.
                      // 2. Backreference to named capture `n`, if it exists and is not an integer
                      //    overridden by numbered capture. In practice, this does not overlap with
                      //    numbered capture since XRegExp does not allow named capture to use a bare
                      //    integer as the name.
                      // 3. If the name or number does not refer to an existing capturing group, it's
                      //    an error.
                      n = +$1; // Type-convert; drop leading zeros
                      if (n <= args.length - 3) {
                          return args[n] || '';
                      }
                      // Groups with the same name is an error, else would need `lastIndexOf`
                      n = captureNames ? indexOf(captureNames, $1) : -1;
                      if (n < 0) {
                          throw new SyntaxError('Backreference to undefined group ' + $0);
                      }
                      return args[n + 1] || '';
                  }
                  // Else, special variable or numbered backreference without curly braces
                  if ($2 === '$') { // $$
                      return '$';
                  }
                  if ($2 === '&' || +$2 === 0) { // $&, $0 (not followed by 1-9), $00
                      return args[0];
                  }
                  if ($2 === '`') { // $` (left context)
                      return args[args.length - 1].slice(0, args[args.length - 2]);
                  }
                  if ($2 === "'") { // $' (right context)
                      return args[args.length - 1].slice(args[args.length - 2] + args[0].length);
                  }
                  // Else, numbered backreference without curly braces
                  $2 = +$2; // Type-convert; drop leading zero
                  // XRegExp behavior for `$n` and `$nn`:
                  // - Backrefs end after 1 or 2 digits. Use `${..}` for more digits.
                  // - `$1` is an error if no capturing groups.
                  // - `$10` is an error if less than 10 capturing groups. Use `${1}0` instead.
                  // - `$01` is `$1` if at least one capturing group, else it's an error.
                  // - `$0` (not followed by 1-9) and `$00` are the entire match.
                  // Native behavior, for comparison:
                  // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.
                  // - `$1` is a literal `$1` if no capturing groups.
                  // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.
                  // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.
                  // - `$0` is a literal `$0`.
                  if (!isNaN($2)) {
                      if ($2 > args.length - 3) {
                          throw new SyntaxError('Backreference to undefined group ' + $0);
                      }
                      return args[$2] || '';
                  }
                  // `$` followed by an unsupported char is an error, unlike native JS
                  throw new SyntaxError('Invalid token ' + $0);
              });
          });
      }

      if (isRegex) {
          if (search.global) {
              // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
              search.lastIndex = 0;
          } else {
              // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
              search.lastIndex = origLastIndex;
          }
      }

      return result;
  };

  /**
   * Fixes browser bugs in the native `String.prototype.split`. Calling `XRegExp.install('natives')`
   * uses this to override the native method. Use via `XRegExp.split` without overriding natives.
   *
   * @memberOf String
   * @param {RegExp|String} separator Regex or string to use for separating the string.
   * @param {Number} [limit] Maximum number of items to include in the result array.
   * @returns {Array} Array of substrings.
   */
  fixed.split = function(separator, limit) {
      if (!XRegExp.isRegExp(separator)) {
          // Browsers handle nonregex split correctly, so use the faster native method
          return nativ.split.apply(this, arguments);
      }

      var str = String(this);
      var output = [];
      var origLastIndex = separator.lastIndex;
      var lastLastIndex = 0;
      var lastLength;

      // Values for `limit`, per the spec:
      // If undefined: pow(2,32) - 1
      // If 0, Infinity, or NaN: 0
      // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);
      // If negative number: pow(2,32) - floor(abs(limit))
      // If other: Type-convert, then use the above rules
      // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless
      // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+
      limit = (limit === undefined ? -1 : limit) >>> 0;

      XRegExp.forEach(str, separator, function(match) {
          // This condition is not the same as `if (match[0].length)`
          if ((match.index + match[0].length) > lastLastIndex) {
              output.push(str.slice(lastLastIndex, match.index));
              if (match.length > 1 && match.index < str.length) {
                  Array.prototype.push.apply(output, match.slice(1));
              }
              lastLength = match[0].length;
              lastLastIndex = match.index + lastLength;
          }
      });

      if (lastLastIndex === str.length) {
          if (!nativ.test.call(separator, '') || lastLength) {
              output.push('');
          }
      } else {
          output.push(str.slice(lastLastIndex));
      }

      separator.lastIndex = origLastIndex;
      return output.length > limit ? output.slice(0, limit) : output;
  };

  // ==--------------------------==
  // Built-in syntax/flag tokens
  // ==--------------------------==

  /*
   * Letter escapes that natively match literal characters: `\a`, `\A`, etc. These should be
   * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser
   * consistency and to reserve their syntax, but lets them be superseded by addons.
   */
  XRegExp.addToken(
      /\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4}|{[\dA-Fa-f]+})|x(?![\dA-Fa-f]{2}))/,
      function(match, scope) {
          // \B is allowed in default scope only
          if (match[1] === 'B' && scope === defaultScope) {
              return match[0];
          }
          throw new SyntaxError('Invalid escape ' + match[0]);
      },
      {
          scope: 'all',
          leadChar: '\\'
      }
  );

  /*
   * Unicode code point escape with curly braces: `\u{N..}`. `N..` is any one or more digit
   * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag
   * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to
   * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior
   * if you follow a `\u{N..}` token that references a code point above U+FFFF with a quantifier, or
   * if you use the same in a character class.
   */
  XRegExp.addToken(
      /\\u{([\dA-Fa-f]+)}/,
      function(match, scope, flags) {
          var code = dec(match[1]);
          if (code > 0x10FFFF) {
              throw new SyntaxError('Invalid Unicode code point ' + match[0]);
          }
          if (code <= 0xFFFF) {
              // Converting to \uNNNN avoids needing to escape the literal character and keep it
              // separate from preceding tokens
              return '\\u' + pad4(hex(code));
          }
          // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling
          if (hasNativeU && flags.indexOf('u') > -1) {
              return match[0];
          }
          throw new SyntaxError('Cannot use Unicode code point above \\u{FFFF} without flag u');
      },
      {
          scope: 'all',
          leadChar: '\\'
      }
  );

  /*
   * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.
   * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because
   * character class endings can't be determined.
   */
  XRegExp.addToken(
      /\[(\^?)\]/,
      function(match) {
          // For cross-browser compatibility with ES3, convert [] to \b\B and [^] to [\s\S].
          // (?!) should work like \b\B, but is unreliable in some versions of Firefox
          return match[1] ? '[\\s\\S]' : '\\b\\B';
      },
      {leadChar: '['}
  );

  /*
   * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in
   * free-spacing mode (flag x).
   */
  XRegExp.addToken(
      /\(\?#[^)]*\)/,
      getContextualTokenSeparator,
      {leadChar: '('}
  );

  /*
   * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.
   */
  XRegExp.addToken(
      /\s+|#[^\n]*\n?/,
      getContextualTokenSeparator,
      {flag: 'x'}
  );

  /*
   * Dot, in dotall mode (aka singleline mode, flag s) only.
   */
  XRegExp.addToken(
      /\./,
      function() {
          return '[\\s\\S]';
      },
      {
          flag: 's',
          leadChar: '.'
      }
  );

  /*
   * Named backreference: `\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,
   * and $ only. Also allows numbered backreferences as `\k<n>`.
   */
  XRegExp.addToken(
      /\\k<([\w$]+)>/,
      function(match) {
          // Groups with the same name is an error, else would need `lastIndexOf`
          var index = isNaN(match[1]) ? (indexOf(this.captureNames, match[1]) + 1) : +match[1];
          var endIndex = match.index + match[0].length;
          if (!index || index > this.captureNames.length) {
              throw new SyntaxError('Backreference to undefined group ' + match[0]);
          }
          // Keep backreferences separate from subsequent literal numbers. This avoids e.g.
          // inadvertedly changing `(?<n>)\k<n>1` to `()\11`.
          return '\\' + index + (
              endIndex === match.input.length || isNaN(match.input.charAt(endIndex)) ?
                  '' : '(?:)'
          );
      },
      {leadChar: '\\'}
  );

  /*
   * Numbered backreference or octal, plus any following digits: `\0`, `\11`, etc. Octals except `\0`
   * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches
   * are returned unaltered. IE < 9 doesn't support backreferences above `\99` in regex syntax.
   */
  XRegExp.addToken(
      /\\(\d+)/,
      function(match, scope) {
          if (
              !(
                  scope === defaultScope &&
                  /^[1-9]/.test(match[1]) &&
                  +match[1] <= this.captureNames.length
              ) &&
              match[1] !== '0'
          ) {
              throw new SyntaxError('Cannot use octal escape or backreference to undefined group ' +
                  match[0]);
          }
          return match[0];
      },
      {
          scope: 'all',
          leadChar: '\\'
      }
  );

  /*
   * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the
   * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style
   * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively
   * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to
   * Python-style named capture as octals.
   */
  XRegExp.addToken(
      /\(\?P?<([\w$]+)>/,
      function(match) {
          // Disallow bare integers as names because named backreferences are added to match arrays
          // and therefore numeric properties may lead to incorrect lookups
          if (!isNaN(match[1])) {
              throw new SyntaxError('Cannot use integer as capture name ' + match[0]);
          }
          if (match[1] === 'length' || match[1] === '__proto__') {
              throw new SyntaxError('Cannot use reserved word as capture name ' + match[0]);
          }
          if (indexOf(this.captureNames, match[1]) > -1) {
              throw new SyntaxError('Cannot use same name for multiple groups ' + match[0]);
          }
          this.captureNames.push(match[1]);
          this.hasNamedCapture = true;
          return '(';
      },
      {leadChar: '('}
  );

  /*
   * Capturing group; match the opening parenthesis only. Required for support of named capturing
   * groups. Also adds explicit capture mode (flag n).
   */
  XRegExp.addToken(
      /\((?!\?)/,
      function(match, scope, flags) {
          if (flags.indexOf('n') > -1) {
              return '(?:';
          }
          this.captureNames.push(null);
          return '(';
      },
      {
          optionalFlags: 'n',
          leadChar: '('
      }
  );

  module.exports = XRegExp;

  },{}]},{},[8])(8)
  });
  });

  var inflection = createCommonjsModule(function (module, exports) {
  /*!
   * inflection
   * Copyright(c) 2011 Ben Lin <ben@dreamerslab.com>
   * MIT Licensed
   *
   * @fileoverview
   * A port of inflection-js to node.js module.
   */

  ( function ( root, factory ){
    {
      module.exports = factory();
    }
  }( commonjsGlobal, function (){

    /**
     * @description This is a list of nouns that use the same form for both singular and plural.
     *              This list should remain entirely in lower case to correctly match Strings.
     * @private
     */
    var uncountable_words = [
      // 'access',
      'accommodation',
      'adulthood',
      'advertising',
      'advice',
      'aggression',
      'aid',
      'air',
      'aircraft',
      'alcohol',
      'anger',
      'applause',
      'arithmetic',
      // 'art',
      'assistance',
      'athletics',
      // 'attention',

      'bacon',
      'baggage',
      // 'ballet',
      // 'beauty',
      'beef',
      // 'beer',
      // 'behavior',
      'biology',
      // 'billiards',
      'blood',
      'botany',
      // 'bowels',
      'bread',
      // 'business',
      'butter',

      'carbon',
      'cardboard',
      'cash',
      'chalk',
      'chaos',
      'chess',
      'crossroads',
      'countryside',

      // 'damage',
      'dancing',
      // 'danger',
      'deer',
      // 'delight',
      // 'dessert',
      'dignity',
      'dirt',
      // 'distribution',
      'dust',

      'economics',
      'education',
      'electricity',
      // 'employment',
      // 'energy',
      'engineering',
      'enjoyment',
      // 'entertainment',
      'envy',
      'equipment',
      'ethics',
      'evidence',
      'evolution',

      // 'failure',
      // 'faith',
      'fame',
      'fiction',
      // 'fish',
      'flour',
      'flu',
      'food',
      // 'freedom',
      // 'fruit',
      'fuel',
      'fun',
      // 'funeral',
      'furniture',

      'gallows',
      'garbage',
      'garlic',
      // 'gas',
      'genetics',
      // 'glass',
      'gold',
      'golf',
      'gossip',
      'grammar',
      // 'grass',
      'gratitude',
      'grief',
      // 'ground',
      'guilt',
      'gymnastics',

      // 'hair',
      'happiness',
      'hardware',
      'harm',
      'hate',
      'hatred',
      'health',
      'heat',
      // 'height',
      'help',
      'homework',
      'honesty',
      'honey',
      'hospitality',
      'housework',
      'humour',
      'hunger',
      'hydrogen',

      'ice',
      'importance',
      'inflation',
      'information',
      // 'injustice',
      'innocence',
      // 'intelligence',
      'iron',
      'irony',

      'jam',
      // 'jealousy',
      // 'jelly',
      'jewelry',
      // 'joy',
      'judo',
      // 'juice',
      // 'justice',

      'karate',
      // 'kindness',
      'knowledge',

      // 'labour',
      'lack',
      // 'land',
      'laughter',
      'lava',
      'leather',
      'leisure',
      'lightning',
      'linguine',
      'linguini',
      'linguistics',
      'literature',
      'litter',
      'livestock',
      'logic',
      'loneliness',
      // 'love',
      'luck',
      'luggage',

      'macaroni',
      'machinery',
      'magic',
      // 'mail',
      'management',
      'mankind',
      'marble',
      'mathematics',
      'mayonnaise',
      'measles',
      // 'meat',
      // 'metal',
      'methane',
      'milk',
      'minus',
      'money',
      // 'moose',
      'mud',
      'music',
      'mumps',

      'nature',
      'news',
      'nitrogen',
      'nonsense',
      'nurture',
      'nutrition',

      'obedience',
      'obesity',
      // 'oil',
      'oxygen',

      // 'paper',
      // 'passion',
      'pasta',
      'patience',
      // 'permission',
      'physics',
      'poetry',
      'pollution',
      'poverty',
      // 'power',
      'pride',
      // 'production',
      // 'progress',
      // 'pronunciation',
      'psychology',
      'publicity',
      'punctuation',

      // 'quality',
      // 'quantity',
      'quartz',

      'racism',
      // 'rain',
      // 'recreation',
      'relaxation',
      'reliability',
      'research',
      'respect',
      'revenge',
      'rice',
      'rubbish',
      'rum',

      'safety',
      // 'salad',
      // 'salt',
      // 'sand',
      // 'satire',
      'scenery',
      'seafood',
      'seaside',
      'series',
      'shame',
      'sheep',
      'shopping',
      // 'silence',
      'sleep',
      // 'slang'
      'smoke',
      'smoking',
      'snow',
      'soap',
      'software',
      'soil',
      // 'sorrow',
      // 'soup',
      'spaghetti',
      // 'speed',
      'species',
      // 'spelling',
      // 'sport',
      'steam',
      // 'strength',
      'stuff',
      'stupidity',
      // 'success',
      // 'sugar',
      'sunshine',
      'symmetry',

      // 'tea',
      'tennis',
      'thirst',
      'thunder',
      'timber',
      // 'time',
      // 'toast',
      // 'tolerance',
      // 'trade',
      'traffic',
      'transportation',
      // 'travel',
      'trust',

      // 'understanding',
      'underwear',
      'unemployment',
      'unity',
      // 'usage',

      'validity',
      'veal',
      'vegetation',
      'vegetarianism',
      'vengeance',
      'violence',
      // 'vision',
      'vitality',

      'warmth',
      // 'water',
      'wealth',
      'weather',
      // 'weight',
      'welfare',
      'wheat',
      // 'whiskey',
      // 'width',
      'wildlife',
      // 'wine',
      'wisdom',
      // 'wood',
      // 'wool',
      // 'work',

      // 'yeast',
      'yoga',

      'zinc',
      'zoology'
    ];

    /**
     * @description These rules translate from the singular form of a noun to its plural form.
     * @private
     */

    var regex = {
      plural : {
        men       : new RegExp( '^(m|wom)en$'                    , 'gi' ),
        people    : new RegExp( '(pe)ople$'                      , 'gi' ),
        children  : new RegExp( '(child)ren$'                    , 'gi' ),
        tia       : new RegExp( '([ti])a$'                       , 'gi' ),
        analyses  : new RegExp( '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$','gi' ),
        hives     : new RegExp( '(hi|ti)ves$'                    , 'gi' ),
        curves    : new RegExp( '(curve)s$'                      , 'gi' ),
        lrves     : new RegExp( '([lr])ves$'                     , 'gi' ),
        aves      : new RegExp( '([a])ves$'                      , 'gi' ),
        foves     : new RegExp( '([^fo])ves$'                    , 'gi' ),
        movies    : new RegExp( '(m)ovies$'                      , 'gi' ),
        aeiouyies : new RegExp( '([^aeiouy]|qu)ies$'             , 'gi' ),
        series    : new RegExp( '(s)eries$'                      , 'gi' ),
        xes       : new RegExp( '(x|ch|ss|sh)es$'                , 'gi' ),
        mice      : new RegExp( '([m|l])ice$'                    , 'gi' ),
        buses     : new RegExp( '(bus)es$'                       , 'gi' ),
        oes       : new RegExp( '(o)es$'                         , 'gi' ),
        shoes     : new RegExp( '(shoe)s$'                       , 'gi' ),
        crises    : new RegExp( '(cris|ax|test)es$'              , 'gi' ),
        octopi    : new RegExp( '(octop|vir)i$'                  , 'gi' ),
        aliases   : new RegExp( '(alias|canvas|status|campus)es$', 'gi' ),
        summonses : new RegExp( '^(summons)es$'                  , 'gi' ),
        oxen      : new RegExp( '^(ox)en'                        , 'gi' ),
        matrices  : new RegExp( '(matr)ices$'                    , 'gi' ),
        vertices  : new RegExp( '(vert|ind)ices$'                , 'gi' ),
        feet      : new RegExp( '^feet$'                         , 'gi' ),
        teeth     : new RegExp( '^teeth$'                        , 'gi' ),
        geese     : new RegExp( '^geese$'                        , 'gi' ),
        quizzes   : new RegExp( '(quiz)zes$'                     , 'gi' ),
        whereases : new RegExp( '^(whereas)es$'                  , 'gi' ),
        criteria  : new RegExp( '^(criteri)a$'                   , 'gi' ),
        genera    : new RegExp( '^genera$'                       , 'gi' ),
        ss        : new RegExp( 'ss$'                            , 'gi' ),
        s         : new RegExp( 's$'                             , 'gi' )
      },

      singular : {
        man       : new RegExp( '^(m|wom)an$'                  , 'gi' ),
        person    : new RegExp( '(pe)rson$'                    , 'gi' ),
        child     : new RegExp( '(child)$'                     , 'gi' ),
        ox        : new RegExp( '^(ox)$'                       , 'gi' ),
        axis      : new RegExp( '(ax|test)is$'                 , 'gi' ),
        octopus   : new RegExp( '(octop|vir)us$'               , 'gi' ),
        alias     : new RegExp( '(alias|status|canvas|campus)$', 'gi' ),
        summons   : new RegExp( '^(summons)$'                  , 'gi' ),
        bus       : new RegExp( '(bu)s$'                       , 'gi' ),
        buffalo   : new RegExp( '(buffal|tomat|potat)o$'       , 'gi' ),
        tium      : new RegExp( '([ti])um$'                    , 'gi' ),
        sis       : new RegExp( 'sis$'                         , 'gi' ),
        ffe       : new RegExp( '(?:([^f])fe|([lr])f)$'        , 'gi' ),
        hive      : new RegExp( '(hi|ti)ve$'                   , 'gi' ),
        aeiouyy   : new RegExp( '([^aeiouy]|qu)y$'             , 'gi' ),
        x         : new RegExp( '(x|ch|ss|sh)$'                , 'gi' ),
        matrix    : new RegExp( '(matr)ix$'                    , 'gi' ),
        vertex    : new RegExp( '(vert|ind)ex$'                , 'gi' ),
        mouse     : new RegExp( '([m|l])ouse$'                 , 'gi' ),
        foot      : new RegExp( '^foot$'                       , 'gi' ),
        tooth     : new RegExp( '^tooth$'                      , 'gi' ),
        goose     : new RegExp( '^goose$'                      , 'gi' ),
        quiz      : new RegExp( '(quiz)$'                      , 'gi' ),
        whereas   : new RegExp( '^(whereas)$'                  , 'gi' ),
        criterion : new RegExp( '^(criteri)on$'                , 'gi' ),
        genus     : new RegExp( '^genus$'                      , 'gi' ),
        s         : new RegExp( 's$'                           , 'gi' ),
        common    : new RegExp( '$'                            , 'gi' )
      }
    };

    var plural_rules = [

      // do not replace if its already a plural word
      [ regex.plural.men       ],
      [ regex.plural.people    ],
      [ regex.plural.children  ],
      [ regex.plural.tia       ],
      [ regex.plural.analyses  ],
      [ regex.plural.hives     ],
      [ regex.plural.curves    ],
      [ regex.plural.lrves     ],
      [ regex.plural.foves     ],
      [ regex.plural.aeiouyies ],
      [ regex.plural.series    ],
      [ regex.plural.movies    ],
      [ regex.plural.xes       ],
      [ regex.plural.mice      ],
      [ regex.plural.buses     ],
      [ regex.plural.oes       ],
      [ regex.plural.shoes     ],
      [ regex.plural.crises    ],
      [ regex.plural.octopi    ],
      [ regex.plural.aliases   ],
      [ regex.plural.summonses ],
      [ regex.plural.oxen      ],
      [ regex.plural.matrices  ],
      [ regex.plural.feet      ],
      [ regex.plural.teeth     ],
      [ regex.plural.geese     ],
      [ regex.plural.quizzes   ],
      [ regex.plural.whereases ],
      [ regex.plural.criteria  ],
      [ regex.plural.genera    ],

      // original rule
      [ regex.singular.man      , '$1en' ],
      [ regex.singular.person   , '$1ople' ],
      [ regex.singular.child    , '$1ren' ],
      [ regex.singular.ox       , '$1en' ],
      [ regex.singular.axis     , '$1es' ],
      [ regex.singular.octopus  , '$1i' ],
      [ regex.singular.alias    , '$1es' ],
      [ regex.singular.summons  , '$1es' ],
      [ regex.singular.bus      , '$1ses' ],
      [ regex.singular.buffalo  , '$1oes' ],
      [ regex.singular.tium     , '$1a' ],
      [ regex.singular.sis      , 'ses' ],
      [ regex.singular.ffe      , '$1$2ves' ],
      [ regex.singular.hive     , '$1ves' ],
      [ regex.singular.aeiouyy  , '$1ies' ],
      [ regex.singular.matrix   , '$1ices' ],
      [ regex.singular.vertex   , '$1ices' ],
      [ regex.singular.x        , '$1es' ],
      [ regex.singular.mouse    , '$1ice' ],
      [ regex.singular.foot     , 'feet' ],
      [ regex.singular.tooth    , 'teeth' ],
      [ regex.singular.goose    , 'geese' ],
      [ regex.singular.quiz     , '$1zes' ],
      [ regex.singular.whereas  , '$1es' ],
      [ regex.singular.criterion, '$1a' ],
      [ regex.singular.genus    , 'genera' ],

      [ regex.singular.s     , 's' ],
      [ regex.singular.common, 's' ]
    ];

    /**
     * @description These rules translate from the plural form of a noun to its singular form.
     * @private
     */
    var singular_rules = [

      // do not replace if its already a singular word
      [ regex.singular.man     ],
      [ regex.singular.person  ],
      [ regex.singular.child   ],
      [ regex.singular.ox      ],
      [ regex.singular.axis    ],
      [ regex.singular.octopus ],
      [ regex.singular.alias   ],
      [ regex.singular.summons ],
      [ regex.singular.bus     ],
      [ regex.singular.buffalo ],
      [ regex.singular.tium    ],
      [ regex.singular.sis     ],
      [ regex.singular.ffe     ],
      [ regex.singular.hive    ],
      [ regex.singular.aeiouyy ],
      [ regex.singular.x       ],
      [ regex.singular.matrix  ],
      [ regex.singular.mouse   ],
      [ regex.singular.foot    ],
      [ regex.singular.tooth   ],
      [ regex.singular.goose   ],
      [ regex.singular.quiz    ],
      [ regex.singular.whereas ],
      [ regex.singular.criterion ],
      [ regex.singular.genus ],

      // original rule
      [ regex.plural.men      , '$1an' ],
      [ regex.plural.people   , '$1rson' ],
      [ regex.plural.children , '$1' ],
      [ regex.plural.genera   , 'genus'],
      [ regex.plural.criteria , '$1on'],
      [ regex.plural.tia      , '$1um' ],
      [ regex.plural.analyses , '$1$2sis' ],
      [ regex.plural.hives    , '$1ve' ],
      [ regex.plural.curves   , '$1' ],
      [ regex.plural.lrves    , '$1f' ],
      [ regex.plural.aves     , '$1ve' ],
      [ regex.plural.foves    , '$1fe' ],
      [ regex.plural.movies   , '$1ovie' ],
      [ regex.plural.aeiouyies, '$1y' ],
      [ regex.plural.series   , '$1eries' ],
      [ regex.plural.xes      , '$1' ],
      [ regex.plural.mice     , '$1ouse' ],
      [ regex.plural.buses    , '$1' ],
      [ regex.plural.oes      , '$1' ],
      [ regex.plural.shoes    , '$1' ],
      [ regex.plural.crises   , '$1is' ],
      [ regex.plural.octopi   , '$1us' ],
      [ regex.plural.aliases  , '$1' ],
      [ regex.plural.summonses, '$1' ],
      [ regex.plural.oxen     , '$1' ],
      [ regex.plural.matrices , '$1ix' ],
      [ regex.plural.vertices , '$1ex' ],
      [ regex.plural.feet     , 'foot' ],
      [ regex.plural.teeth    , 'tooth' ],
      [ regex.plural.geese    , 'goose' ],
      [ regex.plural.quizzes  , '$1' ],
      [ regex.plural.whereases, '$1' ],

      [ regex.plural.ss, 'ss' ],
      [ regex.plural.s , '' ]
    ];

    /**
     * @description This is a list of words that should not be capitalized for title case.
     * @private
     */
    var non_titlecased_words = [
      'and', 'or', 'nor', 'a', 'an', 'the', 'so', 'but', 'to', 'of', 'at','by',
      'from', 'into', 'on', 'onto', 'off', 'out', 'in', 'over', 'with', 'for'
    ];

    /**
     * @description These are regular expressions used for converting between String formats.
     * @private
     */
    var id_suffix         = new RegExp( '(_ids|_id)$', 'g' );
    var underbar          = new RegExp( '_', 'g' );
    var space_or_underbar = new RegExp( '[\ _]', 'g' );
    var uppercase         = new RegExp( '([A-Z])', 'g' );
    var underbar_prefix   = new RegExp( '^_' );

    var inflector = {

    /**
     * A helper method that applies rules based replacement to a String.
     * @private
     * @function
     * @param {String} str String to modify and return based on the passed rules.
     * @param {Array: [RegExp, String]} rules Regexp to match paired with String to use for replacement
     * @param {Array: [String]} skip Strings to skip if they match
     * @param {String} override String to return as though this method succeeded (used to conform to APIs)
     * @returns {String} Return passed String modified by passed rules.
     * @example
     *
     *     this._apply_rules( 'cows', singular_rules ); // === 'cow'
     */
      _apply_rules : function ( str, rules, skip, override ){
        if( override ){
          str = override;
        }else{
          var ignore = ( inflector.indexOf( skip, str.toLowerCase()) > -1 );

          if( !ignore ){
            var i = 0;
            var j = rules.length;

            for( ; i < j; i++ ){
              if( str.match( rules[ i ][ 0 ])){
                if( rules[ i ][ 1 ] !== undefined ){
                  str = str.replace( rules[ i ][ 0 ], rules[ i ][ 1 ]);
                }
                break;
              }
            }
          }
        }

        return str;
      },



    /**
     * This lets us detect if an Array contains a given element.
     * @public
     * @function
     * @param {Array} arr The subject array.
     * @param {Object} item Object to locate in the Array.
     * @param {Number} from_index Starts checking from this position in the Array.(optional)
     * @param {Function} compare_func Function used to compare Array item vs passed item.(optional)
     * @returns {Number} Return index position in the Array of the passed item.
     * @example
     *
     *     var inflection = require( 'inflection' );
     *
     *     inflection.indexOf([ 'hi','there' ], 'guys' ); // === -1
     *     inflection.indexOf([ 'hi','there' ], 'hi' ); // === 0
     */
      indexOf : function ( arr, item, from_index, compare_func ){
        if( !from_index ){
          from_index = -1;
        }

        var index = -1;
        var i     = from_index;
        var j     = arr.length;

        for( ; i < j; i++ ){
          if( arr[ i ]  === item || compare_func && compare_func( arr[ i ], item )){
            index = i;
            break;
          }
        }

        return index;
      },



    /**
     * This function adds pluralization support to every String object.
     * @public
     * @function
     * @param {String} str The subject string.
     * @param {String} plural Overrides normal output with said String.(optional)
     * @returns {String} Singular English language nouns are returned in plural form.
     * @example
     *
     *     var inflection = require( 'inflection' );
     *
     *     inflection.pluralize( 'person' ); // === 'people'
     *     inflection.pluralize( 'octopus' ); // === 'octopi'
     *     inflection.pluralize( 'Hat' ); // === 'Hats'
     *     inflection.pluralize( 'person', 'guys' ); // === 'guys'
     */
      pluralize : function ( str, plural ){
        return inflector._apply_rules( str, plural_rules, uncountable_words, plural );
      },



    /**
     * This function adds singularization support to every String object.
     * @public
     * @function
     * @param {String} str The subject string.
     * @param {String} singular Overrides normal output with said String.(optional)
     * @returns {String} Plural English language nouns are returned in singular form.
     * @example
     *
     *     var inflection = require( 'inflection' );
     *
     *     inflection.singularize( 'people' ); // === 'person'
     *     inflection.singularize( 'octopi' ); // === 'octopus'
     *     inflection.singularize( 'Hats' ); // === 'Hat'
     *     inflection.singularize( 'guys', 'person' ); // === 'person'
     */
      singularize : function ( str, singular ){
        return inflector._apply_rules( str, singular_rules, uncountable_words, singular );
      },


    /**
     * This function will pluralize or singularlize a String appropriately based on an integer value
     * @public
     * @function
     * @param {String} str The subject string.
     * @param {Number} count The number to base pluralization off of.
     * @param {String} singular Overrides normal output with said String.(optional)
     * @param {String} plural Overrides normal output with said String.(optional)
     * @returns {String} English language nouns are returned in the plural or singular form based on the count.
     * @example
     *
     *     var inflection = require( 'inflection' );
     *
     *     inflection.inflect( 'people' 1 ); // === 'person'
     *     inflection.inflect( 'octopi' 1 ); // === 'octopus'
     *     inflection.inflect( 'Hats' 1 ); // === 'Hat'
     *     inflection.inflect( 'guys', 1 , 'person' ); // === 'person'
     *     inflection.inflect( 'person', 2 ); // === 'people'
     *     inflection.inflect( 'octopus', 2 ); // === 'octopi'
     *     inflection.inflect( 'Hat', 2 ); // === 'Hats'
     *     inflection.inflect( 'person', 2, null, 'guys' ); // === 'guys'
     */
      inflect : function ( str, count, singular, plural ){
        count = parseInt( count, 10 );

        if( isNaN( count )) return str;

        if( count === 0 || count > 1 ){
          return inflector._apply_rules( str, plural_rules, uncountable_words, plural );
        }else{
          return inflector._apply_rules( str, singular_rules, uncountable_words, singular );
        }
      },



    /**
     * This function adds camelization support to every String object.
     * @public
     * @function
     * @param {String} str The subject string.
     * @param {Boolean} low_first_letter Default is to capitalize the first letter of the results.(optional)
     *                                 Passing true will lowercase it.
     * @returns {String} Lower case underscored words will be returned in camel case.
     *                  additionally '/' is translated to '::'
     * @example
     *
     *     var inflection = require( 'inflection' );
     *
     *     inflection.camelize( 'message_properties' ); // === 'MessageProperties'
     *     inflection.camelize( 'message_properties', true ); // === 'messageProperties'
     */
      camelize : function ( str, low_first_letter ){
        var str_path = str.split( '/' );
        var i        = 0;
        var j        = str_path.length;
        var str_arr, k, l, first;

        for( ; i < j; i++ ){
          str_arr = str_path[ i ].split( '_' );
          k       = 0;
          l       = str_arr.length;

          for( ; k < l; k++ ){
            if( k !== 0 ){
              str_arr[ k ] = str_arr[ k ].toLowerCase();
            }

            first = str_arr[ k ].charAt( 0 );
            first = low_first_letter && i === 0 && k === 0
              ? first.toLowerCase() : first.toUpperCase();
            str_arr[ k ] = first + str_arr[ k ].substring( 1 );
          }

          str_path[ i ] = str_arr.join( '' );
        }

        return str_path.join( '::' );
      },



    /**
     * This function adds underscore support to every String object.
     * @public
     * @function
     * @param {String} str The subject string.
     * @param {Boolean} all_upper_case Default is to lowercase and add underscore prefix.(optional)
     *                  Passing true will return as entered.
     * @returns {String} Camel cased words are returned as lower cased and underscored.
     *                  additionally '::' is translated to '/'.
     * @example
     *
     *     var inflection = require( 'inflection' );
     *
     *     inflection.underscore( 'MessageProperties' ); // === 'message_properties'
     *     inflection.underscore( 'messageProperties' ); // === 'message_properties'
     *     inflection.underscore( 'MP', true ); // === 'MP'
     */
      underscore : function ( str, all_upper_case ){
        if( all_upper_case && str === str.toUpperCase()) return str;

        var str_path = str.split( '::' );
        var i        = 0;
        var j        = str_path.length;

        for( ; i < j; i++ ){
          str_path[ i ] = str_path[ i ].replace( uppercase, '_$1' );
          str_path[ i ] = str_path[ i ].replace( underbar_prefix, '' );
        }

        return str_path.join( '/' ).toLowerCase();
      },



    /**
     * This function adds humanize support to every String object.
     * @public
     * @function
     * @param {String} str The subject string.
     * @param {Boolean} low_first_letter Default is to capitalize the first letter of the results.(optional)
     *                                 Passing true will lowercase it.
     * @returns {String} Lower case underscored words will be returned in humanized form.
     * @example
     *
     *     var inflection = require( 'inflection' );
     *
     *     inflection.humanize( 'message_properties' ); // === 'Message properties'
     *     inflection.humanize( 'message_properties', true ); // === 'message properties'
     */
      humanize : function ( str, low_first_letter ){
        str = str.toLowerCase();
        str = str.replace( id_suffix, '' );
        str = str.replace( underbar, ' ' );

        if( !low_first_letter ){
          str = inflector.capitalize( str );
        }

        return str;
      },



    /**
     * This function adds capitalization support to every String object.
     * @public
     * @function
     * @param {String} str The subject string.
     * @returns {String} All characters will be lower case and the first will be upper.
     * @example
     *
     *     var inflection = require( 'inflection' );
     *
     *     inflection.capitalize( 'message_properties' ); // === 'Message_properties'
     *     inflection.capitalize( 'message properties', true ); // === 'Message properties'
     */
      capitalize : function ( str ){
        str = str.toLowerCase();

        return str.substring( 0, 1 ).toUpperCase() + str.substring( 1 );
      },



    /**
     * This function replaces underscores with dashes in the string.
     * @public
     * @function
     * @param {String} str The subject string.
     * @returns {String} Replaces all spaces or underscores with dashes.
     * @example
     *
     *     var inflection = require( 'inflection' );
     *
     *     inflection.dasherize( 'message_properties' ); // === 'message-properties'
     *     inflection.dasherize( 'Message Properties' ); // === 'Message-Properties'
     */
      dasherize : function ( str ){
        return str.replace( space_or_underbar, '-' );
      },



    /**
     * This function adds titleize support to every String object.
     * @public
     * @function
     * @param {String} str The subject string.
     * @returns {String} Capitalizes words as you would for a book title.
     * @example
     *
     *     var inflection = require( 'inflection' );
     *
     *     inflection.titleize( 'message_properties' ); // === 'Message Properties'
     *     inflection.titleize( 'message properties to keep' ); // === 'Message Properties to Keep'
     */
      titleize : function ( str ){
        str         = str.toLowerCase().replace( underbar, ' ' );
        var str_arr = str.split( ' ' );
        var i       = 0;
        var j       = str_arr.length;
        var d, k, l;

        for( ; i < j; i++ ){
          d = str_arr[ i ].split( '-' );
          k = 0;
          l = d.length;

          for( ; k < l; k++){
            if( inflector.indexOf( non_titlecased_words, d[ k ].toLowerCase()) < 0 ){
              d[ k ] = inflector.capitalize( d[ k ]);
            }
          }

          str_arr[ i ] = d.join( '-' );
        }

        str = str_arr.join( ' ' );
        str = str.substring( 0, 1 ).toUpperCase() + str.substring( 1 );

        return str;
      },



    /**
     * This function adds demodulize support to every String object.
     * @public
     * @function
     * @param {String} str The subject string.
     * @returns {String} Removes module names leaving only class names.(Ruby style)
     * @example
     *
     *     var inflection = require( 'inflection' );
     *
     *     inflection.demodulize( 'Message::Bus::Properties' ); // === 'Properties'
     */
      demodulize : function ( str ){
        var str_arr = str.split( '::' );

        return str_arr[ str_arr.length - 1 ];
      },



    /**
     * This function adds tableize support to every String object.
     * @public
     * @function
     * @param {String} str The subject string.
     * @returns {String} Return camel cased words into their underscored plural form.
     * @example
     *
     *     var inflection = require( 'inflection' );
     *
     *     inflection.tableize( 'MessageBusProperty' ); // === 'message_bus_properties'
     */
      tableize : function ( str ){
        str = inflector.underscore( str );
        str = inflector.pluralize( str );

        return str;
      },



    /**
     * This function adds classification support to every String object.
     * @public
     * @function
     * @param {String} str The subject string.
     * @returns {String} Underscored plural nouns become the camel cased singular form.
     * @example
     *
     *     var inflection = require( 'inflection' );
     *
     *     inflection.classify( 'message_bus_properties' ); // === 'MessageBusProperty'
     */
      classify : function ( str ){
        str = inflector.camelize( str );
        str = inflector.singularize( str );

        return str;
      },



    /**
     * This function adds foreign key support to every String object.
     * @public
     * @function
     * @param {String} str The subject string.
     * @param {Boolean} drop_id_ubar Default is to seperate id with an underbar at the end of the class name,
                                   you can pass true to skip it.(optional)
     * @returns {String} Underscored plural nouns become the camel cased singular form.
     * @example
     *
     *     var inflection = require( 'inflection' );
     *
     *     inflection.foreign_key( 'MessageBusProperty' ); // === 'message_bus_property_id'
     *     inflection.foreign_key( 'MessageBusProperty', true ); // === 'message_bus_propertyid'
     */
      foreign_key : function ( str, drop_id_ubar ){
        str = inflector.demodulize( str );
        str = inflector.underscore( str ) + (( drop_id_ubar ) ? ( '' ) : ( '_' )) + 'id';

        return str;
      },



    /**
     * This function adds ordinalize support to every String object.
     * @public
     * @function
     * @param {String} str The subject string.
     * @returns {String} Return all found numbers their sequence like '22nd'.
     * @example
     *
     *     var inflection = require( 'inflection' );
     *
     *     inflection.ordinalize( 'the 1 pitch' ); // === 'the 1st pitch'
     */
      ordinalize : function ( str ){
        var str_arr = str.split( ' ' );
        var i       = 0;
        var j       = str_arr.length;

        for( ; i < j; i++ ){
          var k = parseInt( str_arr[ i ], 10 );

          if( !isNaN( k )){
            var ltd = str_arr[ i ].substring( str_arr[ i ].length - 2 );
            var ld  = str_arr[ i ].substring( str_arr[ i ].length - 1 );
            var suf = 'th';

            if( ltd != '11' && ltd != '12' && ltd != '13' ){
              if( ld === '1' ){
                suf = 'st';
              }else if( ld === '2' ){
                suf = 'nd';
              }else if( ld === '3' ){
                suf = 'rd';
              }
            }

            str_arr[ i ] += suf;
          }
        }

        return str_arr.join( ' ' );
      },

    /**
     * This function performs multiple inflection methods on a string
     * @public
     * @function
     * @param {String} str The subject string.
     * @param {Array} arr An array of inflection methods.
     * @returns {String}
     * @example
     *
     *     var inflection = require( 'inflection' );
     *
     *     inflection.transform( 'all job', [ 'pluralize', 'capitalize', 'dasherize' ]); // === 'All-jobs'
     */
      transform : function ( str, arr ){
        var i = 0;
        var j = arr.length;

        for( ;i < j; i++ ){
          var method = arr[ i ];

          if( inflector.hasOwnProperty( method )){
            str = inflector[ method ]( str );
          }
        }

        return str;
      }
    };

  /**
   * @public
   */
    inflector.version = '1.12.0';

    return inflector;
  }));
  });

  var strictUriEncode = function (str) {
  	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
  		return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  	});
  };

  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  /* eslint-disable no-unused-vars */
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;

  function toObject(val) {
  	if (val === null || val === undefined) {
  		throw new TypeError('Object.assign cannot be called with null or undefined');
  	}

  	return Object(val);
  }

  function shouldUseNative() {
  	try {
  		if (!Object.assign) {
  			return false;
  		}

  		// Detect buggy property enumeration order in older V8 versions.

  		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
  		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
  		test1[5] = 'de';
  		if (Object.getOwnPropertyNames(test1)[0] === '5') {
  			return false;
  		}

  		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
  		var test2 = {};
  		for (var i = 0; i < 10; i++) {
  			test2['_' + String.fromCharCode(i)] = i;
  		}
  		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
  			return test2[n];
  		});
  		if (order2.join('') !== '0123456789') {
  			return false;
  		}

  		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
  		var test3 = {};
  		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
  			test3[letter] = letter;
  		});
  		if (Object.keys(Object.assign({}, test3)).join('') !==
  				'abcdefghijklmnopqrst') {
  			return false;
  		}

  		return true;
  	} catch (err) {
  		// We don't expect any of the above to throw, but better to be safe.
  		return false;
  	}
  }

  var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
  	var from;
  	var to = toObject(target);
  	var symbols;

  	for (var s = 1; s < arguments.length; s++) {
  		from = Object(arguments[s]);

  		for (var key in from) {
  			if (hasOwnProperty$1.call(from, key)) {
  				to[key] = from[key];
  			}
  		}

  		if (getOwnPropertySymbols) {
  			symbols = getOwnPropertySymbols(from);
  			for (var i = 0; i < symbols.length; i++) {
  				if (propIsEnumerable.call(from, symbols[i])) {
  					to[symbols[i]] = from[symbols[i]];
  				}
  			}
  		}
  	}

  	return to;
  };

  function encoderForArrayFormat(opts) {
  	switch (opts.arrayFormat) {
  		case 'index':
  			return function (key, value, index) {
  				return value === null ? [
  					encode(key, opts),
  					'[',
  					index,
  					']'
  				].join('') : [
  					encode(key, opts),
  					'[',
  					encode(index, opts),
  					']=',
  					encode(value, opts)
  				].join('');
  			};

  		case 'bracket':
  			return function (key, value) {
  				return value === null ? encode(key, opts) : [
  					encode(key, opts),
  					'[]=',
  					encode(value, opts)
  				].join('');
  			};

  		default:
  			return function (key, value) {
  				return value === null ? encode(key, opts) : [
  					encode(key, opts),
  					'=',
  					encode(value, opts)
  				].join('');
  			};
  	}
  }

  function parserForArrayFormat(opts) {
  	var result;

  	switch (opts.arrayFormat) {
  		case 'index':
  			return function (key, value, accumulator) {
  				result = /\[(\d*)\]$/.exec(key);

  				key = key.replace(/\[\d*\]$/, '');

  				if (!result) {
  					accumulator[key] = value;
  					return;
  				}

  				if (accumulator[key] === undefined) {
  					accumulator[key] = {};
  				}

  				accumulator[key][result[1]] = value;
  			};

  		case 'bracket':
  			return function (key, value, accumulator) {
  				result = /(\[\])$/.exec(key);
  				key = key.replace(/\[\]$/, '');

  				if (!result) {
  					accumulator[key] = value;
  					return;
  				} else if (accumulator[key] === undefined) {
  					accumulator[key] = [value];
  					return;
  				}

  				accumulator[key] = [].concat(accumulator[key], value);
  			};

  		default:
  			return function (key, value, accumulator) {
  				if (accumulator[key] === undefined) {
  					accumulator[key] = value;
  					return;
  				}

  				accumulator[key] = [].concat(accumulator[key], value);
  			};
  	}
  }

  function encode(value, opts) {
  	if (opts.encode) {
  		return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
  	}

  	return value;
  }

  function keysSorter(input) {
  	if (Array.isArray(input)) {
  		return input.sort();
  	} else if (typeof input === 'object') {
  		return keysSorter(Object.keys(input)).sort(function (a, b) {
  			return Number(a) - Number(b);
  		}).map(function (key) {
  			return input[key];
  		});
  	}

  	return input;
  }

  var extract = function (str) {
  	return str.split('?')[1] || '';
  };

  var parse = function (str, opts) {
  	opts = objectAssign({arrayFormat: 'none'}, opts);

  	var formatter = parserForArrayFormat(opts);

  	// Create an object with no prototype
  	// https://github.com/sindresorhus/query-string/issues/47
  	var ret = Object.create(null);

  	if (typeof str !== 'string') {
  		return ret;
  	}

  	str = str.trim().replace(/^(\?|#|&)/, '');

  	if (!str) {
  		return ret;
  	}

  	str.split('&').forEach(function (param) {
  		var parts = param.replace(/\+/g, ' ').split('=');
  		// Firefox (pre 40) decodes `%3D` to `=`
  		// https://github.com/sindresorhus/query-string/pull/37
  		var key = parts.shift();
  		var val = parts.length > 0 ? parts.join('=') : undefined;

  		// missing `=` should be `null`:
  		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
  		val = val === undefined ? null : decodeURIComponent(val);

  		formatter(decodeURIComponent(key), val, ret);
  	});

  	return Object.keys(ret).sort().reduce(function (result, key) {
  		var val = ret[key];
  		if (Boolean(val) && typeof val === 'object' && !Array.isArray(val)) {
  			// Sort object keys, not values
  			result[key] = keysSorter(val);
  		} else {
  			result[key] = val;
  		}

  		return result;
  	}, Object.create(null));
  };

  var stringify = function (obj, opts) {
  	var defaults = {
  		encode: true,
  		strict: true,
  		arrayFormat: 'none'
  	};

  	opts = objectAssign(defaults, opts);

  	var formatter = encoderForArrayFormat(opts);

  	return obj ? Object.keys(obj).sort().map(function (key) {
  		var val = obj[key];

  		if (val === undefined) {
  			return '';
  		}

  		if (val === null) {
  			return encode(key, opts);
  		}

  		if (Array.isArray(val)) {
  			var result = [];

  			val.slice().forEach(function (val2) {
  				if (val2 === undefined) {
  					return;
  				}

  				result.push(formatter(key, val2, result.length));
  			});

  			return result.join('&');
  		}

  		return encode(key, opts) + '=' + encode(val, opts);
  	}).filter(function (x) {
  		return x.length > 0;
  	}).join('&') : '';
  };

  var queryString = {
  	extract: extract,
  	parse: parse,
  	stringify: stringify
  };

  var moment = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
      module.exports = factory();
  }(commonjsGlobal, (function () {
      var hookCallback;

      function hooks () {
          return hookCallback.apply(null, arguments);
      }

      // This is done to register the method called with moment()
      // without creating circular dependencies.
      function setHookCallback (callback) {
          hookCallback = callback;
      }

      function isArray(input) {
          return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
      }

      function isObject(input) {
          // IE8 will treat undefined and null as object if it wasn't for
          // input != null
          return input != null && Object.prototype.toString.call(input) === '[object Object]';
      }

      function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
              return (Object.getOwnPropertyNames(obj).length === 0);
          } else {
              var k;
              for (k in obj) {
                  if (obj.hasOwnProperty(k)) {
                      return false;
                  }
              }
              return true;
          }
      }

      function isUndefined(input) {
          return input === void 0;
      }

      function isNumber(input) {
          return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
      }

      function isDate(input) {
          return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
      }

      function map(arr, fn) {
          var res = [], i;
          for (i = 0; i < arr.length; ++i) {
              res.push(fn(arr[i], i));
          }
          return res;
      }

      function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
      }

      function extend(a, b) {
          for (var i in b) {
              if (hasOwnProp(b, i)) {
                  a[i] = b[i];
              }
          }

          if (hasOwnProp(b, 'toString')) {
              a.toString = b.toString;
          }

          if (hasOwnProp(b, 'valueOf')) {
              a.valueOf = b.valueOf;
          }

          return a;
      }

      function createUTC (input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, true).utc();
      }

      function defaultParsingFlags() {
          // We need to deep clone this object.
          return {
              empty           : false,
              unusedTokens    : [],
              unusedInput     : [],
              overflow        : -2,
              charsLeftOver   : 0,
              nullInput       : false,
              invalidMonth    : null,
              invalidFormat   : false,
              userInvalidated : false,
              iso             : false,
              parsedDateParts : [],
              meridiem        : null,
              rfc2822         : false,
              weekdayMismatch : false
          };
      }

      function getParsingFlags(m) {
          if (m._pf == null) {
              m._pf = defaultParsingFlags();
          }
          return m._pf;
      }

      var some;
      if (Array.prototype.some) {
          some = Array.prototype.some;
      } else {
          some = function (fun) {
              var t = Object(this);
              var len = t.length >>> 0;

              for (var i = 0; i < len; i++) {
                  if (i in t && fun.call(this, t[i], i, t)) {
                      return true;
                  }
              }

              return false;
          };
      }

      function isValid(m) {
          if (m._isValid == null) {
              var flags = getParsingFlags(m);
              var parsedParts = some.call(flags.parsedDateParts, function (i) {
                  return i != null;
              });
              var isNowValid = !isNaN(m._d.getTime()) &&
                  flags.overflow < 0 &&
                  !flags.empty &&
                  !flags.invalidMonth &&
                  !flags.invalidWeekday &&
                  !flags.weekdayMismatch &&
                  !flags.nullInput &&
                  !flags.invalidFormat &&
                  !flags.userInvalidated &&
                  (!flags.meridiem || (flags.meridiem && parsedParts));

              if (m._strict) {
                  isNowValid = isNowValid &&
                      flags.charsLeftOver === 0 &&
                      flags.unusedTokens.length === 0 &&
                      flags.bigHour === undefined;
              }

              if (Object.isFrozen == null || !Object.isFrozen(m)) {
                  m._isValid = isNowValid;
              }
              else {
                  return isNowValid;
              }
          }
          return m._isValid;
      }

      function createInvalid (flags) {
          var m = createUTC(NaN);
          if (flags != null) {
              extend(getParsingFlags(m), flags);
          }
          else {
              getParsingFlags(m).userInvalidated = true;
          }

          return m;
      }

      // Plugins that add properties should also add the key here (null value),
      // so we can properly clone ourselves.
      var momentProperties = hooks.momentProperties = [];

      function copyConfig(to, from) {
          var i, prop, val;

          if (!isUndefined(from._isAMomentObject)) {
              to._isAMomentObject = from._isAMomentObject;
          }
          if (!isUndefined(from._i)) {
              to._i = from._i;
          }
          if (!isUndefined(from._f)) {
              to._f = from._f;
          }
          if (!isUndefined(from._l)) {
              to._l = from._l;
          }
          if (!isUndefined(from._strict)) {
              to._strict = from._strict;
          }
          if (!isUndefined(from._tzm)) {
              to._tzm = from._tzm;
          }
          if (!isUndefined(from._isUTC)) {
              to._isUTC = from._isUTC;
          }
          if (!isUndefined(from._offset)) {
              to._offset = from._offset;
          }
          if (!isUndefined(from._pf)) {
              to._pf = getParsingFlags(from);
          }
          if (!isUndefined(from._locale)) {
              to._locale = from._locale;
          }

          if (momentProperties.length > 0) {
              for (i = 0; i < momentProperties.length; i++) {
                  prop = momentProperties[i];
                  val = from[prop];
                  if (!isUndefined(val)) {
                      to[prop] = val;
                  }
              }
          }

          return to;
      }

      var updateInProgress = false;

      // Moment prototype object
      function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          if (!this.isValid()) {
              this._d = new Date(NaN);
          }
          // Prevent infinite loop in case updateOffset creates new moment
          // objects.
          if (updateInProgress === false) {
              updateInProgress = true;
              hooks.updateOffset(this);
              updateInProgress = false;
          }
      }

      function isMoment (obj) {
          return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
      }

      function absFloor (number) {
          if (number < 0) {
              // -0 -> 0
              return Math.ceil(number) || 0;
          } else {
              return Math.floor(number);
          }
      }

      function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion,
              value = 0;

          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
              value = absFloor(coercedNumber);
          }

          return value;
      }

      // compare two arrays, return the number of differences
      function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length),
              lengthDiff = Math.abs(array1.length - array2.length),
              diffs = 0,
              i;
          for (i = 0; i < len; i++) {
              if ((dontConvert && array1[i] !== array2[i]) ||
                  (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                  diffs++;
              }
          }
          return diffs + lengthDiff;
      }

      function warn(msg) {
          if (hooks.suppressDeprecationWarnings === false &&
                  (typeof console !==  'undefined') && console.warn) {
              console.warn('Deprecation warning: ' + msg);
          }
      }

      function deprecate(msg, fn) {
          var firstTime = true;

          return extend(function () {
              if (hooks.deprecationHandler != null) {
                  hooks.deprecationHandler(null, msg);
              }
              if (firstTime) {
                  var args = [];
                  var arg;
                  for (var i = 0; i < arguments.length; i++) {
                      arg = '';
                      if (typeof arguments[i] === 'object') {
                          arg += '\n[' + i + '] ';
                          for (var key in arguments[0]) {
                              arg += key + ': ' + arguments[0][key] + ', ';
                          }
                          arg = arg.slice(0, -2); // Remove trailing comma and space
                      } else {
                          arg = arguments[i];
                      }
                      args.push(arg);
                  }
                  warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                  firstTime = false;
              }
              return fn.apply(this, arguments);
          }, fn);
      }

      var deprecations = {};

      function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
              warn(msg);
              deprecations[name] = true;
          }
      }

      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;

      function isFunction(input) {
          return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
      }

      function set (config) {
          var prop, i;
          for (i in config) {
              prop = config[i];
              if (isFunction(prop)) {
                  this[i] = prop;
              } else {
                  this['_' + i] = prop;
              }
          }
          this._config = config;
          // Lenient ordinal parsing accepts just a number in addition to
          // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
          // TODO: Remove "ordinalParse" fallback in next major release.
          this._dayOfMonthOrdinalParseLenient = new RegExp(
              (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                  '|' + (/\d{1,2}/).source);
      }

      function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig), prop;
          for (prop in childConfig) {
              if (hasOwnProp(childConfig, prop)) {
                  if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                      res[prop] = {};
                      extend(res[prop], parentConfig[prop]);
                      extend(res[prop], childConfig[prop]);
                  } else if (childConfig[prop] != null) {
                      res[prop] = childConfig[prop];
                  } else {
                      delete res[prop];
                  }
              }
          }
          for (prop in parentConfig) {
              if (hasOwnProp(parentConfig, prop) &&
                      !hasOwnProp(childConfig, prop) &&
                      isObject(parentConfig[prop])) {
                  // make sure changes to properties don't modify parent config
                  res[prop] = extend({}, res[prop]);
              }
          }
          return res;
      }

      function Locale(config) {
          if (config != null) {
              this.set(config);
          }
      }

      var keys;

      if (Object.keys) {
          keys = Object.keys;
      } else {
          keys = function (obj) {
              var i, res = [];
              for (i in obj) {
                  if (hasOwnProp(obj, i)) {
                      res.push(i);
                  }
              }
              return res;
          };
      }

      var defaultCalendar = {
          sameDay : '[Today at] LT',
          nextDay : '[Tomorrow at] LT',
          nextWeek : 'dddd [at] LT',
          lastDay : '[Yesterday at] LT',
          lastWeek : '[Last] dddd [at] LT',
          sameElse : 'L'
      };

      function calendar (key, mom, now) {
          var output = this._calendar[key] || this._calendar['sameElse'];
          return isFunction(output) ? output.call(mom, now) : output;
      }

      var defaultLongDateFormat = {
          LTS  : 'h:mm:ss A',
          LT   : 'h:mm A',
          L    : 'MM/DD/YYYY',
          LL   : 'MMMM D, YYYY',
          LLL  : 'MMMM D, YYYY h:mm A',
          LLLL : 'dddd, MMMM D, YYYY h:mm A'
      };

      function longDateFormat (key) {
          var format = this._longDateFormat[key],
              formatUpper = this._longDateFormat[key.toUpperCase()];

          if (format || !formatUpper) {
              return format;
          }

          this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
              return val.slice(1);
          });

          return this._longDateFormat[key];
      }

      var defaultInvalidDate = 'Invalid date';

      function invalidDate () {
          return this._invalidDate;
      }

      var defaultOrdinal = '%d';
      var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

      function ordinal (number) {
          return this._ordinal.replace('%d', number);
      }

      var defaultRelativeTime = {
          future : 'in %s',
          past   : '%s ago',
          s  : 'a few seconds',
          ss : '%d seconds',
          m  : 'a minute',
          mm : '%d minutes',
          h  : 'an hour',
          hh : '%d hours',
          d  : 'a day',
          dd : '%d days',
          M  : 'a month',
          MM : '%d months',
          y  : 'a year',
          yy : '%d years'
      };

      function relativeTime (number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return (isFunction(output)) ?
              output(number, withoutSuffix, string, isFuture) :
              output.replace(/%d/i, number);
      }

      function pastFuture (diff, output) {
          var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
          return isFunction(format) ? format(output) : format.replace(/%s/i, output);
      }

      var aliases = {};

      function addUnitAlias (unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
      }

      function normalizeUnits(units) {
          return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
      }

      function normalizeObjectUnits(inputObject) {
          var normalizedInput = {},
              normalizedProp,
              prop;

          for (prop in inputObject) {
              if (hasOwnProp(inputObject, prop)) {
                  normalizedProp = normalizeUnits(prop);
                  if (normalizedProp) {
                      normalizedInput[normalizedProp] = inputObject[prop];
                  }
              }
          }

          return normalizedInput;
      }

      var priorities = {};

      function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
      }

      function getPrioritizedUnits(unitsObj) {
          var units = [];
          for (var u in unitsObj) {
              units.push({unit: u, priority: priorities[u]});
          }
          units.sort(function (a, b) {
              return a.priority - b.priority;
          });
          return units;
      }

      function zeroFill(number, targetLength, forceSign) {
          var absNumber = '' + Math.abs(number),
              zerosToFill = targetLength - absNumber.length,
              sign = number >= 0;
          return (sign ? (forceSign ? '+' : '') : '-') +
              Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }

      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

      var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

      var formatFunctions = {};

      var formatTokenFunctions = {};

      // token:    'M'
      // padded:   ['MM', 2]
      // ordinal:  'Mo'
      // callback: function () { this.month() + 1 }
      function addFormatToken (token, padded, ordinal, callback) {
          var func = callback;
          if (typeof callback === 'string') {
              func = function () {
                  return this[callback]();
              };
          }
          if (token) {
              formatTokenFunctions[token] = func;
          }
          if (padded) {
              formatTokenFunctions[padded[0]] = function () {
                  return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
              };
          }
          if (ordinal) {
              formatTokenFunctions[ordinal] = function () {
                  return this.localeData().ordinal(func.apply(this, arguments), token);
              };
          }
      }

      function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
              return input.replace(/^\[|\]$/g, '');
          }
          return input.replace(/\\/g, '');
      }

      function makeFormatFunction(format) {
          var array = format.match(formattingTokens), i, length;

          for (i = 0, length = array.length; i < length; i++) {
              if (formatTokenFunctions[array[i]]) {
                  array[i] = formatTokenFunctions[array[i]];
              } else {
                  array[i] = removeFormattingTokens(array[i]);
              }
          }

          return function (mom) {
              var output = '', i;
              for (i = 0; i < length; i++) {
                  output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
              }
              return output;
          };
      }

      // format date using native date object
      function formatMoment(m, format) {
          if (!m.isValid()) {
              return m.localeData().invalidDate();
          }

          format = expandFormat(format, m.localeData());
          formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

          return formatFunctions[format](m);
      }

      function expandFormat(format, locale) {
          var i = 5;

          function replaceLongDateFormatTokens(input) {
              return locale.longDateFormat(input) || input;
          }

          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format)) {
              format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
              localFormattingTokens.lastIndex = 0;
              i -= 1;
          }

          return format;
      }

      var match1         = /\d/;            //       0 - 9
      var match2         = /\d\d/;          //      00 - 99
      var match3         = /\d{3}/;         //     000 - 999
      var match4         = /\d{4}/;         //    0000 - 9999
      var match6         = /[+-]?\d{6}/;    // -999999 - 999999
      var match1to2      = /\d\d?/;         //       0 - 99
      var match3to4      = /\d\d\d\d?/;     //     999 - 9999
      var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
      var match1to3      = /\d{1,3}/;       //       0 - 999
      var match1to4      = /\d{1,4}/;       //       0 - 9999
      var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

      var matchUnsigned  = /\d+/;           //       0 - inf
      var matchSigned    = /[+-]?\d+/;      //    -inf - inf

      var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
      var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

      var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

      // any word (or two) characters or numbers including two/three word month in arabic.
      // includes scottish gaelic two word and hyphenated months
      var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

      var regexes = {};

      function addRegexToken (token, regex, strictRegex) {
          regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
              return (isStrict && strictRegex) ? strictRegex : regex;
          };
      }

      function getParseRegexForToken (token, config) {
          if (!hasOwnProp(regexes, token)) {
              return new RegExp(unescapeFormat(token));
          }

          return regexes[token](config._strict, config._locale);
      }

      // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
      function unescapeFormat(s) {
          return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
          }));
      }

      function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      }

      var tokens = {};

      function addParseToken (token, callback) {
          var i, func = callback;
          if (typeof token === 'string') {
              token = [token];
          }
          if (isNumber(callback)) {
              func = function (input, array) {
                  array[callback] = toInt(input);
              };
          }
          for (i = 0; i < token.length; i++) {
              tokens[token[i]] = func;
          }
      }

      function addWeekParseToken (token, callback) {
          addParseToken(token, function (input, array, config, token) {
              config._w = config._w || {};
              callback(input, config._w, config, token);
          });
      }

      function addTimeToArrayFromToken(token, input, config) {
          if (input != null && hasOwnProp(tokens, token)) {
              tokens[token](input, config._a, config, token);
          }
      }

      var YEAR = 0;
      var MONTH = 1;
      var DATE = 2;
      var HOUR = 3;
      var MINUTE = 4;
      var SECOND = 5;
      var MILLISECOND = 6;
      var WEEK = 7;
      var WEEKDAY = 8;

      // FORMATTING

      addFormatToken('Y', 0, 0, function () {
          var y = this.year();
          return y <= 9999 ? '' + y : '+' + y;
      });

      addFormatToken(0, ['YY', 2], 0, function () {
          return this.year() % 100;
      });

      addFormatToken(0, ['YYYY',   4],       0, 'year');
      addFormatToken(0, ['YYYYY',  5],       0, 'year');
      addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

      // ALIASES

      addUnitAlias('year', 'y');

      // PRIORITIES

      addUnitPriority('year', 1);

      // PARSING

      addRegexToken('Y',      matchSigned);
      addRegexToken('YY',     match1to2, match2);
      addRegexToken('YYYY',   match1to4, match4);
      addRegexToken('YYYYY',  match1to6, match6);
      addRegexToken('YYYYYY', match1to6, match6);

      addParseToken(['YYYYY', 'YYYYYY'], YEAR);
      addParseToken('YYYY', function (input, array) {
          array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken('YY', function (input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken('Y', function (input, array) {
          array[YEAR] = parseInt(input, 10);
      });

      // HELPERS

      function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
      }

      function isLeapYear(year) {
          return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
      }

      // HOOKS

      hooks.parseTwoDigitYear = function (input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
      };

      // MOMENTS

      var getSetYear = makeGetSet('FullYear', true);

      function getIsLeapYear () {
          return isLeapYear(this.year());
      }

      function makeGetSet (unit, keepTime) {
          return function (value) {
              if (value != null) {
                  set$1(this, unit, value);
                  hooks.updateOffset(this, keepTime);
                  return this;
              } else {
                  return get(this, unit);
              }
          };
      }

      function get (mom, unit) {
          return mom.isValid() ?
              mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
      }

      function set$1 (mom, unit, value) {
          if (mom.isValid() && !isNaN(value)) {
              if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                  mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
              }
              else {
                  mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
              }
          }
      }

      // MOMENTS

      function stringGet (units) {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
              return this[units]();
          }
          return this;
      }


      function stringSet (units, value) {
          if (typeof units === 'object') {
              units = normalizeObjectUnits(units);
              var prioritized = getPrioritizedUnits(units);
              for (var i = 0; i < prioritized.length; i++) {
                  this[prioritized[i].unit](units[prioritized[i].unit]);
              }
          } else {
              units = normalizeUnits(units);
              if (isFunction(this[units])) {
                  return this[units](value);
              }
          }
          return this;
      }

      function mod(n, x) {
          return ((n % x) + x) % x;
      }

      var indexOf;

      if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
      } else {
          indexOf = function (o) {
              // I know
              var i;
              for (i = 0; i < this.length; ++i) {
                  if (this[i] === o) {
                      return i;
                  }
              }
              return -1;
          };
      }

      function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
              return NaN;
          }
          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
      }

      // FORMATTING

      addFormatToken('M', ['MM', 2], 'Mo', function () {
          return this.month() + 1;
      });

      addFormatToken('MMM', 0, 0, function (format) {
          return this.localeData().monthsShort(this, format);
      });

      addFormatToken('MMMM', 0, 0, function (format) {
          return this.localeData().months(this, format);
      });

      // ALIASES

      addUnitAlias('month', 'M');

      // PRIORITY

      addUnitPriority('month', 8);

      // PARSING

      addRegexToken('M',    match1to2);
      addRegexToken('MM',   match1to2, match2);
      addRegexToken('MMM',  function (isStrict, locale) {
          return locale.monthsShortRegex(isStrict);
      });
      addRegexToken('MMMM', function (isStrict, locale) {
          return locale.monthsRegex(isStrict);
      });

      addParseToken(['M', 'MM'], function (input, array) {
          array[MONTH] = toInt(input) - 1;
      });

      addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
          var month = config._locale.monthsParse(input, token, config._strict);
          // if we didn't find a month name, mark the date as invalid.
          if (month != null) {
              array[MONTH] = month;
          } else {
              getParsingFlags(config).invalidMonth = input;
          }
      });

      // LOCALES

      var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
      var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
      function localeMonths (m, format) {
          if (!m) {
              return isArray(this._months) ? this._months :
                  this._months['standalone'];
          }
          return isArray(this._months) ? this._months[m.month()] :
              this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
      }

      var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
      function localeMonthsShort (m, format) {
          if (!m) {
              return isArray(this._monthsShort) ? this._monthsShort :
                  this._monthsShort['standalone'];
          }
          return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
              this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
      }

      function handleStrictParse(monthName, format, strict) {
          var i, ii, mom, llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
              // this is not used
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
              for (i = 0; i < 12; ++i) {
                  mom = createUTC([2000, i]);
                  this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                  this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
              }
          }

          if (strict) {
              if (format === 'MMM') {
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._longMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              }
          } else {
              if (format === 'MMM') {
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._longMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._longMonthsParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              }
          }
      }

      function localeMonthsParse (monthName, format, strict) {
          var i, mom, regex;

          if (this._monthsParseExact) {
              return handleStrictParse.call(this, monthName, format, strict);
          }

          if (!this._monthsParse) {
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
          }

          // TODO: add sorting
          // Sorting makes sure if one month (or abbr) is a prefix of another
          // see sorting in computeMonthsParse
          for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, i]);
              if (strict && !this._longMonthsParse[i]) {
                  this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                  this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
              }
              if (!strict && !this._monthsParse[i]) {
                  regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                  this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
              }
              // test the regex
              if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                  return i;
              } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                  return i;
              } else if (!strict && this._monthsParse[i].test(monthName)) {
                  return i;
              }
          }
      }

      // MOMENTS

      function setMonth (mom, value) {
          var dayOfMonth;

          if (!mom.isValid()) {
              // No op
              return mom;
          }

          if (typeof value === 'string') {
              if (/^\d+$/.test(value)) {
                  value = toInt(value);
              } else {
                  value = mom.localeData().monthsParse(value);
                  // TODO: Another silent failure?
                  if (!isNumber(value)) {
                      return mom;
                  }
              }
          }

          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
          return mom;
      }

      function getSetMonth (value) {
          if (value != null) {
              setMonth(this, value);
              hooks.updateOffset(this, true);
              return this;
          } else {
              return get(this, 'Month');
          }
      }

      function getDaysInMonth () {
          return daysInMonth(this.year(), this.month());
      }

      var defaultMonthsShortRegex = matchWord;
      function monthsShortRegex (isStrict) {
          if (this._monthsParseExact) {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  computeMonthsParse.call(this);
              }
              if (isStrict) {
                  return this._monthsShortStrictRegex;
              } else {
                  return this._monthsShortRegex;
              }
          } else {
              if (!hasOwnProp(this, '_monthsShortRegex')) {
                  this._monthsShortRegex = defaultMonthsShortRegex;
              }
              return this._monthsShortStrictRegex && isStrict ?
                  this._monthsShortStrictRegex : this._monthsShortRegex;
          }
      }

      var defaultMonthsRegex = matchWord;
      function monthsRegex (isStrict) {
          if (this._monthsParseExact) {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  computeMonthsParse.call(this);
              }
              if (isStrict) {
                  return this._monthsStrictRegex;
              } else {
                  return this._monthsRegex;
              }
          } else {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  this._monthsRegex = defaultMonthsRegex;
              }
              return this._monthsStrictRegex && isStrict ?
                  this._monthsStrictRegex : this._monthsRegex;
          }
      }

      function computeMonthsParse () {
          function cmpLenRev(a, b) {
              return b.length - a.length;
          }

          var shortPieces = [], longPieces = [], mixedPieces = [],
              i, mom;
          for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, i]);
              shortPieces.push(this.monthsShort(mom, ''));
              longPieces.push(this.months(mom, ''));
              mixedPieces.push(this.months(mom, ''));
              mixedPieces.push(this.monthsShort(mom, ''));
          }
          // Sorting makes sure if one month (or abbr) is a prefix of another it
          // will match the longer piece.
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 12; i++) {
              shortPieces[i] = regexEscape(shortPieces[i]);
              longPieces[i] = regexEscape(longPieces[i]);
          }
          for (i = 0; i < 24; i++) {
              mixedPieces[i] = regexEscape(mixedPieces[i]);
          }

          this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
      }

      function createDate (y, m, d, h, M, s, ms) {
          // can't just apply() to create a date:
          // https://stackoverflow.com/q/181348
          var date = new Date(y, m, d, h, M, s, ms);

          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
              date.setFullYear(y);
          }
          return date;
      }

      function createUTCDate (y) {
          var date = new Date(Date.UTC.apply(null, arguments));

          // the Date.UTC function remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
          }
          return date;
      }

      // start-of-first-week - start-of-year
      function firstWeekOffset(year, dow, doy) {
          var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
              fwd = 7 + dow - doy,
              // first-week day local weekday -- which local weekday is fwd
              fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

          return -fwdlw + fwd - 1;
      }

      // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7,
              weekOffset = firstWeekOffset(year, dow, doy),
              dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
              resYear, resDayOfYear;

          if (dayOfYear <= 0) {
              resYear = year - 1;
              resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
              resYear = year + 1;
              resDayOfYear = dayOfYear - daysInYear(year);
          } else {
              resYear = year;
              resDayOfYear = dayOfYear;
          }

          return {
              year: resYear,
              dayOfYear: resDayOfYear
          };
      }

      function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy),
              week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
              resWeek, resYear;

          if (week < 1) {
              resYear = mom.year() - 1;
              resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
              resWeek = week - weeksInYear(mom.year(), dow, doy);
              resYear = mom.year() + 1;
          } else {
              resYear = mom.year();
              resWeek = week;
          }

          return {
              week: resWeek,
              year: resYear
          };
      }

      function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy),
              weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }

      // FORMATTING

      addFormatToken('w', ['ww', 2], 'wo', 'week');
      addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

      // ALIASES

      addUnitAlias('week', 'w');
      addUnitAlias('isoWeek', 'W');

      // PRIORITIES

      addUnitPriority('week', 5);
      addUnitPriority('isoWeek', 5);

      // PARSING

      addRegexToken('w',  match1to2);
      addRegexToken('ww', match1to2, match2);
      addRegexToken('W',  match1to2);
      addRegexToken('WW', match1to2, match2);

      addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
          week[token.substr(0, 1)] = toInt(input);
      });

      // HELPERS

      // LOCALES

      function localeWeek (mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }

      var defaultLocaleWeek = {
          dow : 0, // Sunday is the first day of the week.
          doy : 6  // The week that contains Jan 1st is the first week of the year.
      };

      function localeFirstDayOfWeek () {
          return this._week.dow;
      }

      function localeFirstDayOfYear () {
          return this._week.doy;
      }

      // MOMENTS

      function getSetWeek (input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, 'd');
      }

      function getSetISOWeek (input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, 'd');
      }

      // FORMATTING

      addFormatToken('d', 0, 'do', 'day');

      addFormatToken('dd', 0, 0, function (format) {
          return this.localeData().weekdaysMin(this, format);
      });

      addFormatToken('ddd', 0, 0, function (format) {
          return this.localeData().weekdaysShort(this, format);
      });

      addFormatToken('dddd', 0, 0, function (format) {
          return this.localeData().weekdays(this, format);
      });

      addFormatToken('e', 0, 0, 'weekday');
      addFormatToken('E', 0, 0, 'isoWeekday');

      // ALIASES

      addUnitAlias('day', 'd');
      addUnitAlias('weekday', 'e');
      addUnitAlias('isoWeekday', 'E');

      // PRIORITY
      addUnitPriority('day', 11);
      addUnitPriority('weekday', 11);
      addUnitPriority('isoWeekday', 11);

      // PARSING

      addRegexToken('d',    match1to2);
      addRegexToken('e',    match1to2);
      addRegexToken('E',    match1to2);
      addRegexToken('dd',   function (isStrict, locale) {
          return locale.weekdaysMinRegex(isStrict);
      });
      addRegexToken('ddd',   function (isStrict, locale) {
          return locale.weekdaysShortRegex(isStrict);
      });
      addRegexToken('dddd',   function (isStrict, locale) {
          return locale.weekdaysRegex(isStrict);
      });

      addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
          var weekday = config._locale.weekdaysParse(input, token, config._strict);
          // if we didn't get a weekday name, mark the date as invalid
          if (weekday != null) {
              week.d = weekday;
          } else {
              getParsingFlags(config).invalidWeekday = input;
          }
      });

      addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
          week[token] = toInt(input);
      });

      // HELPERS

      function parseWeekday(input, locale) {
          if (typeof input !== 'string') {
              return input;
          }

          if (!isNaN(input)) {
              return parseInt(input, 10);
          }

          input = locale.weekdaysParse(input);
          if (typeof input === 'number') {
              return input;
          }

          return null;
      }

      function parseIsoWeekday(input, locale) {
          if (typeof input === 'string') {
              return locale.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
      }

      // LOCALES

      var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
      function localeWeekdays (m, format) {
          if (!m) {
              return isArray(this._weekdays) ? this._weekdays :
                  this._weekdays['standalone'];
          }
          return isArray(this._weekdays) ? this._weekdays[m.day()] :
              this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
      }

      var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
      function localeWeekdaysShort (m) {
          return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }

      var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
      function localeWeekdaysMin (m) {
          return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }

      function handleStrictParse$1(weekdayName, format, strict) {
          var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._minWeekdaysParse = [];

              for (i = 0; i < 7; ++i) {
                  mom = createUTC([2000, 1]).day(i);
                  this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                  this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                  this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
              }
          }

          if (strict) {
              if (format === 'dddd') {
                  ii = indexOf.call(this._weekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else if (format === 'ddd') {
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              }
          } else {
              if (format === 'dddd') {
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else if (format === 'ddd') {
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              }
          }
      }

      function localeWeekdaysParse (weekdayName, format, strict) {
          var i, mom, regex;

          if (this._weekdaysParseExact) {
              return handleStrictParse$1.call(this, weekdayName, format, strict);
          }

          if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._minWeekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._fullWeekdaysParse = [];
          }

          for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already

              mom = createUTC([2000, 1]).day(i);
              if (strict && !this._fullWeekdaysParse[i]) {
                  this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                  this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                  this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
              }
              if (!this._weekdaysParse[i]) {
                  regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                  this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
              }
              // test the regex
              if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                  return i;
              } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                  return i;
              } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                  return i;
              } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                  return i;
              }
          }
      }

      // MOMENTS

      function getSetDayOfWeek (input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
              input = parseWeekday(input, this.localeData());
              return this.add(input - day, 'd');
          } else {
              return day;
          }
      }

      function getSetLocaleDayOfWeek (input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, 'd');
      }

      function getSetISODayOfWeek (input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }

          // behaves the same as moment#day except
          // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
          // as a setter, sunday should belong to the previous week.

          if (input != null) {
              var weekday = parseIsoWeekday(input, this.localeData());
              return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
              return this.day() || 7;
          }
      }

      var defaultWeekdaysRegex = matchWord;
      function weekdaysRegex (isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysStrictRegex;
              } else {
                  return this._weekdaysRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  this._weekdaysRegex = defaultWeekdaysRegex;
              }
              return this._weekdaysStrictRegex && isStrict ?
                  this._weekdaysStrictRegex : this._weekdaysRegex;
          }
      }

      var defaultWeekdaysShortRegex = matchWord;
      function weekdaysShortRegex (isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysShortStrictRegex;
              } else {
                  return this._weekdaysShortRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                  this._weekdaysShortRegex = defaultWeekdaysShortRegex;
              }
              return this._weekdaysShortStrictRegex && isStrict ?
                  this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
          }
      }

      var defaultWeekdaysMinRegex = matchWord;
      function weekdaysMinRegex (isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysMinStrictRegex;
              } else {
                  return this._weekdaysMinRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                  this._weekdaysMinRegex = defaultWeekdaysMinRegex;
              }
              return this._weekdaysMinStrictRegex && isStrict ?
                  this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
          }
      }


      function computeWeekdaysParse () {
          function cmpLenRev(a, b) {
              return b.length - a.length;
          }

          var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
              i, mom, minp, shortp, longp;
          for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, 1]).day(i);
              minp = this.weekdaysMin(mom, '');
              shortp = this.weekdaysShort(mom, '');
              longp = this.weekdays(mom, '');
              minPieces.push(minp);
              shortPieces.push(shortp);
              longPieces.push(longp);
              mixedPieces.push(minp);
              mixedPieces.push(shortp);
              mixedPieces.push(longp);
          }
          // Sorting makes sure if one weekday (or abbr) is a prefix of another it
          // will match the longer piece.
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 7; i++) {
              shortPieces[i] = regexEscape(shortPieces[i]);
              longPieces[i] = regexEscape(longPieces[i]);
              mixedPieces[i] = regexEscape(mixedPieces[i]);
          }

          this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;

          this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
          this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
          this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
      }

      // FORMATTING

      function hFormat() {
          return this.hours() % 12 || 12;
      }

      function kFormat() {
          return this.hours() || 24;
      }

      addFormatToken('H', ['HH', 2], 0, 'hour');
      addFormatToken('h', ['hh', 2], 0, hFormat);
      addFormatToken('k', ['kk', 2], 0, kFormat);

      addFormatToken('hmm', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });

      addFormatToken('hmmss', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2);
      });

      addFormatToken('Hmm', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2);
      });

      addFormatToken('Hmmss', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2);
      });

      function meridiem (token, lowercase) {
          addFormatToken(token, 0, 0, function () {
              return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
          });
      }

      meridiem('a', true);
      meridiem('A', false);

      // ALIASES

      addUnitAlias('hour', 'h');

      // PRIORITY
      addUnitPriority('hour', 13);

      // PARSING

      function matchMeridiem (isStrict, locale) {
          return locale._meridiemParse;
      }

      addRegexToken('a',  matchMeridiem);
      addRegexToken('A',  matchMeridiem);
      addRegexToken('H',  match1to2);
      addRegexToken('h',  match1to2);
      addRegexToken('k',  match1to2);
      addRegexToken('HH', match1to2, match2);
      addRegexToken('hh', match1to2, match2);
      addRegexToken('kk', match1to2, match2);

      addRegexToken('hmm', match3to4);
      addRegexToken('hmmss', match5to6);
      addRegexToken('Hmm', match3to4);
      addRegexToken('Hmmss', match5to6);

      addParseToken(['H', 'HH'], HOUR);
      addParseToken(['k', 'kk'], function (input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(['a', 'A'], function (input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
      });
      addParseToken(['h', 'hh'], function (input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmmss', function (input, array, config) {
          var pos1 = input.length - 4;
          var pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('Hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken('Hmmss', function (input, array, config) {
          var pos1 = input.length - 4;
          var pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
      });

      // LOCALES

      function localeIsPM (input) {
          // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
          // Using charAt should be more compatible.
          return ((input + '').toLowerCase().charAt(0) === 'p');
      }

      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
      function localeMeridiem (hours, minutes, isLower) {
          if (hours > 11) {
              return isLower ? 'pm' : 'PM';
          } else {
              return isLower ? 'am' : 'AM';
          }
      }


      // MOMENTS

      // Setting the hour should keep the time, because the user explicitly
      // specified which hour they want. So trying to maintain the same hour (in
      // a new timezone) makes sense. Adding/subtracting hours does not follow
      // this rule.
      var getSetHour = makeGetSet('Hours', true);

      var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,

          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,

          week: defaultLocaleWeek,

          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,

          meridiemParse: defaultLocaleMeridiemParse
      };

      // internal storage for locale config files
      var locales = {};
      var localeFamilies = {};
      var globalLocale;

      function normalizeLocale(key) {
          return key ? key.toLowerCase().replace('_', '-') : key;
      }

      // pick the locale from the array
      // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
      // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
      function chooseLocale(names) {
          var i = 0, j, next, locale, split;

          while (i < names.length) {
              split = normalizeLocale(names[i]).split('-');
              j = split.length;
              next = normalizeLocale(names[i + 1]);
              next = next ? next.split('-') : null;
              while (j > 0) {
                  locale = loadLocale(split.slice(0, j).join('-'));
                  if (locale) {
                      return locale;
                  }
                  if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                      //the next array item is better than a shallower substring of this one
                      break;
                  }
                  j--;
              }
              i++;
          }
          return globalLocale;
      }

      function loadLocale(name) {
          var oldLocale = null;
          // TODO: Find a better way to register and load all the locales in Node
          if (!locales[name] && ('object' !== 'undefined') &&
                  module && module.exports) {
              try {
                  oldLocale = globalLocale._abbr;
                  var aliasedRequire = commonjsRequire;
                  aliasedRequire('./locale/' + name);
                  getSetGlobalLocale(oldLocale);
              } catch (e) {}
          }
          return locales[name];
      }

      // This function will load locale and then set the global locale.  If
      // no arguments are passed in, it will simply return the current global
      // locale key.
      function getSetGlobalLocale (key, values) {
          var data;
          if (key) {
              if (isUndefined(values)) {
                  data = getLocale(key);
              }
              else {
                  data = defineLocale(key, values);
              }

              if (data) {
                  // moment.duration._locale = moment._locale = data;
                  globalLocale = data;
              }
              else {
                  if ((typeof console !==  'undefined') && console.warn) {
                      //warn user if arguments are passed but the locale could not be set
                      console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                  }
              }
          }

          return globalLocale._abbr;
      }

      function defineLocale (name, config) {
          if (config !== null) {
              var locale, parentConfig = baseConfig;
              config.abbr = name;
              if (locales[name] != null) {
                  deprecateSimple('defineLocaleOverride',
                          'use moment.updateLocale(localeName, config) to change ' +
                          'an existing locale. moment.defineLocale(localeName, ' +
                          'config) should only be used for creating a new locale ' +
                          'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                  parentConfig = locales[name]._config;
              } else if (config.parentLocale != null) {
                  if (locales[config.parentLocale] != null) {
                      parentConfig = locales[config.parentLocale]._config;
                  } else {
                      locale = loadLocale(config.parentLocale);
                      if (locale != null) {
                          parentConfig = locale._config;
                      } else {
                          if (!localeFamilies[config.parentLocale]) {
                              localeFamilies[config.parentLocale] = [];
                          }
                          localeFamilies[config.parentLocale].push({
                              name: name,
                              config: config
                          });
                          return null;
                      }
                  }
              }
              locales[name] = new Locale(mergeConfigs(parentConfig, config));

              if (localeFamilies[name]) {
                  localeFamilies[name].forEach(function (x) {
                      defineLocale(x.name, x.config);
                  });
              }

              // backwards compat for now: also set the locale
              // make sure we set the locale AFTER all child locales have been
              // created, so we won't end up with the child locale set.
              getSetGlobalLocale(name);


              return locales[name];
          } else {
              // useful for testing
              delete locales[name];
              return null;
          }
      }

      function updateLocale(name, config) {
          if (config != null) {
              var locale, tmpLocale, parentConfig = baseConfig;
              // MERGE
              tmpLocale = loadLocale(name);
              if (tmpLocale != null) {
                  parentConfig = tmpLocale._config;
              }
              config = mergeConfigs(parentConfig, config);
              locale = new Locale(config);
              locale.parentLocale = locales[name];
              locales[name] = locale;

              // backwards compat for now: also set the locale
              getSetGlobalLocale(name);
          } else {
              // pass null for config to unupdate, useful for tests
              if (locales[name] != null) {
                  if (locales[name].parentLocale != null) {
                      locales[name] = locales[name].parentLocale;
                  } else if (locales[name] != null) {
                      delete locales[name];
                  }
              }
          }
          return locales[name];
      }

      // returns locale data
      function getLocale (key) {
          var locale;

          if (key && key._locale && key._locale._abbr) {
              key = key._locale._abbr;
          }

          if (!key) {
              return globalLocale;
          }

          if (!isArray(key)) {
              //short-circuit everything else
              locale = loadLocale(key);
              if (locale) {
                  return locale;
              }
              key = [key];
          }

          return chooseLocale(key);
      }

      function listLocales() {
          return keys(locales);
      }

      function checkOverflow (m) {
          var overflow;
          var a = m._a;

          if (a && getParsingFlags(m).overflow === -2) {
              overflow =
                  a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                  a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                  a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                  a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                  a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                  a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                  -1;

              if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                  overflow = DATE;
              }
              if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                  overflow = WEEK;
              }
              if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                  overflow = WEEKDAY;
              }

              getParsingFlags(m).overflow = overflow;
          }

          return m;
      }

      // Pick the first defined of two or three arguments.
      function defaults(a, b, c) {
          if (a != null) {
              return a;
          }
          if (b != null) {
              return b;
          }
          return c;
      }

      function currentDateArray(config) {
          // hooks is actually the exported moment object
          var nowValue = new Date(hooks.now());
          if (config._useUTC) {
              return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }

      // convert an array to a date.
      // the array should mirror the parameters below
      // note: all values past the year are optional and will default to the lowest possible value.
      // [year, month, day , hour, minute, second, millisecond]
      function configFromArray (config) {
          var i, date, input = [], currentDate, expectedWeekday, yearToUse;

          if (config._d) {
              return;
          }

          currentDate = currentDateArray(config);

          //compute day of the year from weeks and weekdays
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
              dayOfYearFromWeekInfo(config);
          }

          //if the day of the year is set, figure out what it is
          if (config._dayOfYear != null) {
              yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

              if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                  getParsingFlags(config)._overflowDayOfYear = true;
              }

              date = createUTCDate(yearToUse, 0, config._dayOfYear);
              config._a[MONTH] = date.getUTCMonth();
              config._a[DATE] = date.getUTCDate();
          }

          // Default to current date.
          // * if no year, month, day of month are given, default to today
          // * if day of month is given, default month and year
          // * if month is given, default only year
          // * if year is given, don't default anything
          for (i = 0; i < 3 && config._a[i] == null; ++i) {
              config._a[i] = input[i] = currentDate[i];
          }

          // Zero out whatever was not defaulted, including time
          for (; i < 7; i++) {
              config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
          }

          // Check for 24:00:00.000
          if (config._a[HOUR] === 24 &&
                  config._a[MINUTE] === 0 &&
                  config._a[SECOND] === 0 &&
                  config._a[MILLISECOND] === 0) {
              config._nextDay = true;
              config._a[HOUR] = 0;
          }

          config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
          expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

          // Apply timezone offset from input. The actual utcOffset can be changed
          // with parseZone.
          if (config._tzm != null) {
              config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }

          if (config._nextDay) {
              config._a[HOUR] = 24;
          }

          // check for mismatching day of week
          if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
              getParsingFlags(config).weekdayMismatch = true;
          }
      }

      function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
              dow = 1;
              doy = 4;

              // TODO: We need to take the current isoWeekYear, but that depends on
              // how we interpret now (local, utc, fixed offset). So create
              // a now version of current config (take local/utc/offset flags, and
              // create now).
              weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
              week = defaults(w.W, 1);
              weekday = defaults(w.E, 1);
              if (weekday < 1 || weekday > 7) {
                  weekdayOverflow = true;
              }
          } else {
              dow = config._locale._week.dow;
              doy = config._locale._week.doy;

              var curWeek = weekOfYear(createLocal(), dow, doy);

              weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

              // Default to current week.
              week = defaults(w.w, curWeek.week);

              if (w.d != null) {
                  // weekday -- low day numbers are considered next week
                  weekday = w.d;
                  if (weekday < 0 || weekday > 6) {
                      weekdayOverflow = true;
                  }
              } else if (w.e != null) {
                  // local weekday -- counting starts from begining of week
                  weekday = w.e + dow;
                  if (w.e < 0 || w.e > 6) {
                      weekdayOverflow = true;
                  }
              } else {
                  // default to begining of week
                  weekday = dow;
              }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
              getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
              getParsingFlags(config)._overflowWeekday = true;
          } else {
              temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
              config._a[YEAR] = temp.year;
              config._dayOfYear = temp.dayOfYear;
          }
      }

      // iso 8601 regex
      // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
      var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

      var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

      var isoDates = [
          ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
          ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
          ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
          ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
          ['YYYY-DDD', /\d{4}-\d{3}/],
          ['YYYY-MM', /\d{4}-\d\d/, false],
          ['YYYYYYMMDD', /[+-]\d{10}/],
          ['YYYYMMDD', /\d{8}/],
          // YYYYMM is NOT allowed by the standard
          ['GGGG[W]WWE', /\d{4}W\d{3}/],
          ['GGGG[W]WW', /\d{4}W\d{2}/, false],
          ['YYYYDDD', /\d{7}/]
      ];

      // iso time formats and regexes
      var isoTimes = [
          ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
          ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
          ['HH:mm:ss', /\d\d:\d\d:\d\d/],
          ['HH:mm', /\d\d:\d\d/],
          ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
          ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
          ['HHmmss', /\d\d\d\d\d\d/],
          ['HHmm', /\d\d\d\d/],
          ['HH', /\d\d/]
      ];

      var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

      // date from iso format
      function configFromISO(config) {
          var i, l,
              string = config._i,
              match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
              allowTime, dateFormat, timeFormat, tzFormat;

          if (match) {
              getParsingFlags(config).iso = true;

              for (i = 0, l = isoDates.length; i < l; i++) {
                  if (isoDates[i][1].exec(match[1])) {
                      dateFormat = isoDates[i][0];
                      allowTime = isoDates[i][2] !== false;
                      break;
                  }
              }
              if (dateFormat == null) {
                  config._isValid = false;
                  return;
              }
              if (match[3]) {
                  for (i = 0, l = isoTimes.length; i < l; i++) {
                      if (isoTimes[i][1].exec(match[3])) {
                          // match[2] should be 'T' or space
                          timeFormat = (match[2] || ' ') + isoTimes[i][0];
                          break;
                      }
                  }
                  if (timeFormat == null) {
                      config._isValid = false;
                      return;
                  }
              }
              if (!allowTime && timeFormat != null) {
                  config._isValid = false;
                  return;
              }
              if (match[4]) {
                  if (tzRegex.exec(match[4])) {
                      tzFormat = 'Z';
                  } else {
                      config._isValid = false;
                      return;
                  }
              }
              config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
              configFromStringAndFormat(config);
          } else {
              config._isValid = false;
          }
      }

      // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
      var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
          var result = [
              untruncateYear(yearStr),
              defaultLocaleMonthsShort.indexOf(monthStr),
              parseInt(dayStr, 10),
              parseInt(hourStr, 10),
              parseInt(minuteStr, 10)
          ];

          if (secondStr) {
              result.push(parseInt(secondStr, 10));
          }

          return result;
      }

      function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
              return 2000 + year;
          } else if (year <= 999) {
              return 1900 + year;
          }
          return year;
      }

      function preprocessRFC2822(s) {
          // Remove comments and folding whitespace and replace multiple-spaces with a single space
          return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
      }

      function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
              // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
              var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                  weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
              if (weekdayProvided !== weekdayActual) {
                  getParsingFlags(config).weekdayMismatch = true;
                  config._isValid = false;
                  return false;
              }
          }
          return true;
      }

      var obsOffsets = {
          UT: 0,
          GMT: 0,
          EDT: -4 * 60,
          EST: -5 * 60,
          CDT: -5 * 60,
          CST: -6 * 60,
          MDT: -6 * 60,
          MST: -7 * 60,
          PDT: -7 * 60,
          PST: -8 * 60
      };

      function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
              return obsOffsets[obsOffset];
          } else if (militaryOffset) {
              // the only allowed military tz is Z
              return 0;
          } else {
              var hm = parseInt(numOffset, 10);
              var m = hm % 100, h = (hm - m) / 100;
              return h * 60 + m;
          }
      }

      // date and time from ref 2822 format
      function configFromRFC2822(config) {
          var match = rfc2822.exec(preprocessRFC2822(config._i));
          if (match) {
              var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
              if (!checkWeekday(match[1], parsedArray, config)) {
                  return;
              }

              config._a = parsedArray;
              config._tzm = calculateOffset(match[8], match[9], match[10]);

              config._d = createUTCDate.apply(null, config._a);
              config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

              getParsingFlags(config).rfc2822 = true;
          } else {
              config._isValid = false;
          }
      }

      // date from iso format or fallback
      function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);

          if (matched !== null) {
              config._d = new Date(+matched[1]);
              return;
          }

          configFromISO(config);
          if (config._isValid === false) {
              delete config._isValid;
          } else {
              return;
          }

          configFromRFC2822(config);
          if (config._isValid === false) {
              delete config._isValid;
          } else {
              return;
          }

          // Final attempt, use Input Fallback
          hooks.createFromInputFallback(config);
      }

      hooks.createFromInputFallback = deprecate(
          'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
          'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
          'discouraged and will be removed in an upcoming major release. Please refer to ' +
          'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
          function (config) {
              config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
          }
      );

      // constant that refers to the ISO standard
      hooks.ISO_8601 = function () {};

      // constant that refers to the RFC 2822 form
      hooks.RFC_2822 = function () {};

      // date from string and format string
      function configFromStringAndFormat(config) {
          // TODO: Move this to another part of the creation flow to prevent circular deps
          if (config._f === hooks.ISO_8601) {
              configFromISO(config);
              return;
          }
          if (config._f === hooks.RFC_2822) {
              configFromRFC2822(config);
              return;
          }
          config._a = [];
          getParsingFlags(config).empty = true;

          // This array is used to make a Date, either with `new Date` or `Date.UTC`
          var string = '' + config._i,
              i, parsedInput, tokens, token, skipped,
              stringLength = string.length,
              totalParsedInputLength = 0;

          tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

          for (i = 0; i < tokens.length; i++) {
              token = tokens[i];
              parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
              // console.log('token', token, 'parsedInput', parsedInput,
              //         'regex', getParseRegexForToken(token, config));
              if (parsedInput) {
                  skipped = string.substr(0, string.indexOf(parsedInput));
                  if (skipped.length > 0) {
                      getParsingFlags(config).unusedInput.push(skipped);
                  }
                  string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                  totalParsedInputLength += parsedInput.length;
              }
              // don't parse if it's not a known token
              if (formatTokenFunctions[token]) {
                  if (parsedInput) {
                      getParsingFlags(config).empty = false;
                  }
                  else {
                      getParsingFlags(config).unusedTokens.push(token);
                  }
                  addTimeToArrayFromToken(token, parsedInput, config);
              }
              else if (config._strict && !parsedInput) {
                  getParsingFlags(config).unusedTokens.push(token);
              }
          }

          // add remaining unparsed input length to the string
          getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
          if (string.length > 0) {
              getParsingFlags(config).unusedInput.push(string);
          }

          // clear _12h flag if hour is <= 12
          if (config._a[HOUR] <= 12 &&
              getParsingFlags(config).bigHour === true &&
              config._a[HOUR] > 0) {
              getParsingFlags(config).bigHour = undefined;
          }

          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          // handle meridiem
          config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

          configFromArray(config);
          checkOverflow(config);
      }


      function meridiemFixWrap (locale, hour, meridiem) {
          var isPm;

          if (meridiem == null) {
              // nothing to do
              return hour;
          }
          if (locale.meridiemHour != null) {
              return locale.meridiemHour(hour, meridiem);
          } else if (locale.isPM != null) {
              // Fallback
              isPm = locale.isPM(meridiem);
              if (isPm && hour < 12) {
                  hour += 12;
              }
              if (!isPm && hour === 12) {
                  hour = 0;
              }
              return hour;
          } else {
              // this is not supposed to happen
              return hour;
          }
      }

      // date from string and array of format strings
      function configFromStringAndArray(config) {
          var tempConfig,
              bestMoment,

              scoreToBeat,
              i,
              currentScore;

          if (config._f.length === 0) {
              getParsingFlags(config).invalidFormat = true;
              config._d = new Date(NaN);
              return;
          }

          for (i = 0; i < config._f.length; i++) {
              currentScore = 0;
              tempConfig = copyConfig({}, config);
              if (config._useUTC != null) {
                  tempConfig._useUTC = config._useUTC;
              }
              tempConfig._f = config._f[i];
              configFromStringAndFormat(tempConfig);

              if (!isValid(tempConfig)) {
                  continue;
              }

              // if there is any input that was not parsed add a penalty for that format
              currentScore += getParsingFlags(tempConfig).charsLeftOver;

              //or tokens
              currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

              getParsingFlags(tempConfig).score = currentScore;

              if (scoreToBeat == null || currentScore < scoreToBeat) {
                  scoreToBeat = currentScore;
                  bestMoment = tempConfig;
              }
          }

          extend(config, bestMoment || tempConfig);
      }

      function configFromObject(config) {
          if (config._d) {
              return;
          }

          var i = normalizeObjectUnits(config._i);
          config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
              return obj && parseInt(obj, 10);
          });

          configFromArray(config);
      }

      function createFromConfig (config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
              // Adding is smart enough around DST
              res.add(1, 'd');
              res._nextDay = undefined;
          }

          return res;
      }

      function prepareConfig (config) {
          var input = config._i,
              format = config._f;

          config._locale = config._locale || getLocale(config._l);

          if (input === null || (format === undefined && input === '')) {
              return createInvalid({nullInput: true});
          }

          if (typeof input === 'string') {
              config._i = input = config._locale.preparse(input);
          }

          if (isMoment(input)) {
              return new Moment(checkOverflow(input));
          } else if (isDate(input)) {
              config._d = input;
          } else if (isArray(format)) {
              configFromStringAndArray(config);
          } else if (format) {
              configFromStringAndFormat(config);
          }  else {
              configFromInput(config);
          }

          if (!isValid(config)) {
              config._d = null;
          }

          return config;
      }

      function configFromInput(config) {
          var input = config._i;
          if (isUndefined(input)) {
              config._d = new Date(hooks.now());
          } else if (isDate(input)) {
              config._d = new Date(input.valueOf());
          } else if (typeof input === 'string') {
              configFromString(config);
          } else if (isArray(input)) {
              config._a = map(input.slice(0), function (obj) {
                  return parseInt(obj, 10);
              });
              configFromArray(config);
          } else if (isObject(input)) {
              configFromObject(config);
          } else if (isNumber(input)) {
              // from milliseconds
              config._d = new Date(input);
          } else {
              hooks.createFromInputFallback(config);
          }
      }

      function createLocalOrUTC (input, format, locale, strict, isUTC) {
          var c = {};

          if (locale === true || locale === false) {
              strict = locale;
              locale = undefined;
          }

          if ((isObject(input) && isObjectEmpty(input)) ||
                  (isArray(input) && input.length === 0)) {
              input = undefined;
          }
          // object construction must be done this way.
          // https://github.com/moment/moment/issues/1423
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale;
          c._i = input;
          c._f = format;
          c._strict = strict;

          return createFromConfig(c);
      }

      function createLocal (input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, false);
      }

      var prototypeMin = deprecate(
          'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
          function () {
              var other = createLocal.apply(null, arguments);
              if (this.isValid() && other.isValid()) {
                  return other < this ? this : other;
              } else {
                  return createInvalid();
              }
          }
      );

      var prototypeMax = deprecate(
          'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
          function () {
              var other = createLocal.apply(null, arguments);
              if (this.isValid() && other.isValid()) {
                  return other > this ? this : other;
              } else {
                  return createInvalid();
              }
          }
      );

      // Pick a moment m from moments so that m[fn](other) is true for all
      // other. This relies on the function fn to be transitive.
      //
      // moments should either be an array of moment objects or an array, whose
      // first element is an array of moment objects.
      function pickBy(fn, moments) {
          var res, i;
          if (moments.length === 1 && isArray(moments[0])) {
              moments = moments[0];
          }
          if (!moments.length) {
              return createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
              if (!moments[i].isValid() || moments[i][fn](res)) {
                  res = moments[i];
              }
          }
          return res;
      }

      // TODO: Use [].sort instead?
      function min () {
          var args = [].slice.call(arguments, 0);

          return pickBy('isBefore', args);
      }

      function max () {
          var args = [].slice.call(arguments, 0);

          return pickBy('isAfter', args);
      }

      var now = function () {
          return Date.now ? Date.now() : +(new Date());
      };

      var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

      function isDurationValid(m) {
          for (var key in m) {
              if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                  return false;
              }
          }

          var unitHasDecimal = false;
          for (var i = 0; i < ordering.length; ++i) {
              if (m[ordering[i]]) {
                  if (unitHasDecimal) {
                      return false; // only allow non-integers for smallest unit
                  }
                  if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                      unitHasDecimal = true;
                  }
              }
          }

          return true;
      }

      function isValid$1() {
          return this._isValid;
      }

      function createInvalid$1() {
          return createDuration(NaN);
      }

      function Duration (duration) {
          var normalizedInput = normalizeObjectUnits(duration),
              years = normalizedInput.year || 0,
              quarters = normalizedInput.quarter || 0,
              months = normalizedInput.month || 0,
              weeks = normalizedInput.week || 0,
              days = normalizedInput.day || 0,
              hours = normalizedInput.hour || 0,
              minutes = normalizedInput.minute || 0,
              seconds = normalizedInput.second || 0,
              milliseconds = normalizedInput.millisecond || 0;

          this._isValid = isDurationValid(normalizedInput);

          // representation for dateAddRemove
          this._milliseconds = +milliseconds +
              seconds * 1e3 + // 1000
              minutes * 6e4 + // 1000 * 60
              hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
          // Because of dateAddRemove treats 24 hours as different from a
          // day when working around DST, we need to store them separately
          this._days = +days +
              weeks * 7;
          // It is impossible to translate months into days without knowing
          // which months you are are talking about, so we have to store
          // it separately.
          this._months = +months +
              quarters * 3 +
              years * 12;

          this._data = {};

          this._locale = getLocale();

          this._bubble();
      }

      function isDuration (obj) {
          return obj instanceof Duration;
      }

      function absRound (number) {
          if (number < 0) {
              return Math.round(-1 * number) * -1;
          } else {
              return Math.round(number);
          }
      }

      // FORMATTING

      function offset (token, separator) {
          addFormatToken(token, 0, 0, function () {
              var offset = this.utcOffset();
              var sign = '+';
              if (offset < 0) {
                  offset = -offset;
                  sign = '-';
              }
              return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
          });
      }

      offset('Z', ':');
      offset('ZZ', '');

      // PARSING

      addRegexToken('Z',  matchShortOffset);
      addRegexToken('ZZ', matchShortOffset);
      addParseToken(['Z', 'ZZ'], function (input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
      });

      // HELPERS

      // timezone chunker
      // '+10:00' > ['10',  '00']
      // '-1530'  > ['-15', '30']
      var chunkOffset = /([\+\-]|\d\d)/gi;

      function offsetFromString(matcher, string) {
          var matches = (string || '').match(matcher);

          if (matches === null) {
              return null;
          }

          var chunk   = matches[matches.length - 1] || [];
          var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
          var minutes = +(parts[1] * 60) + toInt(parts[2]);

          return minutes === 0 ?
            0 :
            parts[0] === '+' ? minutes : -minutes;
      }

      // Return a moment from input, that is local/utc/zone equivalent to model.
      function cloneWithOffset(input, model) {
          var res, diff;
          if (model._isUTC) {
              res = model.clone();
              diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
              // Use low-level api, because this fn is low-level api.
              res._d.setTime(res._d.valueOf() + diff);
              hooks.updateOffset(res, false);
              return res;
          } else {
              return createLocal(input).local();
          }
      }

      function getDateOffset (m) {
          // On Firefox.24 Date#getTimezoneOffset returns a floating point.
          // https://github.com/moment/moment/pull/1871
          return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
      }

      // HOOKS

      // This function will be called whenever a moment is mutated.
      // It is intended to keep the offset in sync with the timezone.
      hooks.updateOffset = function () {};

      // MOMENTS

      // keepLocalTime = true means only change the timezone, without
      // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
      // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
      // +0200, so we adjust the time as needed, to be valid.
      //
      // Keeping the time actually adds/subtracts (one hour)
      // from the actual represented time. That is why we call updateOffset
      // a second time. In case it wants us to change the offset again
      // _changeInProgress == true case, then we have to adjust, because
      // there is no such time in the given timezone.
      function getSetOffset (input, keepLocalTime, keepMinutes) {
          var offset = this._offset || 0,
              localAdjust;
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          if (input != null) {
              if (typeof input === 'string') {
                  input = offsetFromString(matchShortOffset, input);
                  if (input === null) {
                      return this;
                  }
              } else if (Math.abs(input) < 16 && !keepMinutes) {
                  input = input * 60;
              }
              if (!this._isUTC && keepLocalTime) {
                  localAdjust = getDateOffset(this);
              }
              this._offset = input;
              this._isUTC = true;
              if (localAdjust != null) {
                  this.add(localAdjust, 'm');
              }
              if (offset !== input) {
                  if (!keepLocalTime || this._changeInProgress) {
                      addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                  } else if (!this._changeInProgress) {
                      this._changeInProgress = true;
                      hooks.updateOffset(this, true);
                      this._changeInProgress = null;
                  }
              }
              return this;
          } else {
              return this._isUTC ? offset : getDateOffset(this);
          }
      }

      function getSetZone (input, keepLocalTime) {
          if (input != null) {
              if (typeof input !== 'string') {
                  input = -input;
              }

              this.utcOffset(input, keepLocalTime);

              return this;
          } else {
              return -this.utcOffset();
          }
      }

      function setOffsetToUTC (keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
      }

      function setOffsetToLocal (keepLocalTime) {
          if (this._isUTC) {
              this.utcOffset(0, keepLocalTime);
              this._isUTC = false;

              if (keepLocalTime) {
                  this.subtract(getDateOffset(this), 'm');
              }
          }
          return this;
      }

      function setOffsetToParsedOffset () {
          if (this._tzm != null) {
              this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === 'string') {
              var tZone = offsetFromString(matchOffset, this._i);
              if (tZone != null) {
                  this.utcOffset(tZone);
              }
              else {
                  this.utcOffset(0, true);
              }
          }
          return this;
      }

      function hasAlignedHourOffset (input) {
          if (!this.isValid()) {
              return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;

          return (this.utcOffset() - input) % 60 === 0;
      }

      function isDaylightSavingTime () {
          return (
              this.utcOffset() > this.clone().month(0).utcOffset() ||
              this.utcOffset() > this.clone().month(5).utcOffset()
          );
      }

      function isDaylightSavingTimeShifted () {
          if (!isUndefined(this._isDSTShifted)) {
              return this._isDSTShifted;
          }

          var c = {};

          copyConfig(c, this);
          c = prepareConfig(c);

          if (c._a) {
              var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
              this._isDSTShifted = this.isValid() &&
                  compareArrays(c._a, other.toArray()) > 0;
          } else {
              this._isDSTShifted = false;
          }

          return this._isDSTShifted;
      }

      function isLocal () {
          return this.isValid() ? !this._isUTC : false;
      }

      function isUtcOffset () {
          return this.isValid() ? this._isUTC : false;
      }

      function isUtc () {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }

      // ASP.NET json date format regex
      var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

      // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
      // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
      // and further modified to allow for strings containing both week and day
      var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

      function createDuration (input, key) {
          var duration = input,
              // matching against regexp is expensive, do it on demand
              match = null,
              sign,
              ret,
              diffRes;

          if (isDuration(input)) {
              duration = {
                  ms : input._milliseconds,
                  d  : input._days,
                  M  : input._months
              };
          } else if (isNumber(input)) {
              duration = {};
              if (key) {
                  duration[key] = input;
              } else {
                  duration.milliseconds = input;
              }
          } else if (!!(match = aspNetRegex.exec(input))) {
              sign = (match[1] === '-') ? -1 : 1;
              duration = {
                  y  : 0,
                  d  : toInt(match[DATE])                         * sign,
                  h  : toInt(match[HOUR])                         * sign,
                  m  : toInt(match[MINUTE])                       * sign,
                  s  : toInt(match[SECOND])                       * sign,
                  ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
              };
          } else if (!!(match = isoRegex.exec(input))) {
              sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
              duration = {
                  y : parseIso(match[2], sign),
                  M : parseIso(match[3], sign),
                  w : parseIso(match[4], sign),
                  d : parseIso(match[5], sign),
                  h : parseIso(match[6], sign),
                  m : parseIso(match[7], sign),
                  s : parseIso(match[8], sign)
              };
          } else if (duration == null) {// checks for null or undefined
              duration = {};
          } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
              diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

              duration = {};
              duration.ms = diffRes.milliseconds;
              duration.M = diffRes.months;
          }

          ret = new Duration(duration);

          if (isDuration(input) && hasOwnProp(input, '_locale')) {
              ret._locale = input._locale;
          }

          return ret;
      }

      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;

      function parseIso (inp, sign) {
          // We'd normally use ~~inp for this, but unfortunately it also
          // converts floats to ints.
          // inp may be undefined, so careful calling replace on it.
          var res = inp && parseFloat(inp.replace(',', '.'));
          // apply sign while we're at it
          return (isNaN(res) ? 0 : res) * sign;
      }

      function positiveMomentsDifference(base, other) {
          var res = {milliseconds: 0, months: 0};

          res.months = other.month() - base.month() +
              (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, 'M').isAfter(other)) {
              --res.months;
          }

          res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

          return res;
      }

      function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
              return {milliseconds: 0, months: 0};
          }

          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
              res = positiveMomentsDifference(base, other);
          } else {
              res = positiveMomentsDifference(other, base);
              res.milliseconds = -res.milliseconds;
              res.months = -res.months;
          }

          return res;
      }

      // TODO: remove 'name' arg after deprecation is removed
      function createAdder(direction, name) {
          return function (val, period) {
              var dur, tmp;
              //invert the arguments, but complain about it
              if (period !== null && !isNaN(+period)) {
                  deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                  'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                  tmp = val; val = period; period = tmp;
              }

              val = typeof val === 'string' ? +val : val;
              dur = createDuration(val, period);
              addSubtract(this, dur, direction);
              return this;
          };
      }

      function addSubtract (mom, duration, isAdding, updateOffset) {
          var milliseconds = duration._milliseconds,
              days = absRound(duration._days),
              months = absRound(duration._months);

          if (!mom.isValid()) {
              // No op
              return;
          }

          updateOffset = updateOffset == null ? true : updateOffset;

          if (months) {
              setMonth(mom, get(mom, 'Month') + months * isAdding);
          }
          if (days) {
              set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
          }
          if (milliseconds) {
              mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
          }
          if (updateOffset) {
              hooks.updateOffset(mom, days || months);
          }
      }

      var add      = createAdder(1, 'add');
      var subtract = createAdder(-1, 'subtract');

      function getCalendarFormat(myMoment, now) {
          var diff = myMoment.diff(now, 'days', true);
          return diff < -6 ? 'sameElse' :
                  diff < -1 ? 'lastWeek' :
                  diff < 0 ? 'lastDay' :
                  diff < 1 ? 'sameDay' :
                  diff < 2 ? 'nextDay' :
                  diff < 7 ? 'nextWeek' : 'sameElse';
      }

      function calendar$1 (time, formats) {
          // We want to compare the start of today, vs this.
          // Getting start-of-today depends on whether we're local/utc/offset or not.
          var now = time || createLocal(),
              sod = cloneWithOffset(now, this).startOf('day'),
              format = hooks.calendarFormat(this, sod) || 'sameElse';

          var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

          return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
      }

      function clone () {
          return new Moment(this);
      }

      function isAfter (input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
          if (units === 'millisecond') {
              return this.valueOf() > localInput.valueOf();
          } else {
              return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
      }

      function isBefore (input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
          if (units === 'millisecond') {
              return this.valueOf() < localInput.valueOf();
          } else {
              return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
      }

      function isBetween (from, to, units, inclusivity) {
          inclusivity = inclusivity || '()';
          return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
              (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
      }

      function isSame (input, units) {
          var localInput = isMoment(input) ? input : createLocal(input),
              inputMs;
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(units || 'millisecond');
          if (units === 'millisecond') {
              return this.valueOf() === localInput.valueOf();
          } else {
              inputMs = localInput.valueOf();
              return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
          }
      }

      function isSameOrAfter (input, units) {
          return this.isSame(input, units) || this.isAfter(input,units);
      }

      function isSameOrBefore (input, units) {
          return this.isSame(input, units) || this.isBefore(input,units);
      }

      function diff (input, units, asFloat) {
          var that,
              zoneDelta,
              output;

          if (!this.isValid()) {
              return NaN;
          }

          that = cloneWithOffset(input, this);

          if (!that.isValid()) {
              return NaN;
          }

          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

          units = normalizeUnits(units);

          switch (units) {
              case 'year': output = monthDiff(this, that) / 12; break;
              case 'month': output = monthDiff(this, that); break;
              case 'quarter': output = monthDiff(this, that) / 3; break;
              case 'second': output = (this - that) / 1e3; break; // 1000
              case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
              case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
              case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
              case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
              default: output = this - that;
          }

          return asFloat ? output : absFloor(output);
      }

      function monthDiff (a, b) {
          // difference in months
          var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
              // b is in (anchor - 1 month, anchor + 1 month)
              anchor = a.clone().add(wholeMonthDiff, 'months'),
              anchor2, adjust;

          if (b - anchor < 0) {
              anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
              // linear across the month
              adjust = (b - anchor) / (anchor - anchor2);
          } else {
              anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
              // linear across the month
              adjust = (b - anchor) / (anchor2 - anchor);
          }

          //check for negative zero, return zero if negative zero
          return -(wholeMonthDiff + adjust) || 0;
      }

      hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
      hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

      function toString () {
          return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
      }

      function toISOString(keepOffset) {
          if (!this.isValid()) {
              return null;
          }
          var utc = keepOffset !== true;
          var m = utc ? this.clone().utc() : this;
          if (m.year() < 0 || m.year() > 9999) {
              return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
          }
          if (isFunction(Date.prototype.toISOString)) {
              // native implementation is ~50x faster, use it when we can
              if (utc) {
                  return this.toDate().toISOString();
              } else {
                  return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
              }
          }
          return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
      }

      /**
       * Return a human readable representation of a moment that can
       * also be evaluated to get a new moment which is the same
       *
       * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
       */
      function inspect () {
          if (!this.isValid()) {
              return 'moment.invalid(/* ' + this._i + ' */)';
          }
          var func = 'moment';
          var zone = '';
          if (!this.isLocal()) {
              func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
              zone = 'Z';
          }
          var prefix = '[' + func + '("]';
          var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
          var datetime = '-MM-DD[T]HH:mm:ss.SSS';
          var suffix = zone + '[")]';

          return this.format(prefix + year + datetime + suffix);
      }

      function format (inputString) {
          if (!inputString) {
              inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
      }

      function from (time, withoutSuffix) {
          if (this.isValid() &&
                  ((isMoment(time) && time.isValid()) ||
                   createLocal(time).isValid())) {
              return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
          } else {
              return this.localeData().invalidDate();
          }
      }

      function fromNow (withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
      }

      function to (time, withoutSuffix) {
          if (this.isValid() &&
                  ((isMoment(time) && time.isValid()) ||
                   createLocal(time).isValid())) {
              return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
          } else {
              return this.localeData().invalidDate();
          }
      }

      function toNow (withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
      }

      // If passed a locale key, it will set the locale for this
      // instance.  Otherwise, it will return the locale configuration
      // variables for this instance.
      function locale (key) {
          var newLocaleData;

          if (key === undefined) {
              return this._locale._abbr;
          } else {
              newLocaleData = getLocale(key);
              if (newLocaleData != null) {
                  this._locale = newLocaleData;
              }
              return this;
          }
      }

      var lang = deprecate(
          'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
          function (key) {
              if (key === undefined) {
                  return this.localeData();
              } else {
                  return this.locale(key);
              }
          }
      );

      function localeData () {
          return this._locale;
      }

      function startOf (units) {
          units = normalizeUnits(units);
          // the following switch intentionally omits break keywords
          // to utilize falling through the cases.
          switch (units) {
              case 'year':
                  this.month(0);
                  /* falls through */
              case 'quarter':
              case 'month':
                  this.date(1);
                  /* falls through */
              case 'week':
              case 'isoWeek':
              case 'day':
              case 'date':
                  this.hours(0);
                  /* falls through */
              case 'hour':
                  this.minutes(0);
                  /* falls through */
              case 'minute':
                  this.seconds(0);
                  /* falls through */
              case 'second':
                  this.milliseconds(0);
          }

          // weeks are a special case
          if (units === 'week') {
              this.weekday(0);
          }
          if (units === 'isoWeek') {
              this.isoWeekday(1);
          }

          // quarters are also special
          if (units === 'quarter') {
              this.month(Math.floor(this.month() / 3) * 3);
          }

          return this;
      }

      function endOf (units) {
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond') {
              return this;
          }

          // 'date' is an alias for 'day', so it should be considered as such.
          if (units === 'date') {
              units = 'day';
          }

          return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
      }

      function valueOf () {
          return this._d.valueOf() - ((this._offset || 0) * 60000);
      }

      function unix () {
          return Math.floor(this.valueOf() / 1000);
      }

      function toDate () {
          return new Date(this.valueOf());
      }

      function toArray () {
          var m = this;
          return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
      }

      function toObject () {
          var m = this;
          return {
              years: m.year(),
              months: m.month(),
              date: m.date(),
              hours: m.hours(),
              minutes: m.minutes(),
              seconds: m.seconds(),
              milliseconds: m.milliseconds()
          };
      }

      function toJSON () {
          // new Date(NaN).toJSON() === null
          return this.isValid() ? this.toISOString() : null;
      }

      function isValid$2 () {
          return isValid(this);
      }

      function parsingFlags () {
          return extend({}, getParsingFlags(this));
      }

      function invalidAt () {
          return getParsingFlags(this).overflow;
      }

      function creationData() {
          return {
              input: this._i,
              format: this._f,
              locale: this._locale,
              isUTC: this._isUTC,
              strict: this._strict
          };
      }

      // FORMATTING

      addFormatToken(0, ['gg', 2], 0, function () {
          return this.weekYear() % 100;
      });

      addFormatToken(0, ['GG', 2], 0, function () {
          return this.isoWeekYear() % 100;
      });

      function addWeekYearFormatToken (token, getter) {
          addFormatToken(0, [token, token.length], 0, getter);
      }

      addWeekYearFormatToken('gggg',     'weekYear');
      addWeekYearFormatToken('ggggg',    'weekYear');
      addWeekYearFormatToken('GGGG',  'isoWeekYear');
      addWeekYearFormatToken('GGGGG', 'isoWeekYear');

      // ALIASES

      addUnitAlias('weekYear', 'gg');
      addUnitAlias('isoWeekYear', 'GG');

      // PRIORITY

      addUnitPriority('weekYear', 1);
      addUnitPriority('isoWeekYear', 1);


      // PARSING

      addRegexToken('G',      matchSigned);
      addRegexToken('g',      matchSigned);
      addRegexToken('GG',     match1to2, match2);
      addRegexToken('gg',     match1to2, match2);
      addRegexToken('GGGG',   match1to4, match4);
      addRegexToken('gggg',   match1to4, match4);
      addRegexToken('GGGGG',  match1to6, match6);
      addRegexToken('ggggg',  match1to6, match6);

      addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
          week[token.substr(0, 2)] = toInt(input);
      });

      addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
          week[token] = hooks.parseTwoDigitYear(input);
      });

      // MOMENTS

      function getSetWeekYear (input) {
          return getSetWeekYearHelper.call(this,
                  input,
                  this.week(),
                  this.weekday(),
                  this.localeData()._week.dow,
                  this.localeData()._week.doy);
      }

      function getSetISOWeekYear (input) {
          return getSetWeekYearHelper.call(this,
                  input, this.isoWeek(), this.isoWeekday(), 1, 4);
      }

      function getISOWeeksInYear () {
          return weeksInYear(this.year(), 1, 4);
      }

      function getWeeksInYear () {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }

      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
              return weekOfYear(this, dow, doy).year;
          } else {
              weeksTarget = weeksInYear(input, dow, doy);
              if (week > weeksTarget) {
                  week = weeksTarget;
              }
              return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
      }

      function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
              date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
      }

      // FORMATTING

      addFormatToken('Q', 0, 'Qo', 'quarter');

      // ALIASES

      addUnitAlias('quarter', 'Q');

      // PRIORITY

      addUnitPriority('quarter', 7);

      // PARSING

      addRegexToken('Q', match1);
      addParseToken('Q', function (input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
      });

      // MOMENTS

      function getSetQuarter (input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }

      // FORMATTING

      addFormatToken('D', ['DD', 2], 'Do', 'date');

      // ALIASES

      addUnitAlias('date', 'D');

      // PRIORITY
      addUnitPriority('date', 9);

      // PARSING

      addRegexToken('D',  match1to2);
      addRegexToken('DD', match1to2, match2);
      addRegexToken('Do', function (isStrict, locale) {
          // TODO: Remove "ordinalParse" fallback in next major release.
          return isStrict ?
            (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
            locale._dayOfMonthOrdinalParseLenient;
      });

      addParseToken(['D', 'DD'], DATE);
      addParseToken('Do', function (input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
      });

      // MOMENTS

      var getSetDayOfMonth = makeGetSet('Date', true);

      // FORMATTING

      addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

      // ALIASES

      addUnitAlias('dayOfYear', 'DDD');

      // PRIORITY
      addUnitPriority('dayOfYear', 4);

      // PARSING

      addRegexToken('DDD',  match1to3);
      addRegexToken('DDDD', match3);
      addParseToken(['DDD', 'DDDD'], function (input, array, config) {
          config._dayOfYear = toInt(input);
      });

      // HELPERS

      // MOMENTS

      function getSetDayOfYear (input) {
          var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
          return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
      }

      // FORMATTING

      addFormatToken('m', ['mm', 2], 0, 'minute');

      // ALIASES

      addUnitAlias('minute', 'm');

      // PRIORITY

      addUnitPriority('minute', 14);

      // PARSING

      addRegexToken('m',  match1to2);
      addRegexToken('mm', match1to2, match2);
      addParseToken(['m', 'mm'], MINUTE);

      // MOMENTS

      var getSetMinute = makeGetSet('Minutes', false);

      // FORMATTING

      addFormatToken('s', ['ss', 2], 0, 'second');

      // ALIASES

      addUnitAlias('second', 's');

      // PRIORITY

      addUnitPriority('second', 15);

      // PARSING

      addRegexToken('s',  match1to2);
      addRegexToken('ss', match1to2, match2);
      addParseToken(['s', 'ss'], SECOND);

      // MOMENTS

      var getSetSecond = makeGetSet('Seconds', false);

      // FORMATTING

      addFormatToken('S', 0, 0, function () {
          return ~~(this.millisecond() / 100);
      });

      addFormatToken(0, ['SS', 2], 0, function () {
          return ~~(this.millisecond() / 10);
      });

      addFormatToken(0, ['SSS', 3], 0, 'millisecond');
      addFormatToken(0, ['SSSS', 4], 0, function () {
          return this.millisecond() * 10;
      });
      addFormatToken(0, ['SSSSS', 5], 0, function () {
          return this.millisecond() * 100;
      });
      addFormatToken(0, ['SSSSSS', 6], 0, function () {
          return this.millisecond() * 1000;
      });
      addFormatToken(0, ['SSSSSSS', 7], 0, function () {
          return this.millisecond() * 10000;
      });
      addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
          return this.millisecond() * 100000;
      });
      addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
          return this.millisecond() * 1000000;
      });


      // ALIASES

      addUnitAlias('millisecond', 'ms');

      // PRIORITY

      addUnitPriority('millisecond', 16);

      // PARSING

      addRegexToken('S',    match1to3, match1);
      addRegexToken('SS',   match1to3, match2);
      addRegexToken('SSS',  match1to3, match3);

      var token;
      for (token = 'SSSS'; token.length <= 9; token += 'S') {
          addRegexToken(token, matchUnsigned);
      }

      function parseMs(input, array) {
          array[MILLISECOND] = toInt(('0.' + input) * 1000);
      }

      for (token = 'S'; token.length <= 9; token += 'S') {
          addParseToken(token, parseMs);
      }
      // MOMENTS

      var getSetMillisecond = makeGetSet('Milliseconds', false);

      // FORMATTING

      addFormatToken('z',  0, 0, 'zoneAbbr');
      addFormatToken('zz', 0, 0, 'zoneName');

      // MOMENTS

      function getZoneAbbr () {
          return this._isUTC ? 'UTC' : '';
      }

      function getZoneName () {
          return this._isUTC ? 'Coordinated Universal Time' : '';
      }

      var proto = Moment.prototype;

      proto.add               = add;
      proto.calendar          = calendar$1;
      proto.clone             = clone;
      proto.diff              = diff;
      proto.endOf             = endOf;
      proto.format            = format;
      proto.from              = from;
      proto.fromNow           = fromNow;
      proto.to                = to;
      proto.toNow             = toNow;
      proto.get               = stringGet;
      proto.invalidAt         = invalidAt;
      proto.isAfter           = isAfter;
      proto.isBefore          = isBefore;
      proto.isBetween         = isBetween;
      proto.isSame            = isSame;
      proto.isSameOrAfter     = isSameOrAfter;
      proto.isSameOrBefore    = isSameOrBefore;
      proto.isValid           = isValid$2;
      proto.lang              = lang;
      proto.locale            = locale;
      proto.localeData        = localeData;
      proto.max               = prototypeMax;
      proto.min               = prototypeMin;
      proto.parsingFlags      = parsingFlags;
      proto.set               = stringSet;
      proto.startOf           = startOf;
      proto.subtract          = subtract;
      proto.toArray           = toArray;
      proto.toObject          = toObject;
      proto.toDate            = toDate;
      proto.toISOString       = toISOString;
      proto.inspect           = inspect;
      proto.toJSON            = toJSON;
      proto.toString          = toString;
      proto.unix              = unix;
      proto.valueOf           = valueOf;
      proto.creationData      = creationData;
      proto.year       = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear    = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month       = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week           = proto.weeks        = getSetWeek;
      proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
      proto.weeksInYear    = getWeeksInYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.date       = getSetDayOfMonth;
      proto.day        = proto.days             = getSetDayOfWeek;
      proto.weekday    = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear  = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset            = getSetOffset;
      proto.utc                  = setOffsetToUTC;
      proto.local                = setOffsetToLocal;
      proto.parseZone            = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST                = isDaylightSavingTime;
      proto.isLocal              = isLocal;
      proto.isUtcOffset          = isUtcOffset;
      proto.isUtc                = isUtc;
      proto.isUTC                = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
      proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
      proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
      proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
      proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

      function createUnix (input) {
          return createLocal(input * 1000);
      }

      function createInZone () {
          return createLocal.apply(null, arguments).parseZone();
      }

      function preParsePostFormat (string) {
          return string;
      }

      var proto$1 = Locale.prototype;

      proto$1.calendar        = calendar;
      proto$1.longDateFormat  = longDateFormat;
      proto$1.invalidDate     = invalidDate;
      proto$1.ordinal         = ordinal;
      proto$1.preparse        = preParsePostFormat;
      proto$1.postformat      = preParsePostFormat;
      proto$1.relativeTime    = relativeTime;
      proto$1.pastFuture      = pastFuture;
      proto$1.set             = set;

      proto$1.months            =        localeMonths;
      proto$1.monthsShort       =        localeMonthsShort;
      proto$1.monthsParse       =        localeMonthsParse;
      proto$1.monthsRegex       = monthsRegex;
      proto$1.monthsShortRegex  = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;

      proto$1.weekdays       =        localeWeekdays;
      proto$1.weekdaysMin    =        localeWeekdaysMin;
      proto$1.weekdaysShort  =        localeWeekdaysShort;
      proto$1.weekdaysParse  =        localeWeekdaysParse;

      proto$1.weekdaysRegex       =        weekdaysRegex;
      proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
      proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;

      function get$1 (format, index, field, setter) {
          var locale = getLocale();
          var utc = createUTC().set(setter, index);
          return locale[field](utc, format);
      }

      function listMonthsImpl (format, index, field) {
          if (isNumber(format)) {
              index = format;
              format = undefined;
          }

          format = format || '';

          if (index != null) {
              return get$1(format, index, field, 'month');
          }

          var i;
          var out = [];
          for (i = 0; i < 12; i++) {
              out[i] = get$1(format, i, field, 'month');
          }
          return out;
      }

      // ()
      // (5)
      // (fmt, 5)
      // (fmt)
      // (true)
      // (true, 5)
      // (true, fmt, 5)
      // (true, fmt)
      function listWeekdaysImpl (localeSorted, format, index, field) {
          if (typeof localeSorted === 'boolean') {
              if (isNumber(format)) {
                  index = format;
                  format = undefined;
              }

              format = format || '';
          } else {
              format = localeSorted;
              index = format;
              localeSorted = false;

              if (isNumber(format)) {
                  index = format;
                  format = undefined;
              }

              format = format || '';
          }

          var locale = getLocale(),
              shift = localeSorted ? locale._week.dow : 0;

          if (index != null) {
              return get$1(format, (index + shift) % 7, field, 'day');
          }

          var i;
          var out = [];
          for (i = 0; i < 7; i++) {
              out[i] = get$1(format, (i + shift) % 7, field, 'day');
          }
          return out;
      }

      function listMonths (format, index) {
          return listMonthsImpl(format, index, 'months');
      }

      function listMonthsShort (format, index) {
          return listMonthsImpl(format, index, 'monthsShort');
      }

      function listWeekdays (localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
      }

      function listWeekdaysShort (localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
      }

      function listWeekdaysMin (localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
      }

      getSetGlobalLocale('en', {
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal : function (number) {
              var b = number % 10,
                  output = (toInt(number % 100 / 10) === 1) ? 'th' :
                  (b === 1) ? 'st' :
                  (b === 2) ? 'nd' :
                  (b === 3) ? 'rd' : 'th';
              return number + output;
          }
      });

      // Side effect imports

      hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
      hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

      var mathAbs = Math.abs;

      function abs () {
          var data           = this._data;

          this._milliseconds = mathAbs(this._milliseconds);
          this._days         = mathAbs(this._days);
          this._months       = mathAbs(this._months);

          data.milliseconds  = mathAbs(data.milliseconds);
          data.seconds       = mathAbs(data.seconds);
          data.minutes       = mathAbs(data.minutes);
          data.hours         = mathAbs(data.hours);
          data.months        = mathAbs(data.months);
          data.years         = mathAbs(data.years);

          return this;
      }

      function addSubtract$1 (duration, input, value, direction) {
          var other = createDuration(input, value);

          duration._milliseconds += direction * other._milliseconds;
          duration._days         += direction * other._days;
          duration._months       += direction * other._months;

          return duration._bubble();
      }

      // supports only 2.0-style add(1, 's') or add(duration)
      function add$1 (input, value) {
          return addSubtract$1(this, input, value, 1);
      }

      // supports only 2.0-style subtract(1, 's') or subtract(duration)
      function subtract$1 (input, value) {
          return addSubtract$1(this, input, value, -1);
      }

      function absCeil (number) {
          if (number < 0) {
              return Math.floor(number);
          } else {
              return Math.ceil(number);
          }
      }

      function bubble () {
          var milliseconds = this._milliseconds;
          var days         = this._days;
          var months       = this._months;
          var data         = this._data;
          var seconds, minutes, hours, years, monthsFromDays;

          // if we have a mix of positive and negative values, bubble down first
          // check: https://github.com/moment/moment/issues/2166
          if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                  (milliseconds <= 0 && days <= 0 && months <= 0))) {
              milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
              days = 0;
              months = 0;
          }

          // The following code bubbles up values, see the tests for
          // examples of what that means.
          data.milliseconds = milliseconds % 1000;

          seconds           = absFloor(milliseconds / 1000);
          data.seconds      = seconds % 60;

          minutes           = absFloor(seconds / 60);
          data.minutes      = minutes % 60;

          hours             = absFloor(minutes / 60);
          data.hours        = hours % 24;

          days += absFloor(hours / 24);

          // convert days to months
          monthsFromDays = absFloor(daysToMonths(days));
          months += monthsFromDays;
          days -= absCeil(monthsToDays(monthsFromDays));

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;

          data.days   = days;
          data.months = months;
          data.years  = years;

          return this;
      }

      function daysToMonths (days) {
          // 400 years have 146097 days (taking into account leap year rules)
          // 400 years have 12 months === 4800
          return days * 4800 / 146097;
      }

      function monthsToDays (months) {
          // the reverse of daysToMonths
          return months * 146097 / 4800;
      }

      function as (units) {
          if (!this.isValid()) {
              return NaN;
          }
          var days;
          var months;
          var milliseconds = this._milliseconds;

          units = normalizeUnits(units);

          if (units === 'month' || units === 'year') {
              days   = this._days   + milliseconds / 864e5;
              months = this._months + daysToMonths(days);
              return units === 'month' ? months : months / 12;
          } else {
              // handle milliseconds separately because of floating point math errors (issue #1867)
              days = this._days + Math.round(monthsToDays(this._months));
              switch (units) {
                  case 'week'   : return days / 7     + milliseconds / 6048e5;
                  case 'day'    : return days         + milliseconds / 864e5;
                  case 'hour'   : return days * 24    + milliseconds / 36e5;
                  case 'minute' : return days * 1440  + milliseconds / 6e4;
                  case 'second' : return days * 86400 + milliseconds / 1000;
                  // Math.floor prevents floating point math errors here
                  case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                  default: throw new Error('Unknown unit ' + units);
              }
          }
      }

      // TODO: Use this.as('ms')?
      function valueOf$1 () {
          if (!this.isValid()) {
              return NaN;
          }
          return (
              this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6
          );
      }

      function makeAs (alias) {
          return function () {
              return this.as(alias);
          };
      }

      var asMilliseconds = makeAs('ms');
      var asSeconds      = makeAs('s');
      var asMinutes      = makeAs('m');
      var asHours        = makeAs('h');
      var asDays         = makeAs('d');
      var asWeeks        = makeAs('w');
      var asMonths       = makeAs('M');
      var asYears        = makeAs('y');

      function clone$1 () {
          return createDuration(this);
      }

      function get$2 (units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + 's']() : NaN;
      }

      function makeGetter(name) {
          return function () {
              return this.isValid() ? this._data[name] : NaN;
          };
      }

      var milliseconds = makeGetter('milliseconds');
      var seconds      = makeGetter('seconds');
      var minutes      = makeGetter('minutes');
      var hours        = makeGetter('hours');
      var days         = makeGetter('days');
      var months       = makeGetter('months');
      var years        = makeGetter('years');

      function weeks () {
          return absFloor(this.days() / 7);
      }

      var round = Math.round;
      var thresholds = {
          ss: 44,         // a few seconds to seconds
          s : 45,         // seconds to minute
          m : 45,         // minutes to hour
          h : 22,         // hours to day
          d : 26,         // days to month
          M : 11          // months to year
      };

      // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
          return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }

      function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
          var duration = createDuration(posNegDuration).abs();
          var seconds  = round(duration.as('s'));
          var minutes  = round(duration.as('m'));
          var hours    = round(duration.as('h'));
          var days     = round(duration.as('d'));
          var months   = round(duration.as('M'));
          var years    = round(duration.as('y'));

          var a = seconds <= thresholds.ss && ['s', seconds]  ||
                  seconds < thresholds.s   && ['ss', seconds] ||
                  minutes <= 1             && ['m']           ||
                  minutes < thresholds.m   && ['mm', minutes] ||
                  hours   <= 1             && ['h']           ||
                  hours   < thresholds.h   && ['hh', hours]   ||
                  days    <= 1             && ['d']           ||
                  days    < thresholds.d   && ['dd', days]    ||
                  months  <= 1             && ['M']           ||
                  months  < thresholds.M   && ['MM', months]  ||
                  years   <= 1             && ['y']           || ['yy', years];

          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale;
          return substituteTimeAgo.apply(null, a);
      }

      // This function allows you to set the rounding function for relative time strings
      function getSetRelativeTimeRounding (roundingFunction) {
          if (roundingFunction === undefined) {
              return round;
          }
          if (typeof(roundingFunction) === 'function') {
              round = roundingFunction;
              return true;
          }
          return false;
      }

      // This function allows you to set a threshold for relative time strings
      function getSetRelativeTimeThreshold (threshold, limit) {
          if (thresholds[threshold] === undefined) {
              return false;
          }
          if (limit === undefined) {
              return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === 's') {
              thresholds.ss = limit - 1;
          }
          return true;
      }

      function humanize (withSuffix) {
          if (!this.isValid()) {
              return this.localeData().invalidDate();
          }

          var locale = this.localeData();
          var output = relativeTime$1(this, !withSuffix, locale);

          if (withSuffix) {
              output = locale.pastFuture(+this, output);
          }

          return locale.postformat(output);
      }

      var abs$1 = Math.abs;

      function sign(x) {
          return ((x > 0) - (x < 0)) || +x;
      }

      function toISOString$1() {
          // for ISO strings we do not use the normal bubbling rules:
          //  * milliseconds bubble up until they become hours
          //  * days do not bubble at all
          //  * months bubble up until they become years
          // This is because there is no context-free conversion between hours and days
          // (think of clock changes)
          // and also not between days and months (28-31 days per month)
          if (!this.isValid()) {
              return this.localeData().invalidDate();
          }

          var seconds = abs$1(this._milliseconds) / 1000;
          var days         = abs$1(this._days);
          var months       = abs$1(this._months);
          var minutes, hours, years;

          // 3600 seconds -> 60 minutes -> 1 hour
          minutes           = absFloor(seconds / 60);
          hours             = absFloor(minutes / 60);
          seconds %= 60;
          minutes %= 60;

          // 12 months -> 1 year
          years  = absFloor(months / 12);
          months %= 12;


          // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
          var Y = years;
          var M = months;
          var D = days;
          var h = hours;
          var m = minutes;
          var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
          var total = this.asSeconds();

          if (!total) {
              // this is the same as C#'s (Noda) and python (isodate)...
              // but not other JS (goog.date)
              return 'P0D';
          }

          var totalSign = total < 0 ? '-' : '';
          var ymSign = sign(this._months) !== sign(total) ? '-' : '';
          var daysSign = sign(this._days) !== sign(total) ? '-' : '';
          var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

          return totalSign + 'P' +
              (Y ? ymSign + Y + 'Y' : '') +
              (M ? ymSign + M + 'M' : '') +
              (D ? daysSign + D + 'D' : '') +
              ((h || m || s) ? 'T' : '') +
              (h ? hmsSign + h + 'H' : '') +
              (m ? hmsSign + m + 'M' : '') +
              (s ? hmsSign + s + 'S' : '');
      }

      var proto$2 = Duration.prototype;

      proto$2.isValid        = isValid$1;
      proto$2.abs            = abs;
      proto$2.add            = add$1;
      proto$2.subtract       = subtract$1;
      proto$2.as             = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds      = asSeconds;
      proto$2.asMinutes      = asMinutes;
      proto$2.asHours        = asHours;
      proto$2.asDays         = asDays;
      proto$2.asWeeks        = asWeeks;
      proto$2.asMonths       = asMonths;
      proto$2.asYears        = asYears;
      proto$2.valueOf        = valueOf$1;
      proto$2._bubble        = bubble;
      proto$2.clone          = clone$1;
      proto$2.get            = get$2;
      proto$2.milliseconds   = milliseconds;
      proto$2.seconds        = seconds;
      proto$2.minutes        = minutes;
      proto$2.hours          = hours;
      proto$2.days           = days;
      proto$2.weeks          = weeks;
      proto$2.months         = months;
      proto$2.years          = years;
      proto$2.humanize       = humanize;
      proto$2.toISOString    = toISOString$1;
      proto$2.toString       = toISOString$1;
      proto$2.toJSON         = toISOString$1;
      proto$2.locale         = locale;
      proto$2.localeData     = localeData;

      proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
      proto$2.lang = lang;

      // Side effect imports

      // FORMATTING

      addFormatToken('X', 0, 0, 'unix');
      addFormatToken('x', 0, 0, 'valueOf');

      // PARSING

      addRegexToken('x', matchSigned);
      addRegexToken('X', matchTimestamp);
      addParseToken('X', function (input, array, config) {
          config._d = new Date(parseFloat(input, 10) * 1000);
      });
      addParseToken('x', function (input, array, config) {
          config._d = new Date(toInt(input));
      });

      // Side effect imports


      hooks.version = '2.22.2';

      setHookCallback(createLocal);

      hooks.fn                    = proto;
      hooks.min                   = min;
      hooks.max                   = max;
      hooks.now                   = now;
      hooks.utc                   = createUTC;
      hooks.unix                  = createUnix;
      hooks.months                = listMonths;
      hooks.isDate                = isDate;
      hooks.locale                = getSetGlobalLocale;
      hooks.invalid               = createInvalid;
      hooks.duration              = createDuration;
      hooks.isMoment              = isMoment;
      hooks.weekdays              = listWeekdays;
      hooks.parseZone             = createInZone;
      hooks.localeData            = getLocale;
      hooks.isDuration            = isDuration;
      hooks.monthsShort           = listMonthsShort;
      hooks.weekdaysMin           = listWeekdaysMin;
      hooks.defineLocale          = defineLocale;
      hooks.updateLocale          = updateLocale;
      hooks.locales               = listLocales;
      hooks.weekdaysShort         = listWeekdaysShort;
      hooks.normalizeUnits        = normalizeUnits;
      hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat        = getCalendarFormat;
      hooks.prototype             = proto;

      // currently HTML5 input type only supports 24-hour formats
      hooks.HTML5_FMT = {
          DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
          DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
          DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
          DATE: 'YYYY-MM-DD',                             // <input type="date" />
          TIME: 'HH:mm',                                  // <input type="time" />
          TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
          TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
          WEEK: 'YYYY-[W]WW',                             // <input type="week" />
          MONTH: 'YYYY-MM'                                // <input type="month" />
      };

      return hooks;

  })));
  });

  /**
   * Copyright 2014-2015, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   */

  /**
   * Similar to invariant but only logs a warning if the condition is not met.
   * This can be used to log issues in development environments in critical
   * paths. Removing the logging code for production environments will keep the
   * same logic and follow the same code paths.
   */

  var __DEV__ = process.env.NODE_ENV !== 'production';

  var warning = function() {};

  if (__DEV__) {
    warning = function(condition, format, args) {
      var len = arguments.length;
      args = new Array(len > 2 ? len - 2 : 0);
      for (var key = 2; key < len; key++) {
        args[key - 2] = arguments[key];
      }
      if (format === undefined) {
        throw new Error(
          '`warning(condition, format, ...args)` requires a warning ' +
          'message argument'
        );
      }

      if (format.length < 10 || (/^[s\W]*$/).test(format)) {
        throw new Error(
          'The warning format should be able to uniquely identify this ' +
          'warning. Please, use a more descriptive format than: ' + format
        );
      }

      if (!condition) {
        var argIndex = 0;
        var message = 'Warning: ' +
          format.replace(/%s/g, function() {
            return args[argIndex++];
          });
        if (typeof console !== 'undefined') {
          console.error(message);
        }
        try {
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch(x) {}
      }
    };
  }

  var warning_1 = warning;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Use invariant() to assert state which your program assumes to be true.
   *
   * Provide sprintf-style format (only %s is supported) and arguments
   * to provide information about what broke and what you were
   * expecting.
   *
   * The invariant message will be stripped in production, but the invariant
   * will remain to ensure logic does not differ in production.
   */

  var NODE_ENV = process.env.NODE_ENV;

  var invariant = function(condition, format, a, b, c, d, e, f) {
    if (NODE_ENV !== 'production') {
      if (format === undefined) {
        throw new Error('invariant requires an error message argument');
      }
    }

    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error(
          'Minified exception occurred; use the non-minified dev environment ' +
          'for the full error message and additional helpful warnings.'
        );
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(
          format.replace(/%s/g, function() { return args[argIndex++]; })
        );
        error.name = 'Invariant Violation';
      }

      error.framesToPop = 1; // we don't care about invariant's own frame
      throw error;
    }
  };

  var invariant_1 = invariant;

  function isAbsolute(pathname) {
    return pathname.charAt(0) === '/';
  }

  // About 1.5x faster than the two-arg version of Array#splice()
  function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
      list[i] = list[k];
    }

    list.pop();
  }

  // This implementation is based heavily on node's url.parse
  function resolvePathname(to) {
    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

    var toParts = to && to.split('/') || [];
    var fromParts = from && from.split('/') || [];

    var isToAbs = to && isAbsolute(to);
    var isFromAbs = from && isAbsolute(from);
    var mustEndAbs = isToAbs || isFromAbs;

    if (to && isAbsolute(to)) {
      // to is absolute
      fromParts = toParts;
    } else if (toParts.length) {
      // to is relative, drop the filename
      fromParts.pop();
      fromParts = fromParts.concat(toParts);
    }

    if (!fromParts.length) return '/';

    var hasTrailingSlash = void 0;
    if (fromParts.length) {
      var last = fromParts[fromParts.length - 1];
      hasTrailingSlash = last === '.' || last === '..' || last === '';
    } else {
      hasTrailingSlash = false;
    }

    var up = 0;
    for (var i = fromParts.length; i >= 0; i--) {
      var part = fromParts[i];

      if (part === '.') {
        spliceOne(fromParts, i);
      } else if (part === '..') {
        spliceOne(fromParts, i);
        up++;
      } else if (up) {
        spliceOne(fromParts, i);
        up--;
      }
    }

    if (!mustEndAbs) for (; up--; up) {
      fromParts.unshift('..');
    }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');

    var result = fromParts.join('/');

    if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

    return result;
  }

  var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  function valueEqual(a, b) {
    if (a === b) return true;

    if (a == null || b == null) return false;

    if (Array.isArray(a)) {
      return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
        return valueEqual(item, b[index]);
      });
    }

    var aType = typeof a === 'undefined' ? 'undefined' : _typeof$1(a);
    var bType = typeof b === 'undefined' ? 'undefined' : _typeof$1(b);

    if (aType !== bType) return false;

    if (aType === 'object') {
      var aValue = a.valueOf();
      var bValue = b.valueOf();

      if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);

      var aKeys = Object.keys(a);
      var bKeys = Object.keys(b);

      if (aKeys.length !== bKeys.length) return false;

      return aKeys.every(function (key) {
        return valueEqual(a[key], b[key]);
      });
    }

    return false;
  }

  var addLeadingSlash = function addLeadingSlash(path) {
    return path.charAt(0) === '/' ? path : '/' + path;
  };

  var stripLeadingSlash = function stripLeadingSlash(path) {
    return path.charAt(0) === '/' ? path.substr(1) : path;
  };

  var hasBasename = function hasBasename(path, prefix) {
    return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
  };

  var stripBasename = function stripBasename(path, prefix) {
    return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
  };

  var stripTrailingSlash = function stripTrailingSlash(path) {
    return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
  };

  var parsePath = function parsePath(path) {
    var pathname = path || '/';
    var search = '';
    var hash = '';

    var hashIndex = pathname.indexOf('#');
    if (hashIndex !== -1) {
      hash = pathname.substr(hashIndex);
      pathname = pathname.substr(0, hashIndex);
    }

    var searchIndex = pathname.indexOf('?');
    if (searchIndex !== -1) {
      search = pathname.substr(searchIndex);
      pathname = pathname.substr(0, searchIndex);
    }

    return {
      pathname: pathname,
      search: search === '?' ? '' : search,
      hash: hash === '#' ? '' : hash
    };
  };

  var createPath = function createPath(location) {
    var pathname = location.pathname,
        search = location.search,
        hash = location.hash;


    var path = pathname || '/';

    if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

    if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

    return path;
  };

  var _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var createLocation = function createLocation(path, state, key, currentLocation) {
    var location = void 0;
    if (typeof path === 'string') {
      // Two-arg form: push(path, state)
      location = parsePath(path);
      location.state = state;
    } else {
      // One-arg form: push(location)
      location = _extends$1({}, path);

      if (location.pathname === undefined) location.pathname = '';

      if (location.search) {
        if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
      } else {
        location.search = '';
      }

      if (location.hash) {
        if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
      } else {
        location.hash = '';
      }

      if (state !== undefined && location.state === undefined) location.state = state;
    }

    try {
      location.pathname = decodeURI(location.pathname);
    } catch (e) {
      if (e instanceof URIError) {
        throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
      } else {
        throw e;
      }
    }

    if (key) location.key = key;

    if (currentLocation) {
      // Resolve incomplete/relative pathname relative to current location.
      if (!location.pathname) {
        location.pathname = currentLocation.pathname;
      } else if (location.pathname.charAt(0) !== '/') {
        location.pathname = resolvePathname(location.pathname, currentLocation.pathname);
      }
    } else {
      // When there is no prior location and pathname is empty, set it to /
      if (!location.pathname) {
        location.pathname = '/';
      }
    }

    return location;
  };

  var locationsAreEqual = function locationsAreEqual(a, b) {
    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);
  };

  var createTransitionManager = function createTransitionManager() {
    var prompt = null;

    var setPrompt = function setPrompt(nextPrompt) {
      warning_1(prompt == null, 'A history supports only one prompt at a time');

      prompt = nextPrompt;

      return function () {
        if (prompt === nextPrompt) prompt = null;
      };
    };

    var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
      // TODO: If another transition starts while we're still confirming
      // the previous one, we may end up in a weird state. Figure out the
      // best way to handle this.
      if (prompt != null) {
        var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

        if (typeof result === 'string') {
          if (typeof getUserConfirmation === 'function') {
            getUserConfirmation(result, callback);
          } else {
            warning_1(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

            callback(true);
          }
        } else {
          // Return false from a transition hook to cancel the transition.
          callback(result !== false);
        }
      } else {
        callback(true);
      }
    };

    var listeners = [];

    var appendListener = function appendListener(fn) {
      var isActive = true;

      var listener = function listener() {
        if (isActive) fn.apply(undefined, arguments);
      };

      listeners.push(listener);

      return function () {
        isActive = false;
        listeners = listeners.filter(function (item) {
          return item !== listener;
        });
      };
    };

    var notifyListeners = function notifyListeners() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      listeners.forEach(function (listener) {
        return listener.apply(undefined, args);
      });
    };

    return {
      setPrompt: setPrompt,
      confirmTransitionTo: confirmTransitionTo,
      appendListener: appendListener,
      notifyListeners: notifyListeners
    };
  };

  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

  var addEventListener = function addEventListener(node, event, listener) {
    return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
  };

  var removeEventListener = function removeEventListener(node, event, listener) {
    return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
  };

  var getConfirmation = function getConfirmation(message, callback) {
    return callback(window.confirm(message));
  }; // eslint-disable-line no-alert

  /**
   * Returns true if the HTML5 history API is supported. Taken from Modernizr.
   *
   * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
   * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
   * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
   */
  var supportsHistory = function supportsHistory() {
    var ua = window.navigator.userAgent;

    if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

    return window.history && 'pushState' in window.history;
  };

  /**
   * Returns true if browser fires popstate on hash change.
   * IE10 and IE11 do not.
   */
  var supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
    return window.navigator.userAgent.indexOf('Trident') === -1;
  };

  /**
   * Returns false if using go(n) with hash history causes a full page reload.
   */
  var supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
    return window.navigator.userAgent.indexOf('Firefox') === -1;
  };

  /**
   * Returns true if a given popstate event is an extraneous WebKit event.
   * Accounts for the fact that Chrome on iOS fires real popstate events
   * containing undefined state when pressing the back button.
   */
  var isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
    return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
  };

  var _typeof$2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var PopStateEvent = 'popstate';
  var HashChangeEvent = 'hashchange';

  var getHistoryState = function getHistoryState() {
    try {
      return window.history.state || {};
    } catch (e) {
      // IE 11 sometimes throws when accessing window.history.state
      // See https://github.com/ReactTraining/history/pull/289
      return {};
    }
  };

  /**
   * Creates a history object that uses the HTML5 history API including
   * pushState, replaceState, and the popstate event.
   */
  var createBrowserHistory = function createBrowserHistory() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    invariant_1(canUseDOM, 'Browser history needs a DOM');

    var globalHistory = window.history;
    var canUseHistory = supportsHistory();
    var needsHashChangeListener = !supportsPopStateOnHashChange();

    var _props$forceRefresh = props.forceRefresh,
        forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
        _props$getUserConfirm = props.getUserConfirmation,
        getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,
        _props$keyLength = props.keyLength,
        keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

    var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';

    var getDOMLocation = function getDOMLocation(historyState) {
      var _ref = historyState || {},
          key = _ref.key,
          state = _ref.state;

      var _window$location = window.location,
          pathname = _window$location.pathname,
          search = _window$location.search,
          hash = _window$location.hash;


      var path = pathname + search + hash;

      warning_1(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

      if (basename) path = stripBasename(path, basename);

      return createLocation(path, state, key);
    };

    var createKey = function createKey() {
      return Math.random().toString(36).substr(2, keyLength);
    };

    var transitionManager = createTransitionManager();

    var setState = function setState(nextState) {
      _extends$2(history, nextState);

      history.length = globalHistory.length;

      transitionManager.notifyListeners(history.location, history.action);
    };

    var handlePopState = function handlePopState(event) {
      // Ignore extraneous popstate events in WebKit.
      if (isExtraneousPopstateEvent(event)) return;

      handlePop(getDOMLocation(event.state));
    };

    var handleHashChange = function handleHashChange() {
      handlePop(getDOMLocation(getHistoryState()));
    };

    var forceNextPop = false;

    var handlePop = function handlePop(location) {
      if (forceNextPop) {
        forceNextPop = false;
        setState();
      } else {
        var action = 'POP';

        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
          if (ok) {
            setState({ action: action, location: location });
          } else {
            revertPop(location);
          }
        });
      }
    };

    var revertPop = function revertPop(fromLocation) {
      var toLocation = history.location;

      // TODO: We could probably make this more reliable by
      // keeping a list of keys we've seen in sessionStorage.
      // Instead, we just default to 0 for keys we don't know.

      var toIndex = allKeys.indexOf(toLocation.key);

      if (toIndex === -1) toIndex = 0;

      var fromIndex = allKeys.indexOf(fromLocation.key);

      if (fromIndex === -1) fromIndex = 0;

      var delta = toIndex - fromIndex;

      if (delta) {
        forceNextPop = true;
        go(delta);
      }
    };

    var initialLocation = getDOMLocation(getHistoryState());
    var allKeys = [initialLocation.key];

    // Public interface

    var createHref = function createHref(location) {
      return basename + createPath(location);
    };

    var push = function push(path, state) {
      warning_1(!((typeof path === 'undefined' ? 'undefined' : _typeof$2(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

      var action = 'PUSH';
      var location = createLocation(path, state, createKey(), history.location);

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (!ok) return;

        var href = createHref(location);
        var key = location.key,
            state = location.state;


        if (canUseHistory) {
          globalHistory.pushState({ key: key, state: state }, null, href);

          if (forceRefresh) {
            window.location.href = href;
          } else {
            var prevIndex = allKeys.indexOf(history.location.key);
            var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

            nextKeys.push(location.key);
            allKeys = nextKeys;

            setState({ action: action, location: location });
          }
        } else {
          warning_1(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

          window.location.href = href;
        }
      });
    };

    var replace = function replace(path, state) {
      warning_1(!((typeof path === 'undefined' ? 'undefined' : _typeof$2(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

      var action = 'REPLACE';
      var location = createLocation(path, state, createKey(), history.location);

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (!ok) return;

        var href = createHref(location);
        var key = location.key,
            state = location.state;


        if (canUseHistory) {
          globalHistory.replaceState({ key: key, state: state }, null, href);

          if (forceRefresh) {
            window.location.replace(href);
          } else {
            var prevIndex = allKeys.indexOf(history.location.key);

            if (prevIndex !== -1) allKeys[prevIndex] = location.key;

            setState({ action: action, location: location });
          }
        } else {
          warning_1(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

          window.location.replace(href);
        }
      });
    };

    var go = function go(n) {
      globalHistory.go(n);
    };

    var goBack = function goBack() {
      return go(-1);
    };

    var goForward = function goForward() {
      return go(1);
    };

    var listenerCount = 0;

    var checkDOMListeners = function checkDOMListeners(delta) {
      listenerCount += delta;

      if (listenerCount === 1) {
        addEventListener(window, PopStateEvent, handlePopState);

        if (needsHashChangeListener) addEventListener(window, HashChangeEvent, handleHashChange);
      } else if (listenerCount === 0) {
        removeEventListener(window, PopStateEvent, handlePopState);

        if (needsHashChangeListener) removeEventListener(window, HashChangeEvent, handleHashChange);
      }
    };

    var isBlocked = false;

    var block = function block() {
      var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var unblock = transitionManager.setPrompt(prompt);

      if (!isBlocked) {
        checkDOMListeners(1);
        isBlocked = true;
      }

      return function () {
        if (isBlocked) {
          isBlocked = false;
          checkDOMListeners(-1);
        }

        return unblock();
      };
    };

    var listen = function listen(listener) {
      var unlisten = transitionManager.appendListener(listener);
      checkDOMListeners(1);

      return function () {
        checkDOMListeners(-1);
        unlisten();
      };
    };

    var history = {
      length: globalHistory.length,
      action: 'POP',
      location: initialLocation,
      createHref: createHref,
      push: push,
      replace: replace,
      go: go,
      goBack: goBack,
      goForward: goForward,
      block: block,
      listen: listen
    };

    return history;
  };

  var _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var HashChangeEvent$1 = 'hashchange';

  var HashPathCoders = {
    hashbang: {
      encodePath: function encodePath(path) {
        return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);
      },
      decodePath: function decodePath(path) {
        return path.charAt(0) === '!' ? path.substr(1) : path;
      }
    },
    noslash: {
      encodePath: stripLeadingSlash,
      decodePath: addLeadingSlash
    },
    slash: {
      encodePath: addLeadingSlash,
      decodePath: addLeadingSlash
    }
  };

  var getHashPath = function getHashPath() {
    // We can't use window.location.hash here because it's not
    // consistent across browsers - Firefox will pre-decode it!
    var href = window.location.href;
    var hashIndex = href.indexOf('#');
    return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
  };

  var pushHashPath = function pushHashPath(path) {
    return window.location.hash = path;
  };

  var replaceHashPath = function replaceHashPath(path) {
    var hashIndex = window.location.href.indexOf('#');

    window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
  };

  var createHashHistory = function createHashHistory() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    invariant_1(canUseDOM, 'Hash history needs a DOM');

    var globalHistory = window.history;
    var canGoWithoutReload = supportsGoWithoutReloadUsingHash();

    var _props$getUserConfirm = props.getUserConfirmation,
        getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,
        _props$hashType = props.hashType,
        hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

    var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';

    var _HashPathCoders$hashT = HashPathCoders[hashType],
        encodePath = _HashPathCoders$hashT.encodePath,
        decodePath = _HashPathCoders$hashT.decodePath;


    var getDOMLocation = function getDOMLocation() {
      var path = decodePath(getHashPath());

      warning_1(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

      if (basename) path = stripBasename(path, basename);

      return createLocation(path);
    };

    var transitionManager = createTransitionManager();

    var setState = function setState(nextState) {
      _extends$3(history, nextState);

      history.length = globalHistory.length;

      transitionManager.notifyListeners(history.location, history.action);
    };

    var forceNextPop = false;
    var ignorePath = null;

    var handleHashChange = function handleHashChange() {
      var path = getHashPath();
      var encodedPath = encodePath(path);

      if (path !== encodedPath) {
        // Ensure we always have a properly-encoded hash.
        replaceHashPath(encodedPath);
      } else {
        var location = getDOMLocation();
        var prevLocation = history.location;

        if (!forceNextPop && locationsAreEqual(prevLocation, location)) return; // A hashchange doesn't always == location change.

        if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.

        ignorePath = null;

        handlePop(location);
      }
    };

    var handlePop = function handlePop(location) {
      if (forceNextPop) {
        forceNextPop = false;
        setState();
      } else {
        var action = 'POP';

        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
          if (ok) {
            setState({ action: action, location: location });
          } else {
            revertPop(location);
          }
        });
      }
    };

    var revertPop = function revertPop(fromLocation) {
      var toLocation = history.location;

      // TODO: We could probably make this more reliable by
      // keeping a list of paths we've seen in sessionStorage.
      // Instead, we just default to 0 for paths we don't know.

      var toIndex = allPaths.lastIndexOf(createPath(toLocation));

      if (toIndex === -1) toIndex = 0;

      var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));

      if (fromIndex === -1) fromIndex = 0;

      var delta = toIndex - fromIndex;

      if (delta) {
        forceNextPop = true;
        go(delta);
      }
    };

    // Ensure the hash is encoded properly before doing anything else.
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) replaceHashPath(encodedPath);

    var initialLocation = getDOMLocation();
    var allPaths = [createPath(initialLocation)];

    // Public interface

    var createHref = function createHref(location) {
      return '#' + encodePath(basename + createPath(location));
    };

    var push = function push(path, state) {
      warning_1(state === undefined, 'Hash history cannot push state; it is ignored');

      var action = 'PUSH';
      var location = createLocation(path, undefined, undefined, history.location);

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (!ok) return;

        var path = createPath(location);
        var encodedPath = encodePath(basename + path);
        var hashChanged = getHashPath() !== encodedPath;

        if (hashChanged) {
          // We cannot tell if a hashchange was caused by a PUSH, so we'd
          // rather setState here and ignore the hashchange. The caveat here
          // is that other hash histories in the page will consider it a POP.
          ignorePath = path;
          pushHashPath(encodedPath);

          var prevIndex = allPaths.lastIndexOf(createPath(history.location));
          var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextPaths.push(path);
          allPaths = nextPaths;

          setState({ action: action, location: location });
        } else {
          warning_1(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

          setState();
        }
      });
    };

    var replace = function replace(path, state) {
      warning_1(state === undefined, 'Hash history cannot replace state; it is ignored');

      var action = 'REPLACE';
      var location = createLocation(path, undefined, undefined, history.location);

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (!ok) return;

        var path = createPath(location);
        var encodedPath = encodePath(basename + path);
        var hashChanged = getHashPath() !== encodedPath;

        if (hashChanged) {
          // We cannot tell if a hashchange was caused by a REPLACE, so we'd
          // rather setState here and ignore the hashchange. The caveat here
          // is that other hash histories in the page will consider it a POP.
          ignorePath = path;
          replaceHashPath(encodedPath);
        }

        var prevIndex = allPaths.indexOf(createPath(history.location));

        if (prevIndex !== -1) allPaths[prevIndex] = path;

        setState({ action: action, location: location });
      });
    };

    var go = function go(n) {
      warning_1(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

      globalHistory.go(n);
    };

    var goBack = function goBack() {
      return go(-1);
    };

    var goForward = function goForward() {
      return go(1);
    };

    var listenerCount = 0;

    var checkDOMListeners = function checkDOMListeners(delta) {
      listenerCount += delta;

      if (listenerCount === 1) {
        addEventListener(window, HashChangeEvent$1, handleHashChange);
      } else if (listenerCount === 0) {
        removeEventListener(window, HashChangeEvent$1, handleHashChange);
      }
    };

    var isBlocked = false;

    var block = function block() {
      var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var unblock = transitionManager.setPrompt(prompt);

      if (!isBlocked) {
        checkDOMListeners(1);
        isBlocked = true;
      }

      return function () {
        if (isBlocked) {
          isBlocked = false;
          checkDOMListeners(-1);
        }

        return unblock();
      };
    };

    var listen = function listen(listener) {
      var unlisten = transitionManager.appendListener(listener);
      checkDOMListeners(1);

      return function () {
        checkDOMListeners(-1);
        unlisten();
      };
    };

    var history = {
      length: globalHistory.length,
      action: 'POP',
      location: initialLocation,
      createHref: createHref,
      push: push,
      replace: replace,
      go: go,
      goBack: goBack,
      goForward: goForward,
      block: block,
      listen: listen
    };

    return history;
  };

  var _typeof$3 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  var _extends$4 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var clamp = function clamp(n, lowerBound, upperBound) {
    return Math.min(Math.max(n, lowerBound), upperBound);
  };

  /**
   * Creates a history object that stores locations in memory.
   */
  var createMemoryHistory = function createMemoryHistory() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var getUserConfirmation = props.getUserConfirmation,
        _props$initialEntries = props.initialEntries,
        initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
        _props$initialIndex = props.initialIndex,
        initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
        _props$keyLength = props.keyLength,
        keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;


    var transitionManager = createTransitionManager();

    var setState = function setState(nextState) {
      _extends$4(history, nextState);

      history.length = history.entries.length;

      transitionManager.notifyListeners(history.location, history.action);
    };

    var createKey = function createKey() {
      return Math.random().toString(36).substr(2, keyLength);
    };

    var index = clamp(initialIndex, 0, initialEntries.length - 1);
    var entries = initialEntries.map(function (entry) {
      return typeof entry === 'string' ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());
    });

    // Public interface

    var createHref = createPath;

    var push = function push(path, state) {
      warning_1(!((typeof path === 'undefined' ? 'undefined' : _typeof$3(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

      var action = 'PUSH';
      var location = createLocation(path, state, createKey(), history.location);

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (!ok) return;

        var prevIndex = history.index;
        var nextIndex = prevIndex + 1;

        var nextEntries = history.entries.slice(0);
        if (nextEntries.length > nextIndex) {
          nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
        } else {
          nextEntries.push(location);
        }

        setState({
          action: action,
          location: location,
          index: nextIndex,
          entries: nextEntries
        });
      });
    };

    var replace = function replace(path, state) {
      warning_1(!((typeof path === 'undefined' ? 'undefined' : _typeof$3(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

      var action = 'REPLACE';
      var location = createLocation(path, state, createKey(), history.location);

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (!ok) return;

        history.entries[history.index] = location;

        setState({ action: action, location: location });
      });
    };

    var go = function go(n) {
      var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

      var action = 'POP';
      var location = history.entries[nextIndex];

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({
            action: action,
            location: location,
            index: nextIndex
          });
        } else {
          // Mimic the behavior of DOM histories by
          // causing a render after a cancelled POP.
          setState();
        }
      });
    };

    var goBack = function goBack() {
      return go(-1);
    };

    var goForward = function goForward() {
      return go(1);
    };

    var canGo = function canGo(n) {
      var nextIndex = history.index + n;
      return nextIndex >= 0 && nextIndex < history.entries.length;
    };

    var block = function block() {
      var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return transitionManager.setPrompt(prompt);
    };

    var listen = function listen(listener) {
      return transitionManager.appendListener(listener);
    };

    var history = {
      length: entries.length,
      action: 'POP',
      location: entries[index],
      index: index,
      entries: entries,
      createHref: createHref,
      push: push,
      replace: replace,
      go: go,
      goBack: goBack,
      goForward: goForward,
      canGo: canGo,
      block: block,
      listen: listen
    };

    return history;
  };

  var promiseCount = 0;
  var objectCount = 0;
  /**
   * @module Core
   */

  var Obj =
  /*#__PURE__*/
  function () {
    /**
     * Basic object that can trigger events
     *
     * @class Core.Obj
     * @constructor
     */
    function Obj() {
      _classCallCheck(this, Obj);

      // Init values
      this._listeners = new Map();
      this._promises = new Map();
      this.__chickenUid_Obj = "**Obj".concat(++objectCount, "**");
    }

    _createClass(Obj, [{
      key: "__getUid",
      value: function __getUid() {
        return this.__chickenUid_Obj;
      } ////////////////////
      // Public methods //
      ////////////////////

    }, {
      key: "promise",
      value: function promise(key, callback) {
        // Do the callback
        var promise = this._getPromiseInfo(key);

        callback.apply(null, [promise.resolve, promise.reject]);
        return promise.promise;
      }
    }, {
      key: "resolvePromise",
      value: function resolvePromise(key) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        this._getPromiseInfo(key).resolve.apply(this, args);

        return this;
      }
    }, {
      key: "rejectPromise",
      value: function rejectPromise(key) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        this._getPromiseInfo(key).reject.apply(this, args);

        return this;
      }
    }, {
      key: "getPromise",
      value: function getPromise(key) {
        return this._getPromiseInfo(key).promise;
      }
    }, {
      key: "resetPromise",
      value: function resetPromise(key) {
        this._promises.delete(key);
      }
    }, {
      key: "_getPromiseInfo",
      value: function _getPromiseInfo(key) {
        // Was the promise already defined
        if (!this._promises.has(key)) {
          // Store it
          var p = {};
          p.promise = new Promise(function (resolve, reject) {
            p.resolve = resolve;
            p.reject = reject;
            p.id = promiseCount++;
          });

          this._promises.set(key, p);
        }

        return this._promises.get(key);
      }
    }, {
      key: "when",
      value: function when() {
        var _this = this;

        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        // The last one should be a callback
        var successCallback = args.pop();

        var failCallback = function failCallback(error) {
          for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            args[_key4 - 1] = arguments[_key4];
          }

          throw new Error('Uncaught promise failure for ' + args.join(', ') + ': ' + error);
        };

        if (args.length > 1 && typeof underscore.last(args) === 'function') {
          failCallback = successCallback;
          successCallback = args.pop();
        } // Collect promises


        var promises = [];

        underscore.each(args, function (arg) {
          promises.push(_this._getPromiseInfo(arg).promise);
        }); // One?


        if (promises.length === 1) {
          // Simple.
          promises[0].then(successCallback, failCallback);
        } else {
          // When all are done
          Promise.all(promises).then(successCallback, failCallback);
        }

        return this;
      }
      /**
       * Add listener for chosen event
       *
       * @method on
       * @param  {string}   eventName The event name to listen for.
       * @param  {Function} callback  The function to call when the event occurs. Depending on the event, this 
       *                              callback can receive 0 or more arguments when called.
       * @example
       * 		obj.on('message', function(message) {
       * 			console.log(message);
       * 		});
       * @chainable
       */

    }, {
      key: "on",
      value: function on(eventName, callback) {
        // Get the set
        if (!this._listeners.has(eventName)) {
          this._listeners.set(eventName, new Set());
        }

        var events = this._listeners.get(eventName); // Add callback


        events.add(callback); // Chain

        return this;
      }
      /**
       * Remove a previously added listener for chosen event
       *
       * @method off
       * @param  {string}   eventName The event name to remove listener for
       * @param  {Function} callback  The previously added callback to remove from listeners
       * @chainable
       */

    }, {
      key: "off",
      value: function off(eventName, callback) {
        // Get the callbacks
        var callbacks = this._listeners.get(eventName);

        if (callbacks === undefined) return this; // Remove callback

        callbacks.delete(callback);
        return this;
      }
      /**
       * Trigger calling of all registered callbacks for given event
       * with given arguments.
       *
       * @method trigger
       * @param  {string}    eventName The event name to trigger callbacks for
       * @param  {...mixed}  args      Zero or more arguments to pass along to each callback
       * @chainable
       */

    }, {
      key: "trigger",
      value: function trigger(eventName) {
        var _this2 = this;

        for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
          args[_key5 - 1] = arguments[_key5];
        }

        // Get the callbacks
        var callbacks = this._listeners.get(eventName);

        if (callbacks === undefined) return this; // Loop and call

        callbacks.forEach(function (cb) {
          cb.apply(_this2, args);
        });
        return this;
      } /////////////////////
      // Private methods //
      /////////////////////

    }]);

    return Obj;
  }();

  var Reference =
  /*#__PURE__*/
  function () {
    function Reference(observable, path) {
      _classCallCheck(this, Reference);

      this.observable = observable;
      this.path = path;
    }

    _createClass(Reference, [{
      key: "getValue",
      value: function getValue() {
        return this.observable.get(this.path);
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.observable.set(this.path, value);
        return this;
      }
    }, {
      key: "watch",
      value: function watch(callback) {
        this.observable.observe(this.path, callback);
      }
    }]);

    return Reference;
  }();

  /**
   * @module Helpers
   */
  var ClassMap = {
    classes: new Map(),
    get: function get(className) {
      return this.classes.get(className);
    },
    register: function register(className, c) {
      this.classes.set(className, c);
      return this;
    },
    create: function create(className) {
      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var c = ClassMap.get(className);
      if (c === undefined) throw new Error('The ' + className + ' class is not registered in the ClassMap');
      return _construct(c, _toConsumableArray(args));
    },
    isA: function isA(obj, className) {
      var c = ClassMap.get(className);
      if (c === undefined) throw new Error('The ' + className + ' class is not registered in the ClassMap');
      return obj instanceof c;
    }
  };

  /**
   * @module Core
   */

  var ComputedProperty =
  /*#__PURE__*/
  function () {
    /**
     * @class Core.ComputedProperty
     * 
     * @constructor
     * @param  {Array}   			dependencies 
     * @param  {Function} 			callback     	 
     */
    function ComputedProperty(dependencies, callback) {
      _classCallCheck(this, ComputedProperty);

      /**
       * The Observable instance that this computed attribute is
       * a part of.
       * 
       * @property observable
       * @type {Core.Observable}
       */
      this.observable = null;
      /**
       * The attribute name within the Observable that this ComputedProperty
       * represents.
       * 
       * @property name
       * @type {string}
       */

      this.name = null;
      /**
       * The names of the attributes that this compution depends on. These
       * attributes will also be injected into the callback.
       *
       * @property dependencies
       * @type {array}
       */

      this.dependencies = dependencies;
      /**
       * The compution function that is called when the value is requested.
       *
       * @property callback
       * @type {Function}
       */

      this.callback = callback;
    }
    /**
     * Get the current computed value 
     *
     * @method getValue
     * @return {mixed}
     */


    _createClass(ComputedProperty, [{
      key: "getValue",
      value: function getValue() {
        var _this = this;

        // Get dependency values
        var args = [];

        underscore.each(this.dependencies, function (dep) {
          args.push(_this.observable.get(dep));
        }); // Do the callback


        return this.callback.apply(this.observable, args);
      }
      /**
       * Alias of `getValue`
       * 
       * @method toString
       * @return {mixed}
       */

    }, {
      key: "toString",
      value: function toString() {
        return this.getValue();
      }
      /**
       * Make this property part of an Observable object, and 
       * start watching for changes.
       * 
       * @method initialize
       * @param {string} name 					The name op the property
       * @param {Core.Observable} observable 		The observable instance this property is a part of
       * @chainable
       */

    }, {
      key: "initialize",
      value: function initialize(name, observable) {
        var _this2 = this;

        // Localize
        this.name = name;
        this.observable = observable; // Watch the properties

        this.observable.observe(this.dependencies, function () {
          _this2.observable._scheduleAttributeChanged(_this2.name);
        });
        return this;
      }
    }]);

    return ComputedProperty;
  }();

  /**
   * @module Core
   */

  var Observable =
  /*#__PURE__*/
  function (_Obj) {
    _inherits(Observable, _Obj);

    /**
     * The basic object class that notifies **observers** and **students** about 
     * changes in its attributes. 
     *
     * ## Observers
     * An observer is an object (in actuality a callback) that watches for changes on 
     * a certain attribute or it's child attributes, in case of nested Observables. 
     * An observer can {{#crossLink "Core.Observable/disregard"}}{{/crossLink}} the attribute to stop watching.
     *
     * 	// Initialize object and watch for changes
     * 	var obj = new Chicken.Core.Observable();
     * 	obj.set('foo', 'bar');
     * 	var callback = () => {
     * 		alert('Changed: ' + obj.get('foo'));
     * 	};
     * 	obj.observe('foo', callback);
     * 	
     * 	// Change
     * 	obj.set('foo', 'boo'); // Will alert 'Changed: boo'
     * 	
     * 	// Stop watching
     * 	obj.disregard('foo', callback);
     * 	obj.set('foo', 'back-to-bar'); // Will not alert anthing
     *
     * ## Students
     * A student is an object (in actuality a callback) that watches for changes in
     * **any attribute** or any **child attribute**, in case of nested Observables.
     * An observer can **neglect** their study to stop wachting.
     *
     * 	// Initialize object
     * 	var obj = new Chicken.Core.Observable();
     * 	obj.set('foo', 'bar');
     * 	var childObj = new Chicken.Core.Observable();
     * 	childObj.set('free', 'willy');
     * 	obj.set('child', childObj);
     *
     * 	// Listen
     * 	var callback = (changedAttributes) {
     * 		console.log(changedAttributes);
     * 	};
     * 	obj.study(callback);
     *
     * 	// Update attributes
     *	obj.set('foo', 'boo');                  // Will log ['foo']
     *	obj.get('child').set('free', 'tibet');  // Will log ['child']
     * 	childObj.set('foo', 'bee');             // Will log ['child']
     *
     * 	// Neglect my study
     * 	obj.neglect(callback);
     * 	obj.set('foo', 'back to bar');          // Will not log anything
     *
     * @class Core.Observable
     * @extends Core.Object
     *
     * @constructor
     * @param  {Object}  [initValues={}]       			 A hash of key-value pairs to initialize the object with
     * @param  {Boolean} [convertToObservables=true]	 Whether to convert any Object and Array values in the `initValues` parameter into Observable and ObservableArray instance
     **/
    function Observable() {
      var _this;

      var initValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var convertToObservables = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      _classCallCheck(this, Observable);

      // Basics
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Observable).call(this)); ////////////////
      // Properties //
      ////////////////

      /**
       * @property observers
       * @type {Map}
       */

      _this.observers = new Map();
      /**
       * @attribute attributes
       * @type {object}
       */

      _this.attributes = {};
      /**
       * Whenever this property is true, no notifications will be triggered
       * 
       * @attribute notificationsDisabled
       * @type {Boolean}
       */

      _this.notificationsDisabled = false; // Scheduling

      _this._scheduleAttributesChangedTimeout = false;
      _this._scheduleAttributesChangedAttributes = null; ////////////////////
      // Initialization //
      ////////////////////
      // Initialize values

      _this.withoutNotifications(function () {
        _this.import(initValues, convertToObservables);
      }); // Properties for internal use


      _this._bindings = {};
      return _this;
    } ////////////////////
    // Public methods //
    ////////////////////

    /**
     * Check if attribute is defined
     *
     * @method has
     * @param  {string}  key The name of the key to check
     * @return {Boolean}     True when the attribute has been defined
     */


    _createClass(Observable, [{
      key: "has",
      value: function has(key) {
        // Split
        var parts = Number.isInteger(key) ? [key] : key.split(/\./);
        var currentPart = parts.shift(); // No deep shit?

        if (parts.length === 0) return this._has(currentPart) !== undefined; // Look deeper

        var value = this._get(currentPart); // No value


        if (value === undefined) {
          return false;
        } // Check if the value is also an observable


        if (Observable.isObservable(value)) {
          // Pass the rest along to go a level deeper
          return value.has(parts.join('.'));
        } else {
          return false;
        }
      }
    }, {
      key: "_has",
      value: function _has(key) {
        return this.attributes[key] !== undefined;
      }
      /**
       * Get attribute from object
       *
       * @method get
       * @param  {string} key The name of the key to retrieve the value of. You can use dot-notation to use deep-getting
       * @return The value or undefined when the key is not set
       */

    }, {
      key: "get",
      value: function get(key) {
        // Split
        if (key === undefined) throw new TypeError('There was no key provided');
        var parts = key;
        if (typeof key === 'string') parts = key.split(/\./);
        var currentPart = parts.shift(); // Get value

        var value = this._get(currentPart); // Nothing?


        if (value === undefined) return; // Is it a reference?

        if (value instanceof Reference) {
          value = value.getValue();
        } // Value found?


        if (parts.length === 0) {
          // Is it computed?
          if (value instanceof ComputedProperty) {
            return value.getValue();
          } // Return the value as is.


          return value;
        } // Check if the value is also an observable


        if (Observable.isObservable(value)) {
          // Pass the rest along to go a level deeper
          return value.get(parts.join('.'));
        } else {
          // Nothing to be retrieved
          return; //throw new Error('The found value for ' + currentPart + ' is not an Observable and cannot be used with dot-notation to retreive subvalues. Value is ' + (typeof value));
        }
      }
    }, {
      key: "_get",
      value: function _get$$1(key) {
        return this.attributes[key];
      }
      /**
       * Set attribute on object. When you set a attribute on Observable, all
       * *observers* and *students* will be notified of the change.
       *
       * @method set
       * @param {string/array} key   	The name of the key to store the value of. You can use dot-notation to use deep-setting
       * @param {mixed} value 		The value to store
       * @param {boolean} [convertToObservables=false]
       *        						Whether to convert standard object values into Observable instances
       * @chainable
       */

    }, {
      key: "set",
      value: function set(key, value) {
        var _this2 = this;

        var convertToObservables = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        // Object given?
        if (_typeof(key) === 'object') {
          // Loop and set each
          underscore.each(key, function (v, k) {
            _this2.set(k, v, convertToObservables);
          });

          return this;
        } // Convert?


        if (convertToObservables === true && _typeof(value) === 'object' && value !== null) {
          if (value.constructor === Object) {
            value = new Observable(value);
          } else if (Array.isArray(value)) {
            value = ClassMap.create('ObservableArray', [value]);
          }
        } // Is it a computed attribute


        if (value instanceof ComputedProperty) {
          value.initialize(key, this);
        } // Is there a dot in there?


        if (typeof key === 'string' && key.match(/\.[\w]/)) {
          ////////////////////////
          // Split and deep set //
          ////////////////////////
          var parts = key.split(/\./);
          var currentPart = parts.shift(); // Does the first key not exist?

          if (this.attributes[currentPart] === undefined) {
            // Should it be an array?
            var newValue;

            if (Number.isInteger(parts[0]) || typeof parts[0] === 'string' && parts[0].match(/^\d+$/)) {
              // Create list (using classmap to prevent circular dependencies)
              newValue = ClassMap.create('ObservableArray');
            } else {
              // Create it
              newValue = new Observable();
            } // Store it


            this.attributes[currentPart] = newValue;
          } // Do deep setting


          this.get(currentPart).set(parts.join('.'), value);
          return this;
        } // Now set the attribute


        this.setAttribute(key, value, convertToObservables);
        return this;
      }
    }, {
      key: "setAttribute",
      value: function setAttribute(key, value) {
        var _this3 = this;

        // Is the value identical?
        if (ClassMap.get('Utils').areEqual(value, this.get(key))) {
          return this;
        } // Set it


        this._set(key, value); // Is the value observable?


        if (Observable.isObservable(value)) {
          // Study the object
          value.study(function () {
            _this3._scheduleAttributeChanged(key);
          });
        } // Is the value a reference?
        else if (value instanceof Reference) {
            // Study the object
            value.watch(function () {
              _this3._scheduleAttributeChanged(key);
            });
          } // Update attribute


        this._scheduleAttributeChanged(key);

        return this;
      }
    }, {
      key: "setIfChanged",
      value: function setIfChanged(key, value) {
        // Original
        var originalValue = this.get(key);
        if (originalValue == value) return this;
        return this.set(key, value);
      }
    }, {
      key: "_set",
      value: function _set$$1(key, value) {
        // Is there a current value that is a reference?
        if (this.attributes[key] instanceof Reference && !(value instanceof Reference)) {
          // Write the referenced value
          this.attributes[key].setValue(value);
        } else {
          // Store the value
          this.attributes[key] = value;
        }

        return this;
      }
    }, {
      key: "setSilently",
      value: function setSilently(key, value) {
        var _this4 = this;

        var convertToObservables = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        return this.withoutNotifications(function () {
          _this4.set(key, value, convertToObservables);
        });
      }
    }, {
      key: "unset",
      value: function unset(key) {
        this._unset(key); // Update attribute


        this._scheduleAttributeChanged(key);

        return this;
      }
    }, {
      key: "_unset",
      value: function _unset(key) {
        delete this.attributes[key];
      }
    }, {
      key: "import",
      value: function _import(obj) {
        var _this5 = this;

        var convertToObservables = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        // Import all items in hash
        this.withoutNotifications(function () {
          underscore.each(obj, function (value, key) {
            _this5.set(key, value, convertToObservables);
          });
        }); // Notify!

        if (!this.notificationsDisabled) this.trigger(Observable.Events.Import);
        return this;
      }
    }, {
      key: "fill",
      value: function fill(obj) {
        var _this6 = this;

        // Loop through object
        underscore.each(obj, function (value, key) {
          // Get existing value
          if (_this6.has(key)) {
            // Get value
            var curValue = _this6.get(key); // Observable?


            if (curValue instanceof Observable) {
              curValue.fill(value);
            } else {
              _this6.set(key, value, true);
            }
          } else {
            // Just set it.
            _this6.set(key, value, true);
          }
        });

        return this;
      }
      /**
       * Increment given attribute's numeric value
       *
       * @method increment
       * @param  {string} key          
       * @param  {Number} by           (Default = 1)
       * @param  {Number} defaultValue (Default = 0)
       * @chainable
       */

    }, {
      key: "increment",
      value: function increment(key) {
        var by = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var v = this.get(key);
        if (v === undefined || typeof v !== 'number') v = defaultValue;
        v += by;
        this.set(key, v);
        return this;
      }
      /**
       * Decrement given attribute's numeric value
       *
       * @method increment
       * @param  {string} key          
       * @param  {Number} by           (Default = 1)
       * @param  {Number} defaultValue (Default = 0)
       * @chainable
       */

    }, {
      key: "decrement",
      value: function decrement(key) {
        var by = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var v = this.get(key);
        if (v === undefined || typeof v !== 'number') v = defaultValue;
        v -= by;
        this.set(key, v);
        return this;
      }
      /**
       * Toggle the given attribute's boolean value
       *
       * @method toggle
       * @param  {string}  key                
       * @param  {Boolean} valueWhenUndefined  (Default = true) What value to set when the attribute does not have a value yet
       * @chainable
       */

    }, {
      key: "toggle",
      value: function toggle(key) {
        var valueWhenUndefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var v = this.get(key);

        if (v === undefined || typeof v !== 'boolean') {
          v = valueWhenUndefined;
        } else {
          v = !v;
        }

        this.set(key, v);
        return this;
      }
      /**
       * Listen for any changes in any of the object's attributes. 
       * The callback will receive an array containing the names of
       * all updates attributes. 
       *
       * Note: This is an alias of the 'change' event, so calling
       * ```this.on('change', callback)``` will achieve the same result.
       *
       * @example
       * 	// Initialize object
       * 	var obj = new Chicken.Core.Observable();
       * 	obj.set('foo', 'bar');
       * 	var childObj = new Chicken.Core.Observable();
       * 	childObj.set('free', 'willy');
       * 	obj.set('child', childObj);
       *
       * 	// Listen
       * 	obj.study((changedAttributes) {
       * 		console.log(changedAttributes);
       * 	});
       *
       * 	// Update attributes
       *	obj.set('foo', 'boo');                  // Will log ['foo']
       *	obj.get('child').set('free', 'tibet');  // Will log ['child']
       * 	childObj.set('foo', 'bee');             // Will log ['child']
       *
       * @method study
       * @param  {Function} callback
       * @chainable
       */

    }, {
      key: "study",
      value: function study(callback) {
        // This is an alias of the 'change' event
        return this.on(Observable.Events.Change, callback);
      }
      /**
       * Stop listening for changes on the object's attributes.
       *
       * Note: This is an alias of the 'change' event, so calling
       * ```this.off('change', callback)``` will achieve the same result.
       *
       * @example
       * 
       * 
       * @method neglect
       * @param  {Function} callback 
       * @chainable
       */

    }, {
      key: "neglect",
      value: function neglect(callback) {
        // This is an alias of the 'change' event
        return this.off(Observable.Events.Change, callback);
      }
      /**
       * Observe the attribute with given key, so that callback is called
       * whenever the attribute or it's child attributes change.
       *
       * 	// Initialize object and watch for changes
       * 	var obj = new Chicken.Core.Observable();
       * 	obj.set('foo', 'bar');
       * 	var callback = () => {
       * 		alert('Changed: ' + obj.get('foo'));
       * 	};
       * 	obj.observe('foo', callback);
       * 	
       * 	// Change
       * 	obj.set('foo', 'boo'); // Will alert 'Changed: boo'
       * 	
       * @method observe
       * @param  {string|array}   key      The name of the attribute to observe
       * @param  {Function} callback 
       * @chainable
       */

    }, {
      key: "observe",
      value: function observe(keyOrKeys, callback) {
        var _this7 = this;

        ////////////////////
        // More than one? //
        ////////////////////
        if (Array.isArray(keyOrKeys)) {
          underscore.each(keyOrKeys, function (key) {
            _this7.observe(key, callback);
          });

          return this;
        }

        var key = keyOrKeys; //////////////////////////////
        // Does the key have a dot? //
        //////////////////////////////

        var parts = key.split(/\./);

        if (parts.length > 1) {
          // Get the object concerned
          var attrKey = parts.shift();
          var obj = this.get(attrKey);
          var objKey = parts.join('.'); // Is it an observable?

          if (Observable.isObservable(obj) && obj.observe) {
            // Observe this observable itself
            this.observe(attrKey, callback); // Go deeper

            return obj.observe(objKey, callback);
          }

          throw new Error('Cannot observe property of non-existing object: ' + key);
        } //////////////////
        // Add observer //
        //////////////////


        if (!this.observers.has(key)) {
          this.observers.set(key, new Set());
        }

        var observers = this.observers.get(key); // Add callback

        observers.add(callback);
        return this;
      }
      /**
       * Stop observing the attribute with given key, or any of it's
       * child attributes.
       *
       * @method disregard
       * @param  {string}   key      The name of the attribute to disregard
       * @param  {Function} callback 
       * @chainable
       */

    }, {
      key: "disregard",
      value: function disregard(key, callback) {
        // Get the observers
        var observers = this.observers.get(key);
        if (observers === undefined) return this; // Remove callback

        observers.delete(callback);
        return this;
      }
      /**
       * Get the Observable including all its children
       * as a native object.
       *
       * @method toObject
       * @return {object}
       */

    }, {
      key: "toObject",
      value: function toObject() {
        var includedUids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var obj = {};

        underscore.each(this.attributes, function (item, key) {
          // Observable?
          if (Observable.isObservable(item)) {
            // Already included?
            var guid = ClassMap.get('Utils').uidFor(item);

            if (underscore.indexOf(includedUids, guid) !== -1) {
              obj[key] = '...recursive(' + guid + ')...';
              return;
            }

            includedUids.push(guid); // Array?

            if (item instanceof Observable) {
              item = item.toObject(includedUids);
            } else {
              item = item.toArray(includedUids);
            }
          }

          obj[key] = item;
        });

        return obj;
      }
      /**
       * Apply given callback for each attribute defined in this observable
       *
       * @method each
       * @param  {Function} callback
       * @chainable
       */

    }, {
      key: "each",
      value: function each(callback) {
        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        underscore.each(this.attributes, callback, context);

        return this;
      }
      /**
       * Execute given callback without triggering change notifications.
       * 
       * @method withoutNotifications
       * @param  {Function} callback 
       * @chainable
       */

    }, {
      key: "withoutNotifications",
      value: function withoutNotifications(callback) {
        var wasDisabled = this.notificationsDisabled;
        this.notificationsDisabled = true;
        callback();
        this.notificationsDisabled = wasDisabled;
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        var convertToObservables = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        // Make copy!
        var c = this.constructor;
        var copy = new c(this.toObject(), convertToObservables);
        return copy;
      } /////////////////////
      // Private methods //
      /////////////////////

    }, {
      key: "_scheduleAttributeChanged",
      value: function _scheduleAttributeChanged(key) {
        var _this8 = this;

        // Notifications disabled?
        if (this.notificationsDisabled) return; // Already something scheduled?

        if (!this._scheduleAttributesChangedTimeout) {
          // Schedule it
          this._scheduleAttributesChangedAttributes = [];
          this._scheduleAttributesChangedTimeout = setTimeout(function () {
            // Trigger it now!
            _this8._scheduleAttributesChangedTimeout = false;

            _this8._triggerAttributesChanged();
          }, Observable.AttributeChangedDelay);
        } // Add attribute to the set


        this._scheduleAttributesChangedAttributes.push(key);
      }
    }, {
      key: "_triggerAttributesChanged",
      value: function _triggerAttributesChanged() {
        var _this9 = this;

        // Notifications disabled?
        if (this.notificationsDisabled) return; // Clear for next time.

        if (this._scheduleAttributesChangedTimeout) clearTimeout(this._scheduleAttributesChangedTimeout);
        this._scheduleAttributesChangedTimeout = false; // Check my attributes

        var attrs = underscore.unique(this._scheduleAttributesChangedAttributes);

        if (attrs) {
          // Collect the observers, using a Set to make sure the same observer can't be called twice
          var combinedObservers = new Set();

          underscore.each(attrs, function (attr) {
            // Get observers
            var attrObservers = _this9.observers.get(attr);

            if (attrObservers) {
              attrObservers.forEach(function (observer) {
                // Add it.
                combinedObservers.add(observer);
              });
            }
          }); // Did we have any observers?


          combinedObservers.forEach(function (observer) {
            // Now call it.
            observer.apply(_this9);
          }); // Students as well.

          this.trigger(Observable.Events.Change, attrs);
        }
      }
    }, {
      key: "isObservable",
      value: function isObservable() {
        return true;
      }
    }]);

    return Observable;
  }(Obj); ////////////
  // Events //
  ////////////


  Observable.Events = {
    /**
     * This event is fired whenever anything changes in the array
     * of one of its observable items.
     * 
     * @event change
     */
    Change: 'change',

    /**
     * This event is fired whenever an import is completed
     *
     * @event import
     */
    Import: 'import'
  };

  Observable.isObservable = function (obj) {
    return _typeof(obj) === 'object' && obj !== null && typeof obj.isObservable === 'function' && obj.isObservable() === true;
  };

  Observable.AttributeChangedDelay = 1;
  ClassMap.register('Observable', Observable);

  function Chainable (cls) {
    cls.create = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _construct(cls, args);
    };

    return cls;
  }

  /**
   * @module Core
   */

  var SettingsObject =
  /*#__PURE__*/
  function (_Observable) {
    _inherits(SettingsObject, _Observable);

    /**
     * @class Core.SettingsObject
     * @extends Core.Observable
     *
     * @constructor
     * @param {object}  defaultSettings  	Initialize with these default settings
     * @param {array}   [allowedKeys] 		Optional array of allowed keys. By default all keys are allowed	 
     */
    function SettingsObject() {
      var _this;

      var defaultSettings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var allowedKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      _classCallCheck(this, SettingsObject);

      // Instantiate with default settings
      _this = _possibleConstructorReturn(this, _getPrototypeOf(SettingsObject).call(this, defaultSettings));
      /**
       * @property allowedKeys
       * @type Array
       */

      _this.allowedKeys = allowedKeys;
      _this.notificationsDisabled = true;
      return _this;
    }
    /**
     * Apply given settings
     *
     * @method apply
     * @param {object} 	settings	A hash-object with keys and values
     * @chainable
     */


    _createClass(SettingsObject, [{
      key: "apply",
      value: function apply(settings) {
        var _this2 = this;

        // Apply each key individually
        underscore.each(settings, function (value, key) {
          _this2.set(key, value);
        });

        return this;
      } // Extra check for allowedKeys.

    }, {
      key: "set",
      value: function set(key, value) {
        // Is it allowed?
        if (this.allowedKeys && this.allowedKeys.length > 0 && !underscore.contains(this.allowedKeys, key)) {
          throw new Error('This SettingsObject does not have a setting for "' + key + '". The allowed settings are: ' + this.allowedKeys.join(', '));
        } // Do it.


        return _get(_getPrototypeOf(SettingsObject.prototype), "set", this).call(this, key, value);
      }
    }]);

    return SettingsObject;
  }(Observable);

  var SettingsObject$1 = Chainable(SettingsObject);

  /**
   * @module Dom
   */

  var Element =
  /*#__PURE__*/
  function (_Obj) {
    _inherits(Element, _Obj);

    /**
     * @class Dom.Element
     * @extends Core.Obj
     *
     * @constructor
     * @param {jQuery} $element
     * @param {Application} [application]
     */
    function Element($element) {
      var _this;

      _classCallCheck(this, Element);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Element).call(this));
      /**
       * The jQuery element that is the ViewContainer
       * 
       * @property $element
       * @type {jQuery}
       */

      _this.$element = $element;
      return _this;
    }

    _createClass(Element, [{
      key: "setContent",
      value: function setContent(content) {
        // Fire the before hooks.
        this._fireHooks('beforeRender'); // Set it


        this.$element.html(content);
        this.trigger('content', content); // Fire the after hooks

        this._fireHooks('afterRender');
      }
    }, {
      key: "_fireHooks",
      value: function _fireHooks(type) {
        var _this2 = this;

        underscore.each(Element.Hooks[type], function (callback) {
          // Fire it.
          callback.apply(_this2, [_this2.$element, _this2]);
        });
      }
    }]);

    return Element;
  }(Obj);

  Element.registerHook = function (callback) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'afterRender';
    Element.Hooks[type].push(callback);
    return true;
  };

  Element.Hooks = {
    beforeRender: [],
    afterRender: []
  };

  /** 
   * @module Dom
   */
  var Transition =
  /*#__PURE__*/
  function () {
    function Transition($container, $fromContent, $toContent, name) {
      _classCallCheck(this, Transition);

      /**
       * @property $container
       * @type {jQuery}
       */
      this.$container = $container;
      this.$from = $fromContent;
      this.$to = $toContent;
      this.name = name;
      this.viewWidth = false;
      this.viewHeight = false;
      this.duration = null; // Existing?

      if (Transition[name] === undefined) {
        throw new Error("There is no Transition registered under the key \"".concat(name, "\""));
      }
    }

    _createClass(Transition, [{
      key: "play",
      value: function play() {
        var _this = this;

        // Get obj
        var obj = Transition[this.name]; // Generic preparation

        this._prepare(); // Position content


        var newContentPosition = obj.newContentPosition || 'right';

        switch (newContentPosition) {
          case 'default':
            this.$to.css({
              left: 0,
              top: 0
            });
            break;

          case 'transparent':
            this.$to.css({
              left: 0,
              top: 0,
              opacity: 0
            });
            break;

          case 'right':
            this.$to.css({
              left: this.viewWidth,
              top: 0
            });
            break;

          case 'left':
            this.$to.css({
              left: -this.viewWidth,
              top: 0
            });
            break;

          default:
            throw new Error("Unknown newContentPosition: ".concat(newContentPosition));
        } // Add the new content


        this.$container.append(this.$to); // Now play it

        var result = obj.play(this, this.$from, this.$to);
        if (!result || !(result instanceof Promise)) throw new Error("Transition.".concat(this.name, ".play($from, $to) should return a Promise"));
        result.then(function () {
          // Reset 
          _this._finish();
        });
        return result;
      }
    }, {
      key: "_prepare",
      value: function _prepare() {
        // Get width
        this.viewWidth = this.$container.width();
        this.viewHeight = this.$container.height(); // Style container

        this.$container.css({
          position: 'relative',
          width: this.viewWidth,
          height: this.viewHeight,
          overflow: 'hidden'
        }); // Set style to content

        if (this.$from) {
          this.$from.css({
            position: 'absolute',
            width: this.viewWidth,
            height: this.viewHeight,
            zIndex: 10
          });
        }

        this.$to.css({
          position: 'absolute',
          width: this.viewWidth,
          height: this.viewHeight,
          zIndex: 20
        });
      }
    }, {
      key: "_finish",
      value: function _finish() {
        this.$container.css({
          width: '',
          height: ''
        });
        this.$to.css({
          width: '',
          height: ''
        });
      }
    }]);

    return Transition;
  }(); // ███████╗██╗     ██╗██████╗ ███████╗    ██╗     ███████╗███████╗████████╗
  // ██╔════╝██║     ██║██╔══██╗██╔════╝    ██║     ██╔════╝██╔════╝╚══██╔══╝
  // ███████╗██║     ██║██║  ██║█████╗      ██║     █████╗  █████╗     ██║   
  // ╚════██║██║     ██║██║  ██║██╔══╝      ██║     ██╔══╝  ██╔══╝     ██║   
  // ███████║███████╗██║██████╔╝███████╗    ███████╗███████╗██║        ██║   
  // ╚══════╝╚══════╝╚═╝╚═════╝ ╚══════╝    ╚══════╝╚══════╝╚═╝        ╚═╝   
  //                                                                         


  Transition.slideLeft = {
    newContentPosition: 'right',
    play: function play(transition, $from, $to) {
      // Promise
      return new Promise(function (resolve) {
        // Options
        var options = {
          duration: transition.duration || 250
        }; // Move out the old

        if ($from) {
          $from.animate({
            left: -transition.viewWidth
          }, options);
        } // Move in the new


        options.complete = function () {
          resolve();
        };

        $to.animate({
          left: 0
        }, options);
      });
    }
  }; // ███████╗██╗     ██╗██████╗ ███████╗    ██████╗ ██╗ ██████╗ ██╗  ██╗████████╗
  // ██╔════╝██║     ██║██╔══██╗██╔════╝    ██╔══██╗██║██╔════╝ ██║  ██║╚══██╔══╝
  // ███████╗██║     ██║██║  ██║█████╗      ██████╔╝██║██║  ███╗███████║   ██║   
  // ╚════██║██║     ██║██║  ██║██╔══╝      ██╔══██╗██║██║   ██║██╔══██║   ██║   
  // ███████║███████╗██║██████╔╝███████╗    ██║  ██║██║╚██████╔╝██║  ██║   ██║   
  // ╚══════╝╚══════╝╚═╝╚═════╝ ╚══════╝    ╚═╝  ╚═╝╚═╝ ╚═════╝ ╚═╝  ╚═╝   ╚═╝   
  //                                                                             

  Transition.slideRight = {
    newContentPosition: 'left',
    play: function play(transition, $from, $to) {
      // Promise
      return new Promise(function (resolve) {
        // Options
        var options = {
          duration: transition.duration || 250
        }; // Move out the old

        if ($from) {
          $from.animate({
            left: transition.viewWidth
          }, options);
        } // Move in the new


        options.complete = function () {
          resolve();
        };

        $to.animate({
          left: 0
        }, options);
      });
    }
  }; // ███████╗ █████╗ ██████╗ ███████╗
  // ██╔════╝██╔══██╗██╔══██╗██╔════╝
  // █████╗  ███████║██║  ██║█████╗  
  // ██╔══╝  ██╔══██║██║  ██║██╔══╝  
  // ██║     ██║  ██║██████╔╝███████╗
  // ╚═╝     ╚═╝  ╚═╝╚═════╝ ╚══════╝
  //                                 

  Transition.fade = {
    newContentPosition: 'transparent',
    play: function play(transition, $from, $to) {
      // Promise
      return new Promise(function (resolve) {
        // Options
        var options = {
          duration: transition.duration || 250
        }; // Move in the new

        options.complete = function () {
          resolve();
        };

        $to.animate({
          opacity: 1
        }, options);
      });
    }
  };

  /**
   * @module Dom
   */

  var ViewContainer =
  /*#__PURE__*/
  function (_Element) {
    _inherits(ViewContainer, _Element);

    /**
     * A ViewContainer is en DomElement in your application that
     * can contain a rendered View. Each ViewContainer needs a 
     * unique name, and the main ViewContainer for the application
     * is always called 'main'.
     * 
     * @class Dom.ViewContainer 
     * @extends Core.Object
     *
     * @constructor
     * @param {jQuery} $element
     * @param {Application} application
     */
    function ViewContainer($element, application) {
      var _this;

      _classCallCheck(this, ViewContainer);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ViewContainer).call(this, $element, application)); // Private props

      _this._isLoading = false; ////////////////
      // Properties //
      ////////////////

      /**
       * The unique name you can use in your routes to target this
       * ViewContainer.
       * 
       * @property name
       * @type {string}
       */

      _this.name = ViewContainer.getViewName($element);
      /**
       * The Routing.Action that rendered the content that is currently
       * in this ViewContainer
       * 
       * @property currentAction
       * @type {Routing.Action}
       */

      _this.currentAction = null;
      /**
       * The default transition to use for this ViewContainer
       * 
       * @property defaultTransition
       * @type {string}
       */

      _this.defaultTransition = $element.attr('transition');
      /**
       * @property transitionsDisabled
       * @type {boolean}
       */

      _this.transitionsDisabled = false;
      /**
       * Currently active content 
       * 
       * @property $currentContent
       * @type {jQuery}
       */

      _this.$currentContent = null;
      _this.currentView = null;
      return _this;
    }
    /**
     * Initialize the ViewContainer. 
     *
     * @method initialize
     * @chainable
     */


    _createClass(ViewContainer, [{
      key: "initialize",
      value: function initialize() {
        this.$element.addClass(ViewContainer.Classes.Initialized);
        return this;
      }
      /**
       * @method setActionContent
       * @param {string} 				content 			The (HTML) content to render
       * @param {boolean}				setLoadingFalse		Whether to set the loading-state to false
       * @chainable
       */

    }, {
      key: "setContent",
      value: function setContent(content) {
        var _this2 = this;

        var setLoadingFalse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        // Transition?
        var transition = this.currentAction.transition;

        if (!transition && transition !== false) {
          // Use my default transition
          transition = this.defaultTransition;
        } // No longer loading


        if (setLoadingFalse) this.setLoading(false); // Use transition?

        this.transitionContent(content, transition).then(function () {
          // Apply hooks
          ViewContainer.any.trigger('render', _this2);
        });
        return this;
      }
    }, {
      key: "transitionContent",
      value: function transitionContent(newContent, transitionName) {
        var _this3 = this;

        return new Promise(function (resolve) {
          // Put content into container
          var $newContent = jquery('<div class="view-container-element" />').html(newContent); // No transition?

          if (!transitionName || transitionName === 'none' || _this3.transitionsDisabled) {
            // Remove old content
            _this3._fireHooks('beforeRender');

            _this3.$element.find('.view-container-element').remove(); // Set content now


            _this3.$element.append($newContent); // Switch!


            _this3.$currentContent = $newContent;

            _this3.trigger('content', newContent);

            _this3._fireHooks('afterRender');

            return resolve();
          } // Create transition


          var transition = new Transition(_this3.$element, _this3.$currentContent, $newContent, transitionName);

          _this3._fireHooks('beforeRender');

          transition.play().then(function () {
            // Remove old content
            if (_this3.$currentContent) {
              _this3.$currentContent.remove();
            } // Switch!


            _this3.$currentContent = $newContent;

            _this3.trigger('content', newContent);

            _this3._fireHooks('afterRender'); // Done!


            resolve();
          });
        });
      }
    }, {
      key: "setView",
      value: function setView(view) {
        this.currentView = view;
        return this;
      }
    }, {
      key: "setAction",
      value: function setAction(action) {
        this.currentAction = action;
        return this;
      }
    }, {
      key: "setLoading",
      value: function setLoading() {
        var loading = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this._isLoading = loading;
        this.$element.toggleClass(ViewContainer.Classes.Loading, loading);
        return this;
      }
    }, {
      key: "isLoading",
      value: function isLoading() {
        return this._isLoading;
      }
    }, {
      key: "isInDom",
      value: function isInDom() {
        return this.$element.closest(document.documentElement).length > 0;
      }
    }]);

    return ViewContainer;
  }(Element);

  ViewContainer.Classes = {
    Initialized: 'initialized',
    Loading: 'loading'
  };
  ViewContainer.ElementSelector = 'view-container:not(.initialized),[view-container]:not(.initialized)';
  ViewContainer.DefaultName = 'main';

  ViewContainer.getViewName = function ($element) {
    // Get it either from the name-attr or view-attr
    var name = $element.is('view-container') ? $element.attr('name') : $element.attr('view-container'); // No?

    if (!name) name = ViewContainer.DefaultName;
    return name;
  };

  ViewContainer.any = new Obj();

  var utils = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.clear = clear;
  exports.insertBefore = insertBefore;
  // inclusive of both nodes

  function clear(parentNode, firstNode, lastNode) {
    if (!parentNode) {
      return;
    }

    var node = firstNode;
    var nextNode;
    do {
      nextNode = node.nextSibling;
      parentNode.removeChild(node);
      if (node === lastNode) {
        break;
      }
      node = nextNode;
    } while (node);
  }

  function insertBefore(parentNode, firstNode, lastNode, refNode) {
    var node = firstNode;
    var nextNode;
    do {
      nextNode = node.nextSibling;
      parentNode.insertBefore(node, refNode);
      if (node === lastNode) {
        break;
      }
      node = nextNode;
    } while (node);
  }

  });

  unwrapExports(utils);
  var utils_1 = utils.clear;
  var utils_2 = utils.insertBefore;

  var morphRange = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;



  // constructor just initializes the fields
  // use one of the static initializers to create a valid morph.
  function Morph(domHelper, contextualElement) {
    this.domHelper = domHelper;
    // context if content if current content is detached
    this.contextualElement = contextualElement;
    // inclusive range of morph
    // these should be nodeType 1, 3, or 8
    this.firstNode = null;
    this.lastNode = null;

    // flag to force text to setContent to be treated as html
    this.parseTextAsHTML = false;

    // morph list graph
    this.parentMorphList = null;
    this.previousMorph = null;
    this.nextMorph = null;
  }

  Morph.empty = function (domHelper, contextualElement) {
    var morph = new Morph(domHelper, contextualElement);
    morph.clear();
    return morph;
  };

  Morph.create = function (domHelper, contextualElement, node) {
    var morph = new Morph(domHelper, contextualElement);
    morph.setNode(node);
    return morph;
  };

  Morph.attach = function (domHelper, contextualElement, firstNode, lastNode) {
    var morph = new Morph(domHelper, contextualElement);
    morph.setRange(firstNode, lastNode);
    return morph;
  };

  Morph.prototype.setContent = function Morph$setContent(content) {
    if (content === null || content === undefined) {
      return this.clear();
    }

    var type = typeof content;
    switch (type) {
      case 'string':
        if (this.parseTextAsHTML) {
          return this.domHelper.setMorphHTML(this, content);
        }
        return this.setText(content);
      case 'object':
        if (typeof content.nodeType === 'number') {
          return this.setNode(content);
        }
        /* Handlebars.SafeString */
        if (typeof content.toHTML === 'function') {
          return this.setHTML(content.toHTML());
        }
        if (this.parseTextAsHTML) {
          return this.setHTML(content.toString());
        }
      /* falls through */
      case 'boolean':
      case 'number':
        return this.setText(content.toString());
      case 'function':
        raiseCannotBindToFunction(content);
      default:
        throw new TypeError('unsupported content');
    }
  };

  function raiseCannotBindToFunction(content) {
    var functionName = content.name;
    var message;

    if (functionName) {
      message = 'Unsupported Content: Cannot bind to function `' + functionName + '`';
    } else {
      message = 'Unsupported Content: Cannot bind to function';
    }

    throw new TypeError(message);
  }

  Morph.prototype.clear = function Morph$clear() {
    var node = this.setNode(this.domHelper.createComment(''));
    return node;
  };

  Morph.prototype.setText = function Morph$setText(text) {
    var firstNode = this.firstNode;
    var lastNode = this.lastNode;

    if (firstNode && lastNode === firstNode && firstNode.nodeType === 3) {
      firstNode.nodeValue = text;
      return firstNode;
    }

    return this.setNode(text ? this.domHelper.createTextNode(text) : this.domHelper.createComment(''));
  };

  Morph.prototype.setNode = function Morph$setNode(newNode) {
    var firstNode, lastNode;
    switch (newNode.nodeType) {
      case 3:
        firstNode = newNode;
        lastNode = newNode;
        break;
      case 11:
        firstNode = newNode.firstChild;
        lastNode = newNode.lastChild;
        if (firstNode === null) {
          firstNode = this.domHelper.createComment('');
          newNode.appendChild(firstNode);
          lastNode = firstNode;
        }
        break;
      default:
        firstNode = newNode;
        lastNode = newNode;
        break;
    }

    this.setRange(firstNode, lastNode);

    return newNode;
  };

  Morph.prototype.setRange = function (firstNode, lastNode) {
    var previousFirstNode = this.firstNode;
    if (previousFirstNode !== null) {

      var parentNode = previousFirstNode.parentNode;
      if (parentNode !== null) {
        utils.insertBefore(parentNode, firstNode, lastNode, previousFirstNode);
        utils.clear(parentNode, previousFirstNode, this.lastNode);
      }
    }

    this.firstNode = firstNode;
    this.lastNode = lastNode;

    if (this.parentMorphList) {
      this._syncFirstNode();
      this._syncLastNode();
    }
  };

  Morph.prototype.destroy = function Morph$destroy() {
    this.unlink();

    var firstNode = this.firstNode;
    var lastNode = this.lastNode;
    var parentNode = firstNode && firstNode.parentNode;

    this.firstNode = null;
    this.lastNode = null;

    utils.clear(parentNode, firstNode, lastNode);
  };

  Morph.prototype.unlink = function Morph$unlink() {
    var parentMorphList = this.parentMorphList;
    var previousMorph = this.previousMorph;
    var nextMorph = this.nextMorph;

    if (previousMorph) {
      if (nextMorph) {
        previousMorph.nextMorph = nextMorph;
        nextMorph.previousMorph = previousMorph;
      } else {
        previousMorph.nextMorph = null;
        parentMorphList.lastChildMorph = previousMorph;
      }
    } else {
      if (nextMorph) {
        nextMorph.previousMorph = null;
        parentMorphList.firstChildMorph = nextMorph;
      } else if (parentMorphList) {
        parentMorphList.lastChildMorph = parentMorphList.firstChildMorph = null;
      }
    }

    this.parentMorphList = null;
    this.nextMorph = null;
    this.previousMorph = null;

    if (parentMorphList && parentMorphList.mountedMorph) {
      if (!parentMorphList.firstChildMorph) {
        // list is empty
        parentMorphList.mountedMorph.clear();
        return;
      } else {
        parentMorphList.firstChildMorph._syncFirstNode();
        parentMorphList.lastChildMorph._syncLastNode();
      }
    }
  };

  Morph.prototype.setHTML = function (text) {
    var fragment = this.domHelper.parseHTML(text, this.contextualElement);
    return this.setNode(fragment);
  };

  Morph.prototype.setMorphList = function Morph$appendMorphList(morphList) {
    morphList.mountedMorph = this;
    this.clear();

    var originalFirstNode = this.firstNode;

    if (morphList.firstChildMorph) {
      this.firstNode = morphList.firstChildMorph.firstNode;
      this.lastNode = morphList.lastChildMorph.lastNode;

      var current = morphList.firstChildMorph;

      while (current) {
        var next = current.nextMorph;
        current.insertBeforeNode(originalFirstNode, null);
        current = next;
      }
      originalFirstNode.parentNode.removeChild(originalFirstNode);
    }
  };

  Morph.prototype._syncFirstNode = function Morph$syncFirstNode() {
    var morph = this;
    var parentMorphList;
    while (parentMorphList = morph.parentMorphList) {
      if (parentMorphList.mountedMorph === null) {
        break;
      }
      if (morph !== parentMorphList.firstChildMorph) {
        break;
      }
      if (morph.firstNode === parentMorphList.mountedMorph.firstNode) {
        break;
      }

      parentMorphList.mountedMorph.firstNode = morph.firstNode;

      morph = parentMorphList.mountedMorph;
    }
  };

  Morph.prototype._syncLastNode = function Morph$syncLastNode() {
    var morph = this;
    var parentMorphList;
    while (parentMorphList = morph.parentMorphList) {
      if (parentMorphList.mountedMorph === null) {
        break;
      }
      if (morph !== parentMorphList.lastChildMorph) {
        break;
      }
      if (morph.lastNode === parentMorphList.mountedMorph.lastNode) {
        break;
      }

      parentMorphList.mountedMorph.lastNode = morph.lastNode;

      morph = parentMorphList.mountedMorph;
    }
  };

  Morph.prototype.insertBeforeNode = function Morph$insertBeforeNode(parentNode, refNode) {
    utils.insertBefore(parentNode, this.firstNode, this.lastNode, refNode);
  };

  Morph.prototype.appendToNode = function Morph$appendToNode(parentNode) {
    utils.insertBefore(parentNode, this.firstNode, this.lastNode, null);
  };

  exports.default = Morph;
  module.exports = exports.default;

  });

  unwrapExports(morphRange);

  var morph = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }



  var _morphRange2 = _interopRequireDefault(morphRange);

  var guid = 1;

  function HTMLBarsMorph(domHelper, contextualElement) {
    this.super$constructor(domHelper, contextualElement);

    this._state = undefined;
    this.ownerNode = null;
    this.isDirty = false;
    this.isSubtreeDirty = false;
    this.lastYielded = null;
    this.lastResult = null;
    this.lastValue = null;
    this.buildChildEnv = null;
    this.morphList = null;
    this.morphMap = null;
    this.key = null;
    this.linkedParams = null;
    this.linkedResult = null;
    this.childNodes = null;
    this.rendered = false;
    this.guid = "range" + guid++;
    this.seen = false;
  }

  HTMLBarsMorph.empty = function (domHelper, contextualElement) {
    var morph = new HTMLBarsMorph(domHelper, contextualElement);
    morph.clear();
    return morph;
  };

  HTMLBarsMorph.create = function (domHelper, contextualElement, node) {
    var morph = new HTMLBarsMorph(domHelper, contextualElement);
    morph.setNode(node);
    return morph;
  };

  HTMLBarsMorph.attach = function (domHelper, contextualElement, firstNode, lastNode) {
    var morph = new HTMLBarsMorph(domHelper, contextualElement);
    morph.setRange(firstNode, lastNode);
    return morph;
  };

  var prototype = HTMLBarsMorph.prototype = Object.create(_morphRange2.default.prototype);
  prototype.constructor = HTMLBarsMorph;
  prototype.super$constructor = _morphRange2.default;

  prototype.getState = function () {
    if (!this._state) {
      this._state = {};
    }

    return this._state;
  };

  prototype.setState = function (newState) {
    /*jshint -W093 */

    return this._state = newState;
  };

  exports.default = HTMLBarsMorph;
  module.exports = exports.default;

  });

  unwrapExports(morph);

  var sanitizeAttributeValue_1 = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.sanitizeAttributeValue = sanitizeAttributeValue;
  /* jshint scripturl:true */

  var badProtocols = {
    'javascript:': true,
    'vbscript:': true
  };

  var badTags = {
    'A': true,
    'BODY': true,
    'LINK': true,
    'IMG': true,
    'IFRAME': true,
    'BASE': true,
    'FORM': true
  };

  var badTagsForDataURI = {
    'EMBED': true
  };

  var badAttributes = {
    'href': true,
    'src': true,
    'background': true,
    'action': true
  };

  exports.badAttributes = badAttributes;
  var badAttributesForDataURI = {
    'src': true
  };

  function sanitizeAttributeValue(dom, element, attribute, value) {
    var tagName;

    if (!element) {
      tagName = null;
    } else {
      tagName = element.tagName.toUpperCase();
    }

    if (value && value.toHTML) {
      return value.toHTML();
    }

    if ((tagName === null || badTags[tagName]) && badAttributes[attribute]) {
      var protocol = dom.protocolForURL(value);
      if (badProtocols[protocol] === true) {
        return 'unsafe:' + value;
      }
    }

    if (badTagsForDataURI[tagName] && badAttributesForDataURI[attribute]) {
      return 'unsafe:' + value;
    }

    return value;
  }

  });

  unwrapExports(sanitizeAttributeValue_1);
  var sanitizeAttributeValue_2 = sanitizeAttributeValue_1.sanitizeAttributeValue;
  var sanitizeAttributeValue_3 = sanitizeAttributeValue_1.badAttributes;

  var prop = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.isAttrRemovalValue = isAttrRemovalValue;
  exports.normalizeProperty = normalizeProperty;

  function isAttrRemovalValue(value) {
    return value === null || value === undefined;
  }

  /*
   *
   * @method normalizeProperty
   * @param element {HTMLElement}
   * @param slotName {String}
   * @returns {Object} { name, type }
   */

  function normalizeProperty(element, slotName) {
    var type, normalized;

    if (slotName in element) {
      normalized = slotName;
      type = 'prop';
    } else {
      var lower = slotName.toLowerCase();
      if (lower in element) {
        type = 'prop';
        normalized = lower;
      } else {
        type = 'attr';
        normalized = slotName;
      }
    }

    if (type === 'prop' && (normalized.toLowerCase() === 'style' || preferAttr(element.tagName, normalized))) {
      type = 'attr';
    }

    return { normalized: normalized, type: type };
  }

  // properties that MUST be set as attributes, due to:
  // * browser bug
  // * strange spec outlier
  var ATTR_OVERRIDES = {

    // phantomjs < 2.0 lets you set it as a prop but won't reflect it
    // back to the attribute. button.getAttribute('type') === null
    BUTTON: { type: true, form: true },

    INPUT: {
      // TODO: remove when IE8 is droped
      // Some versions of IE (IE8) throw an exception when setting
      // `input.list = 'somestring'`:
      // https://github.com/emberjs/ember.js/issues/10908
      // https://github.com/emberjs/ember.js/issues/11364
      list: true,
      // Some version of IE (like IE9) actually throw an exception
      // if you set input.type = 'something-unknown'
      type: true,
      form: true,
      // Chrome 46.0.2464.0: 'autocorrect' in document.createElement('input') === false
      // Safari 8.0.7: 'autocorrect' in document.createElement('input') === false
      // Mobile Safari (iOS 8.4 simulator): 'autocorrect' in document.createElement('input') === true
      autocorrect: true
    },

    // element.form is actually a legitimate readOnly property, that is to be
    // mutated, but must be mutated by setAttribute...
    SELECT: { form: true },
    OPTION: { form: true },
    TEXTAREA: { form: true },
    LABEL: { form: true },
    FIELDSET: { form: true },
    LEGEND: { form: true },
    OBJECT: { form: true }
  };

  function preferAttr(tagName, propName) {
    var tag = ATTR_OVERRIDES[tagName.toUpperCase()];
    return tag && tag[propName.toLowerCase()] || false;
  }

  });

  unwrapExports(prop);
  var prop_1 = prop.isAttrRemovalValue;
  var prop_2 = prop.normalizeProperty;

  var buildHtmlDom = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  /* global XMLSerializer:false */
  var svgHTMLIntegrationPoints = { foreignObject: 1, desc: 1, title: 1 };
  exports.svgHTMLIntegrationPoints = svgHTMLIntegrationPoints;
  var svgNamespace = 'http://www.w3.org/2000/svg';

  exports.svgNamespace = svgNamespace;
  var doc = typeof document === 'undefined' ? false : document;

  // Safari does not like using innerHTML on SVG HTML integration
  // points (desc/title/foreignObject).
  var needsIntegrationPointFix = doc && (function (document) {
    if (document.createElementNS === undefined) {
      return;
    }
    // In FF title will not accept innerHTML.
    var testEl = document.createElementNS(svgNamespace, 'title');
    testEl.innerHTML = "<div></div>";
    return testEl.childNodes.length === 0 || testEl.childNodes[0].nodeType !== 1;
  })(doc);

  // Internet Explorer prior to 9 does not allow setting innerHTML if the first element
  // is a "zero-scope" element. This problem can be worked around by making
  // the first node an invisible text node. We, like Modernizr, use &shy;
  var needsShy = doc && (function (document) {
    var testEl = document.createElement('div');
    testEl.innerHTML = "<div></div>";
    testEl.firstChild.innerHTML = "<script><\/script>";
    return testEl.firstChild.innerHTML === '';
  })(doc);

  // IE 8 (and likely earlier) likes to move whitespace preceeding
  // a script tag to appear after it. This means that we can
  // accidentally remove whitespace when updating a morph.
  var movesWhitespace = doc && (function (document) {
    var testEl = document.createElement('div');
    testEl.innerHTML = "Test: <script type='text/x-placeholder'><\/script>Value";
    return testEl.childNodes[0].nodeValue === 'Test:' && testEl.childNodes[2].nodeValue === ' Value';
  })(doc);

  var tagNamesRequiringInnerHTMLFix = doc && (function (document) {
    var tagNamesRequiringInnerHTMLFix;
    // IE 9 and earlier don't allow us to set innerHTML on col, colgroup, frameset,
    // html, style, table, tbody, tfoot, thead, title, tr. Detect this and add
    // them to an initial list of corrected tags.
    //
    // Here we are only dealing with the ones which can have child nodes.
    //
    var tableNeedsInnerHTMLFix;
    var tableInnerHTMLTestElement = document.createElement('table');
    try {
      tableInnerHTMLTestElement.innerHTML = '<tbody></tbody>';
    } catch (e) {} finally {
      tableNeedsInnerHTMLFix = tableInnerHTMLTestElement.childNodes.length === 0;
    }
    if (tableNeedsInnerHTMLFix) {
      tagNamesRequiringInnerHTMLFix = {
        colgroup: ['table'],
        table: [],
        tbody: ['table'],
        tfoot: ['table'],
        thead: ['table'],
        tr: ['table', 'tbody']
      };
    }

    // IE 8 doesn't allow setting innerHTML on a select tag. Detect this and
    // add it to the list of corrected tags.
    //
    var selectInnerHTMLTestElement = document.createElement('select');
    selectInnerHTMLTestElement.innerHTML = '<option></option>';
    if (!selectInnerHTMLTestElement.childNodes[0]) {
      tagNamesRequiringInnerHTMLFix = tagNamesRequiringInnerHTMLFix || {};
      tagNamesRequiringInnerHTMLFix.select = [];
    }
    return tagNamesRequiringInnerHTMLFix;
  })(doc);

  function scriptSafeInnerHTML(element, html) {
    // without a leading text node, IE will drop a leading script tag.
    html = '&shy;' + html;

    element.innerHTML = html;

    var nodes = element.childNodes;

    // Look for &shy; to remove it.
    var shyElement = nodes[0];
    while (shyElement.nodeType === 1 && !shyElement.nodeName) {
      shyElement = shyElement.firstChild;
    }
    // At this point it's the actual unicode character.
    if (shyElement.nodeType === 3 && shyElement.nodeValue.charAt(0) === "\u00AD") {
      var newValue = shyElement.nodeValue.slice(1);
      if (newValue.length) {
        shyElement.nodeValue = shyElement.nodeValue.slice(1);
      } else {
        shyElement.parentNode.removeChild(shyElement);
      }
    }

    return nodes;
  }

  function buildDOMWithFix(html, contextualElement) {
    var tagName = contextualElement.tagName;

    // Firefox versions < 11 do not have support for element.outerHTML.
    var outerHTML = contextualElement.outerHTML || new XMLSerializer().serializeToString(contextualElement);
    if (!outerHTML) {
      throw "Can't set innerHTML on " + tagName + " in this browser";
    }

    html = fixSelect(html, contextualElement);

    var wrappingTags = tagNamesRequiringInnerHTMLFix[tagName.toLowerCase()];

    var startTag = outerHTML.match(new RegExp("<" + tagName + "([^>]*)>", 'i'))[0];
    var endTag = '</' + tagName + '>';

    var wrappedHTML = [startTag, html, endTag];

    var i = wrappingTags.length;
    var wrappedDepth = 1 + i;
    while (i--) {
      wrappedHTML.unshift('<' + wrappingTags[i] + '>');
      wrappedHTML.push('</' + wrappingTags[i] + '>');
    }

    var wrapper = document.createElement('div');
    scriptSafeInnerHTML(wrapper, wrappedHTML.join(''));
    var element = wrapper;
    while (wrappedDepth--) {
      element = element.firstChild;
      while (element && element.nodeType !== 1) {
        element = element.nextSibling;
      }
    }
    while (element && element.tagName !== tagName) {
      element = element.nextSibling;
    }
    return element ? element.childNodes : [];
  }

  var buildDOM;
  if (needsShy) {
    buildDOM = function buildDOM(html, contextualElement, dom) {
      html = fixSelect(html, contextualElement);

      contextualElement = dom.cloneNode(contextualElement, false);
      scriptSafeInnerHTML(contextualElement, html);
      return contextualElement.childNodes;
    };
  } else {
    buildDOM = function buildDOM(html, contextualElement, dom) {
      html = fixSelect(html, contextualElement);

      contextualElement = dom.cloneNode(contextualElement, false);
      contextualElement.innerHTML = html;
      return contextualElement.childNodes;
    };
  }

  function fixSelect(html, contextualElement) {
    if (contextualElement.tagName === 'SELECT') {
      html = "<option></option>" + html;
    }

    return html;
  }

  var buildIESafeDOM;
  if (tagNamesRequiringInnerHTMLFix || movesWhitespace) {
    buildIESafeDOM = function buildIESafeDOM(html, contextualElement, dom) {
      // Make a list of the leading text on script nodes. Include
      // script tags without any whitespace for easier processing later.
      var spacesBefore = [];
      var spacesAfter = [];
      if (typeof html === 'string') {
        html = html.replace(/(\s*)(<script)/g, function (match, spaces, tag) {
          spacesBefore.push(spaces);
          return tag;
        });

        html = html.replace(/(<\/script>)(\s*)/g, function (match, tag, spaces) {
          spacesAfter.push(spaces);
          return tag;
        });
      }

      // Fetch nodes
      var nodes;
      if (tagNamesRequiringInnerHTMLFix[contextualElement.tagName.toLowerCase()]) {
        // buildDOMWithFix uses string wrappers for problematic innerHTML.
        nodes = buildDOMWithFix(html, contextualElement);
      } else {
        nodes = buildDOM(html, contextualElement, dom);
      }

      // Build a list of script tags, the nodes themselves will be
      // mutated as we add test nodes.
      var i, j, node, nodeScriptNodes;
      var scriptNodes = [];
      for (i = 0; i < nodes.length; i++) {
        node = nodes[i];
        if (node.nodeType !== 1) {
          continue;
        }
        if (node.tagName === 'SCRIPT') {
          scriptNodes.push(node);
        } else {
          nodeScriptNodes = node.getElementsByTagName('script');
          for (j = 0; j < nodeScriptNodes.length; j++) {
            scriptNodes.push(nodeScriptNodes[j]);
          }
        }
      }

      // Walk the script tags and put back their leading text nodes.
      var scriptNode, textNode, spaceBefore, spaceAfter;
      for (i = 0; i < scriptNodes.length; i++) {
        scriptNode = scriptNodes[i];
        spaceBefore = spacesBefore[i];
        if (spaceBefore && spaceBefore.length > 0) {
          textNode = dom.document.createTextNode(spaceBefore);
          scriptNode.parentNode.insertBefore(textNode, scriptNode);
        }

        spaceAfter = spacesAfter[i];
        if (spaceAfter && spaceAfter.length > 0) {
          textNode = dom.document.createTextNode(spaceAfter);
          scriptNode.parentNode.insertBefore(textNode, scriptNode.nextSibling);
        }
      }

      return nodes;
    };
  } else {
    buildIESafeDOM = buildDOM;
  }

  var buildHTMLDOM;
  if (needsIntegrationPointFix) {
    exports.buildHTMLDOM = buildHTMLDOM = function buildHTMLDOM(html, contextualElement, dom) {
      if (svgHTMLIntegrationPoints[contextualElement.tagName]) {
        return buildIESafeDOM(html, document.createElement('div'), dom);
      } else {
        return buildIESafeDOM(html, contextualElement, dom);
      }
    };
  } else {
    exports.buildHTMLDOM = buildHTMLDOM = buildIESafeDOM;
  }

  exports.buildHTMLDOM = buildHTMLDOM;

  });

  unwrapExports(buildHtmlDom);
  var buildHtmlDom_1 = buildHtmlDom.svgHTMLIntegrationPoints;
  var buildHtmlDom_2 = buildHtmlDom.svgNamespace;
  var buildHtmlDom_3 = buildHtmlDom.buildHTMLDOM;

  var safeString = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  // Build out our basic SafeString type
  function SafeString(string) {
    this.string = string;
  }

  SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
    return '' + this.string;
  };

  exports.default = SafeString;
  module.exports = exports.default;

  });

  unwrapExports(safeString);

  var safeString$2 = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _handlebarsSafeString2 = _interopRequireDefault(safeString);

  exports.default = _handlebarsSafeString2.default;
  module.exports = exports.default;

  });

  unwrapExports(safeString$2);

  var utils$2 = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.extend = extend;
  exports.indexOf = indexOf;
  exports.escapeExpression = escapeExpression;
  exports.isEmpty = isEmpty;
  exports.blockParams = blockParams;
  exports.appendContextPath = appendContextPath;
  var escape = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };

  var badChars = /[&<>"'`]/g,
      possible = /[&<>"'`]/;

  function escapeChar(chr) {
    return escape[chr];
  }

  function extend(obj /* , ...source */) {
    for (var i = 1; i < arguments.length; i++) {
      for (var key in arguments[i]) {
        if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
          obj[key] = arguments[i][key];
        }
      }
    }

    return obj;
  }

  var toString = Object.prototype.toString;

  exports.toString = toString;
  // Sourced from lodash
  // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
  /*eslint-disable func-style, no-var */
  var isFunction = function (value) {
    return typeof value === 'function';
  };
  // fallback for older versions of Chrome and Safari
  /* istanbul ignore next */
  if (isFunction(/x/)) {
    exports.isFunction = isFunction = function (value) {
      return typeof value === 'function' && toString.call(value) === '[object Function]';
    };
  }
  var isFunction;
  exports.isFunction = isFunction;
  /*eslint-enable func-style, no-var */

  /* istanbul ignore next */
  var isArray = Array.isArray || function (value) {
    return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
  };

  exports.isArray = isArray;
  // Older IE versions do not directly support indexOf so we must implement our own, sadly.

  function indexOf(array, value) {
    for (var i = 0, len = array.length; i < len; i++) {
      if (array[i] === value) {
        return i;
      }
    }
    return -1;
  }

  function escapeExpression(string) {
    if (typeof string !== 'string') {
      // don't escape SafeStrings, since they're already safe
      if (string && string.toHTML) {
        return string.toHTML();
      } else if (string == null) {
        return '';
      } else if (!string) {
        return string + '';
      }

      // Force a string conversion as this will be done by the append regardless and
      // the regex test will do this transparently behind the scenes, causing issues if
      // an object's to string has escaped characters in it.
      string = '' + string;
    }

    if (!possible.test(string)) {
      return string;
    }
    return string.replace(badChars, escapeChar);
  }

  function isEmpty(value) {
    if (!value && value !== 0) {
      return true;
    } else if (isArray(value) && value.length === 0) {
      return true;
    } else {
      return false;
    }
  }

  function blockParams(params, ids) {
    params.path = ids;
    return params;
  }

  function appendContextPath(contextPath, id) {
    return (contextPath ? contextPath + '.' : '') + id;
  }

  });

  unwrapExports(utils$2);
  var utils_1$1 = utils$2.extend;
  var utils_2$1 = utils$2.indexOf;
  var utils_3 = utils$2.escapeExpression;
  var utils_4 = utils$2.isEmpty;
  var utils_5 = utils$2.blockParams;
  var utils_6 = utils$2.appendContextPath;
  var utils_7 = utils$2.isFunction;
  var utils_8 = utils$2.isArray;

  var namespaces = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.getAttrNamespace = getAttrNamespace;
  // ref http://dev.w3.org/html5/spec-LC/namespaces.html
  var defaultNamespaces = {
    html: 'http://www.w3.org/1999/xhtml',
    mathml: 'http://www.w3.org/1998/Math/MathML',
    svg: 'http://www.w3.org/2000/svg',
    xlink: 'http://www.w3.org/1999/xlink',
    xml: 'http://www.w3.org/XML/1998/namespace'
  };

  function getAttrNamespace(attrName, detectedNamespace) {
    if (detectedNamespace) {
      return detectedNamespace;
    }

    var namespace;

    var colonIndex = attrName.indexOf(':');
    if (colonIndex !== -1) {
      var prefix = attrName.slice(0, colonIndex);
      namespace = defaultNamespaces[prefix];
    }

    return namespace || null;
  }

  });

  unwrapExports(namespaces);
  var namespaces_1 = namespaces.getAttrNamespace;

  var morphUtils = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.visitChildren = visitChildren;
  exports.validateChildMorphs = validateChildMorphs;
  exports.linkParams = linkParams;
  exports.dump = dump;
  /*globals console*/

  function visitChildren(nodes, callback) {
    if (!nodes || nodes.length === 0) {
      return;
    }

    nodes = nodes.slice();

    while (nodes.length) {
      var node = nodes.pop();
      callback(node);

      if (node.childNodes) {
        nodes.push.apply(nodes, node.childNodes);
      } else if (node.firstChildMorph) {
        var current = node.firstChildMorph;

        while (current) {
          nodes.push(current);
          current = current.nextMorph;
        }
      } else if (node.morphList) {
        var current = node.morphList.firstChildMorph;

        while (current) {
          nodes.push(current);
          current = current.nextMorph;
        }
      }
    }
  }

  function validateChildMorphs(env, morph, visitor) {
    var morphList = morph.morphList;
    if (morph.morphList) {
      var current = morphList.firstChildMorph;

      while (current) {
        var next = current.nextMorph;
        validateChildMorphs(env, current, visitor);
        current = next;
      }
    } else if (morph.lastResult) {
      morph.lastResult.revalidateWith(env, undefined, undefined, undefined, visitor);
    } else if (morph.childNodes) {
      // This means that the childNodes were wired up manually
      for (var i = 0, l = morph.childNodes.length; i < l; i++) {
        validateChildMorphs(env, morph.childNodes[i], visitor);
      }
    }
  }

  function linkParams(env, scope, morph, path, params, hash) {
    if (morph.linkedParams) {
      return;
    }

    if (env.hooks.linkRenderNode(morph, env, scope, path, params, hash)) {
      morph.linkedParams = { params: params, hash: hash };
    }
  }

  function dump(node) {
    console.group(node, node.isDirty);

    if (node.childNodes) {
      map(node.childNodes, dump);
    } else if (node.firstChildMorph) {
      var current = node.firstChildMorph;

      while (current) {
        dump(current);
        current = current.nextMorph;
      }
    } else if (node.morphList) {
      dump(node.morphList);
    }

    console.groupEnd();
  }

  function map(nodes, cb) {
    for (var i = 0, l = nodes.length; i < l; i++) {
      cb(nodes[i]);
    }
  }

  });

  unwrapExports(morphUtils);
  var morphUtils_1 = morphUtils.visitChildren;
  var morphUtils_2 = morphUtils.validateChildMorphs;
  var morphUtils_3 = morphUtils.linkParams;
  var morphUtils_4 = morphUtils.dump;

  var htmlbarsUtil = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _htmlbarsUtilSafeString2 = _interopRequireDefault(safeString$2);







  exports.SafeString = _htmlbarsUtilSafeString2.default;
  exports.escapeExpression = utils$2.escapeExpression;
  exports.getAttrNamespace = namespaces.getAttrNamespace;
  exports.validateChildMorphs = morphUtils.validateChildMorphs;
  exports.linkParams = morphUtils.linkParams;
  exports.dump = morphUtils.dump;

  });

  unwrapExports(htmlbarsUtil);
  var htmlbarsUtil_1 = htmlbarsUtil.SafeString;
  var htmlbarsUtil_2 = htmlbarsUtil.escapeExpression;
  var htmlbarsUtil_3 = htmlbarsUtil.getAttrNamespace;
  var htmlbarsUtil_4 = htmlbarsUtil.validateChildMorphs;
  var htmlbarsUtil_5 = htmlbarsUtil.linkParams;
  var htmlbarsUtil_6 = htmlbarsUtil.dump;

  var morphAttr = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;









  function getProperty() {
    return this.domHelper.getPropertyStrict(this.element, this.attrName);
  }

  function updateProperty(value) {
    if (this._renderedInitially === true || !prop.isAttrRemovalValue(value)) {
      var element = this.element;
      var attrName = this.attrName;

      if (attrName === 'value' && element.tagName === 'INPUT' && element.value === value) ; else {
          // do not render if initial value is undefined or null
          this.domHelper.setPropertyStrict(element, attrName, value);
        }
    }

    this._renderedInitially = true;
  }

  function getAttribute() {
    return this.domHelper.getAttribute(this.element, this.attrName);
  }

  // normalize to be more inline with updateProperty behavior
  function normalizeAttributeValue(value) {
    if (value === false || value === undefined || value === null) {
      return null;
    }
    if (value === true) {
      return '';
    }
    // onclick function etc in SSR
    if (typeof value === 'function') {
      return null;
    }
    return String(value);
  }

  function updateAttribute(_value) {
    var value = normalizeAttributeValue(_value);
    if (prop.isAttrRemovalValue(value)) {
      this.domHelper.removeAttribute(this.element, this.attrName);
    } else {
      this.domHelper.setAttribute(this.element, this.attrName, value);
    }
  }

  function getAttributeNS() {
    return this.domHelper.getAttributeNS(this.element, this.namespace, this.attrName);
  }

  function updateAttributeNS(_value) {
    var value = normalizeAttributeValue(_value);
    if (prop.isAttrRemovalValue(value)) {
      this.domHelper.removeAttribute(this.element, this.attrName);
    } else {
      this.domHelper.setAttributeNS(this.element, this.namespace, this.attrName, value);
    }
  }

  var UNSET = { unset: true };

  var guid = 1;

  AttrMorph.create = function (element, attrName, domHelper, namespace) {
    var ns = htmlbarsUtil.getAttrNamespace(attrName, namespace);

    if (ns) {
      return new AttributeNSAttrMorph(element, attrName, domHelper, ns);
    } else {
      return createNonNamespacedAttrMorph(element, attrName, domHelper);
    }
  };

  function createNonNamespacedAttrMorph(element, attrName, domHelper) {
    var _normalizeProperty = prop.normalizeProperty(element, attrName);

    var normalized = _normalizeProperty.normalized;
    var type = _normalizeProperty.type;

    if (element.namespaceURI === buildHtmlDom.svgNamespace || attrName === 'style' || type === 'attr') {
      return new AttributeAttrMorph(element, normalized, domHelper);
    } else {
      return new PropertyAttrMorph(element, normalized, domHelper);
    }
  }

  function AttrMorph(element, attrName, domHelper) {
    this.element = element;
    this.domHelper = domHelper;
    this.attrName = attrName;
    this._state = undefined;
    this.isDirty = false;
    this.isSubtreeDirty = false;
    this.escaped = true;
    this.lastValue = UNSET;
    this.lastResult = null;
    this.lastYielded = null;
    this.childNodes = null;
    this.linkedParams = null;
    this.linkedResult = null;
    this.guid = "attr" + guid++;
    this.seen = false;
    this.ownerNode = null;
    this.rendered = false;
    this._renderedInitially = false;
    this.namespace = undefined;
    this.didInit();
  }

  AttrMorph.prototype.getState = function () {
    if (!this._state) {
      this._state = {};
    }

    return this._state;
  };

  AttrMorph.prototype.setState = function (newState) {
    /*jshint -W093 */

    return this._state = newState;
  };

  AttrMorph.prototype.didInit = function () {};
  AttrMorph.prototype.willSetContent = function () {};

  AttrMorph.prototype.setContent = function (value) {
    this.willSetContent(value);

    if (this.lastValue === value) {
      return;
    }
    this.lastValue = value;

    if (this.escaped) {
      var sanitized = sanitizeAttributeValue_1.sanitizeAttributeValue(this.domHelper, this.element, this.attrName, value);
      this._update(sanitized, this.namespace);
    } else {
      this._update(value, this.namespace);
    }
  };

  AttrMorph.prototype.getContent = function () {
    var value = this.lastValue = this._get();
    return value;
  };

  // renderAndCleanup calls `clear` on all items in the morph map
  // just before calling `destroy` on the morph.
  //
  // As a future refactor this could be changed to set the property
  // back to its original/default value.
  AttrMorph.prototype.clear = function () {};

  AttrMorph.prototype.destroy = function () {
    this.element = null;
    this.domHelper = null;
  };

  AttrMorph.prototype._$superAttrMorph = AttrMorph;

  function PropertyAttrMorph(element, attrName, domHelper) {
    this._$superAttrMorph(element, attrName, domHelper);
  }

  PropertyAttrMorph.prototype = Object.create(AttrMorph.prototype);
  PropertyAttrMorph.prototype._update = updateProperty;
  PropertyAttrMorph.prototype._get = getProperty;

  function AttributeNSAttrMorph(element, attrName, domHelper, namespace) {
    this._$superAttrMorph(element, attrName, domHelper);
    this.namespace = namespace;
  }

  AttributeNSAttrMorph.prototype = Object.create(AttrMorph.prototype);
  AttributeNSAttrMorph.prototype._update = updateAttributeNS;
  AttributeNSAttrMorph.prototype._get = getAttributeNS;

  function AttributeAttrMorph(element, attrName, domHelper) {
    this._$superAttrMorph(element, attrName, domHelper);
  }

  AttributeAttrMorph.prototype = Object.create(AttrMorph.prototype);
  AttributeAttrMorph.prototype._update = updateAttribute;
  AttributeAttrMorph.prototype._get = getAttribute;

  exports.default = AttrMorph;
  exports.sanitizeAttributeValue = sanitizeAttributeValue_1.sanitizeAttributeValue;

  });

  unwrapExports(morphAttr);
  var morphAttr_1 = morphAttr.sanitizeAttributeValue;

  var classes = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  var doc = typeof document === 'undefined' ? false : document;

  // PhantomJS has a broken classList. See https://github.com/ariya/phantomjs/issues/12782
  var canClassList = doc && (function () {
    var d = document.createElement('div');
    if (!d.classList) {
      return false;
    }
    d.classList.add('boo');
    d.classList.add('boo', 'baz');
    return d.className === 'boo baz';
  })();

  function buildClassList(element) {
    var classString = element.getAttribute('class') || '';
    return classString !== '' && classString !== ' ' ? classString.split(' ') : [];
  }

  function intersect(containingArray, valuesArray) {
    var containingIndex = 0;
    var containingLength = containingArray.length;
    var valuesIndex = 0;
    var valuesLength = valuesArray.length;

    var intersection = new Array(valuesLength);

    // TODO: rewrite this loop in an optimal manner
    for (; containingIndex < containingLength; containingIndex++) {
      valuesIndex = 0;
      for (; valuesIndex < valuesLength; valuesIndex++) {
        if (valuesArray[valuesIndex] === containingArray[containingIndex]) {
          intersection[valuesIndex] = containingIndex;
          break;
        }
      }
    }

    return intersection;
  }

  function addClassesViaAttribute(element, classNames) {
    var existingClasses = buildClassList(element);

    var indexes = intersect(existingClasses, classNames);
    var didChange = false;

    for (var i = 0, l = classNames.length; i < l; i++) {
      if (indexes[i] === undefined) {
        didChange = true;
        existingClasses.push(classNames[i]);
      }
    }

    if (didChange) {
      element.setAttribute('class', existingClasses.length > 0 ? existingClasses.join(' ') : '');
    }
  }

  function removeClassesViaAttribute(element, classNames) {
    var existingClasses = buildClassList(element);

    var indexes = intersect(classNames, existingClasses);
    var didChange = false;
    var newClasses = [];

    for (var i = 0, l = existingClasses.length; i < l; i++) {
      if (indexes[i] === undefined) {
        newClasses.push(existingClasses[i]);
      } else {
        didChange = true;
      }
    }

    if (didChange) {
      element.setAttribute('class', newClasses.length > 0 ? newClasses.join(' ') : '');
    }
  }

  var addClasses, removeClasses;
  if (canClassList) {
    exports.addClasses = addClasses = function addClasses(element, classNames) {
      if (element.classList) {
        if (classNames.length === 1) {
          element.classList.add(classNames[0]);
        } else if (classNames.length === 2) {
          element.classList.add(classNames[0], classNames[1]);
        } else {
          element.classList.add.apply(element.classList, classNames);
        }
      } else {
        addClassesViaAttribute(element, classNames);
      }
    };
    exports.removeClasses = removeClasses = function removeClasses(element, classNames) {
      if (element.classList) {
        if (classNames.length === 1) {
          element.classList.remove(classNames[0]);
        } else if (classNames.length === 2) {
          element.classList.remove(classNames[0], classNames[1]);
        } else {
          element.classList.remove.apply(element.classList, classNames);
        }
      } else {
        removeClassesViaAttribute(element, classNames);
      }
    };
  } else {
    exports.addClasses = addClasses = addClassesViaAttribute;
    exports.removeClasses = removeClasses = removeClassesViaAttribute;
  }

  exports.addClasses = addClasses;
  exports.removeClasses = removeClasses;

  });

  unwrapExports(classes);
  var classes_1 = classes.addClasses;
  var classes_2 = classes.removeClasses;

  var domHelper = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  /*globals module, URL*/



  var _htmlbarsRuntimeMorph2 = _interopRequireDefault(morph);



  var _morphAttr2 = _interopRequireDefault(morphAttr);







  var doc = typeof document === 'undefined' ? false : document;

  var deletesBlankTextNodes = doc && (function (document) {
    var element = document.createElement('div');
    element.appendChild(document.createTextNode(''));
    var clonedElement = element.cloneNode(true);
    return clonedElement.childNodes.length === 0;
  })(doc);

  var ignoresCheckedAttribute = doc && (function (document) {
    var element = document.createElement('input');
    element.setAttribute('checked', 'checked');
    var clonedElement = element.cloneNode(false);
    return !clonedElement.checked;
  })(doc);

  var canRemoveSvgViewBoxAttribute = doc && (doc.createElementNS ? (function (document) {
    var element = document.createElementNS(buildHtmlDom.svgNamespace, 'svg');
    element.setAttribute('viewBox', '0 0 100 100');
    element.removeAttribute('viewBox');
    return !element.getAttribute('viewBox');
  })(doc) : true);

  var canClone = doc && (function (document) {
    var element = document.createElement('div');
    element.appendChild(document.createTextNode(' '));
    element.appendChild(document.createTextNode(' '));
    var clonedElement = element.cloneNode(true);
    return clonedElement.childNodes[0].nodeValue === ' ';
  })(doc);

  // This is not the namespace of the element, but of
  // the elements inside that elements.
  function interiorNamespace(element) {
    if (element && element.namespaceURI === buildHtmlDom.svgNamespace && !buildHtmlDom.svgHTMLIntegrationPoints[element.tagName]) {
      return buildHtmlDom.svgNamespace;
    } else {
      return null;
    }
  }

  // The HTML spec allows for "omitted start tags". These tags are optional
  // when their intended child is the first thing in the parent tag. For
  // example, this is a tbody start tag:
  //
  // <table>
  //   <tbody>
  //     <tr>
  //
  // The tbody may be omitted, and the browser will accept and render:
  //
  // <table>
  //   <tr>
  //
  // However, the omitted start tag will still be added to the DOM. Here
  // we test the string and context to see if the browser is about to
  // perform this cleanup.
  //
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html#optional-tags
  // describes which tags are omittable. The spec for tbody and colgroup
  // explains this behavior:
  //
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/tables.html#the-tbody-element
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/tables.html#the-colgroup-element
  //

  var omittedStartTagChildTest = /<([\w:]+)/;
  function detectOmittedStartTag(string, contextualElement) {
    // Omitted start tags are only inside table tags.
    if (contextualElement.tagName === 'TABLE') {
      var omittedStartTagChildMatch = omittedStartTagChildTest.exec(string);
      if (omittedStartTagChildMatch) {
        var omittedStartTagChild = omittedStartTagChildMatch[1];
        // It is already asserted that the contextual element is a table
        // and not the proper start tag. Just see if a tag was omitted.
        return omittedStartTagChild === 'tr' || omittedStartTagChild === 'col';
      }
    }
  }

  function buildSVGDOM(html, dom) {
    var div = dom.document.createElement('div');
    div.innerHTML = '<svg>' + html + '</svg>';
    return div.firstChild.childNodes;
  }

  var guid = 1;

  function ElementMorph(element, dom, namespace) {
    this.element = element;
    this.dom = dom;
    this.namespace = namespace;
    this.guid = "element" + guid++;

    this._state = undefined;
    this.isDirty = true;
  }

  ElementMorph.prototype.getState = function () {
    if (!this._state) {
      this._state = {};
    }

    return this._state;
  };

  ElementMorph.prototype.setState = function (newState) {
    /*jshint -W093 */

    return this._state = newState;
  };

  // renderAndCleanup calls `clear` on all items in the morph map
  // just before calling `destroy` on the morph.
  //
  // As a future refactor this could be changed to set the property
  // back to its original/default value.
  ElementMorph.prototype.clear = function () {};

  ElementMorph.prototype.destroy = function () {
    this.element = null;
    this.dom = null;
  };

  /*
   * A class wrapping DOM functions to address environment compatibility,
   * namespaces, contextual elements for morph un-escaped content
   * insertion.
   *
   * When entering a template, a DOMHelper should be passed:
   *
   *   template(context, { hooks: hooks, dom: new DOMHelper() });
   *
   * TODO: support foreignObject as a passed contextual element. It has
   * a namespace (svg) that does not match its internal namespace
   * (xhtml).
   *
   * @class DOMHelper
   * @constructor
   * @param {HTMLDocument} _document The document DOM methods are proxied to
   */
  function DOMHelper(_document) {
    this.document = _document || document;
    if (!this.document) {
      throw new Error("A document object must be passed to the DOMHelper, or available on the global scope");
    }
    this.canClone = canClone;
    this.namespace = null;

    installEnvironmentSpecificMethods(this);
  }

  var prototype = DOMHelper.prototype;
  prototype.constructor = DOMHelper;

  prototype.getElementById = function (id, rootNode) {
    rootNode = rootNode || this.document;
    return rootNode.getElementById(id);
  };

  prototype.insertBefore = function (element, childElement, referenceChild) {
    return element.insertBefore(childElement, referenceChild);
  };

  prototype.appendChild = function (element, childElement) {
    return element.appendChild(childElement);
  };

  var itemAt;

  // It appears that sometimes, in yet to be itentified scenarios PhantomJS 2.0
  // crashes on childNodes.item(index), but works as expected with childNodes[index];
  //
  // Although it would be nice to move to childNodes[index] in all scenarios,
  // this would require SimpleDOM to maintain the childNodes array. This would be
  // quite costly, in both dev time and runtime.
  //
  // So instead, we choose the best possible method and call it a day.
  //
  /*global navigator */
  if (typeof navigator !== 'undefined' && navigator.userAgent.indexOf('PhantomJS')) {
    itemAt = function (nodes, index) {
      return nodes[index];
    };
  } else {
    itemAt = function (nodes, index) {
      return nodes.item(index);
    };
  }

  prototype.childAt = function (element, indices) {
    var child = element;

    for (var i = 0; i < indices.length; i++) {
      child = itemAt(child.childNodes, indices[i]);
    }

    return child;
  };

  // Note to a Fellow Implementor:
  // Ahh, accessing a child node at an index. Seems like it should be so simple,
  // doesn't it? Unfortunately, this particular method has caused us a surprising
  // amount of pain. As you'll note below, this method has been modified to walk
  // the linked list of child nodes rather than access the child by index
  // directly, even though there are two (2) APIs in the DOM that do this for us.
  // If you're thinking to yourself, "What an oversight! What an opportunity to
  // optimize this code!" then to you I say: stop! For I have a tale to tell.
  //
  // First, this code must be compatible with simple-dom for rendering on the
  // server where there is no real DOM. Previously, we accessed a child node
  // directly via `element.childNodes[index]`. While we *could* in theory do a
  // full-fidelity simulation of a live `childNodes` array, this is slow,
  // complicated and error-prone.
  //
  // "No problem," we thought, "we'll just use the similar
  // `childNodes.item(index)` API." Then, we could just implement our own `item`
  // method in simple-dom and walk the child node linked list there, allowing
  // us to retain the performance advantages of the (surely optimized) `item()`
  // API in the browser.
  //
  // Unfortunately, an enterprising soul named Samy Alzahrani discovered that in
  // IE8, accessing an item out-of-bounds via `item()` causes an exception where
  // other browsers return null. This necessitated a... check of
  // `childNodes.length`, bringing us back around to having to support a
  // full-fidelity `childNodes` array!
  //
  // Worst of all, Kris Selden investigated how browsers are actualy implemented
  // and discovered that they're all linked lists under the hood anyway. Accessing
  // `childNodes` requires them to allocate a new live collection backed by that
  // linked list, which is itself a rather expensive operation. Our assumed
  // optimization had backfired! That is the danger of magical thinking about
  // the performance of native implementations.
  //
  // And this, my friends, is why the following implementation just walks the
  // linked list, as surprised as that may make you. Please ensure you understand
  // the above before changing this and submitting a PR.
  //
  // Tom Dale, January 18th, 2015, Portland OR
  prototype.childAtIndex = function (element, index) {
    var node = element.firstChild;

    for (var idx = 0; node && idx < index; idx++) {
      node = node.nextSibling;
    }

    return node;
  };

  prototype.appendText = function (element, text) {
    return element.appendChild(this.document.createTextNode(text));
  };

  prototype.setAttribute = function (element, name, value) {
    element.setAttribute(name, String(value));
  };

  prototype.getAttribute = function (element, name) {
    return element.getAttribute(name);
  };

  prototype.setAttributeNS = function (element, namespace, name, value) {
    element.setAttributeNS(namespace, name, String(value));
  };

  prototype.getAttributeNS = function (element, namespace, name) {
    return element.getAttributeNS(namespace, name);
  };

  if (canRemoveSvgViewBoxAttribute) {
    prototype.removeAttribute = function (element, name) {
      element.removeAttribute(name);
    };
  } else {
    prototype.removeAttribute = function (element, name) {
      if (element.tagName === 'svg' && name === 'viewBox') {
        element.setAttribute(name, null);
      } else {
        element.removeAttribute(name);
      }
    };
  }

  prototype.setPropertyStrict = function (element, name, value) {
    if (value === undefined) {
      value = null;
    }

    if (value === null && (name === 'value' || name === 'type' || name === 'src')) {
      value = '';
    }

    element[name] = value;
  };

  prototype.getPropertyStrict = function (element, name) {
    return element[name];
  };

  prototype.setProperty = function (element, name, value, namespace) {
    if (element.namespaceURI === buildHtmlDom.svgNamespace) {
      if (prop.isAttrRemovalValue(value)) {
        element.removeAttribute(name);
      } else {
        if (namespace) {
          element.setAttributeNS(namespace, name, value);
        } else {
          element.setAttribute(name, value);
        }
      }
    } else {
      var _normalizeProperty = prop.normalizeProperty(element, name);

      var normalized = _normalizeProperty.normalized;
      var type = _normalizeProperty.type;

      if (type === 'prop') {
        element[normalized] = value;
      } else {
        if (prop.isAttrRemovalValue(value)) {
          element.removeAttribute(name);
        } else {
          if (namespace && element.setAttributeNS) {
            element.setAttributeNS(namespace, name, value);
          } else {
            element.setAttribute(name, value);
          }
        }
      }
    }
  };

  if (doc && doc.createElementNS) {
    // Only opt into namespace detection if a contextualElement
    // is passed.
    prototype.createElement = function (tagName, contextualElement) {
      var namespace = this.namespace;
      if (contextualElement) {
        if (tagName === 'svg') {
          namespace = buildHtmlDom.svgNamespace;
        } else {
          namespace = interiorNamespace(contextualElement);
        }
      }
      if (namespace) {
        return this.document.createElementNS(namespace, tagName);
      } else {
        return this.document.createElement(tagName);
      }
    };
    prototype.setAttributeNS = function (element, namespace, name, value) {
      element.setAttributeNS(namespace, name, String(value));
    };
  } else {
    prototype.createElement = function (tagName) {
      return this.document.createElement(tagName);
    };
    prototype.setAttributeNS = function (element, namespace, name, value) {
      element.setAttribute(name, String(value));
    };
  }

  prototype.addClasses = classes.addClasses;
  prototype.removeClasses = classes.removeClasses;

  prototype.setNamespace = function (ns) {
    this.namespace = ns;
  };

  prototype.detectNamespace = function (element) {
    this.namespace = interiorNamespace(element);
  };

  prototype.createDocumentFragment = function () {
    return this.document.createDocumentFragment();
  };

  prototype.createTextNode = function (text) {
    return this.document.createTextNode(text);
  };

  prototype.createComment = function (text) {
    return this.document.createComment(text);
  };

  prototype.repairClonedNode = function (element, blankChildTextNodes, isChecked) {
    if (deletesBlankTextNodes && blankChildTextNodes.length > 0) {
      for (var i = 0, len = blankChildTextNodes.length; i < len; i++) {
        var textNode = this.document.createTextNode(''),
            offset = blankChildTextNodes[i],
            before = this.childAtIndex(element, offset);
        if (before) {
          element.insertBefore(textNode, before);
        } else {
          element.appendChild(textNode);
        }
      }
    }
    if (ignoresCheckedAttribute && isChecked) {
      element.setAttribute('checked', 'checked');
    }
  };

  prototype.cloneNode = function (element, deep) {
    var clone = element.cloneNode(!!deep);
    return clone;
  };

  prototype.AttrMorphClass = _morphAttr2.default;

  prototype.createAttrMorph = function (element, attrName, namespace) {
    return this.AttrMorphClass.create(element, attrName, this, namespace);
  };

  prototype.ElementMorphClass = ElementMorph;

  prototype.createElementMorph = function (element, namespace) {
    return new this.ElementMorphClass(element, this, namespace);
  };

  prototype.createUnsafeAttrMorph = function (element, attrName, namespace) {
    var morph$$1 = this.createAttrMorph(element, attrName, namespace);
    morph$$1.escaped = false;
    return morph$$1;
  };

  prototype.MorphClass = _htmlbarsRuntimeMorph2.default;

  prototype.createMorph = function (parent, start, end, contextualElement) {
    if (contextualElement && contextualElement.nodeType === 11) {
      throw new Error("Cannot pass a fragment as the contextual element to createMorph");
    }

    if (!contextualElement && parent && parent.nodeType === 1) {
      contextualElement = parent;
    }
    var morph$$1 = new this.MorphClass(this, contextualElement);
    morph$$1.firstNode = start;
    morph$$1.lastNode = end;
    return morph$$1;
  };

  prototype.createFragmentMorph = function (contextualElement) {
    if (contextualElement && contextualElement.nodeType === 11) {
      throw new Error("Cannot pass a fragment as the contextual element to createMorph");
    }

    var fragment = this.createDocumentFragment();
    return _htmlbarsRuntimeMorph2.default.create(this, contextualElement, fragment);
  };

  prototype.replaceContentWithMorph = function (element) {
    var firstChild = element.firstChild;

    if (!firstChild) {
      var comment = this.createComment('');
      this.appendChild(element, comment);
      return _htmlbarsRuntimeMorph2.default.create(this, element, comment);
    } else {
      var morph$$1 = _htmlbarsRuntimeMorph2.default.attach(this, element, firstChild, element.lastChild);
      morph$$1.clear();
      return morph$$1;
    }
  };

  prototype.createUnsafeMorph = function (parent, start, end, contextualElement) {
    var morph$$1 = this.createMorph(parent, start, end, contextualElement);
    morph$$1.parseTextAsHTML = true;
    return morph$$1;
  };

  // This helper is just to keep the templates good looking,
  // passing integers instead of element references.
  prototype.createMorphAt = function (parent, startIndex, endIndex, contextualElement) {
    var single = startIndex === endIndex;
    var start = this.childAtIndex(parent, startIndex);
    var end = single ? start : this.childAtIndex(parent, endIndex);
    return this.createMorph(parent, start, end, contextualElement);
  };

  prototype.createUnsafeMorphAt = function (parent, startIndex, endIndex, contextualElement) {
    var morph$$1 = this.createMorphAt(parent, startIndex, endIndex, contextualElement);
    morph$$1.parseTextAsHTML = true;
    return morph$$1;
  };

  prototype.insertMorphBefore = function (element, referenceChild, contextualElement) {
    var insertion = this.document.createComment('');
    element.insertBefore(insertion, referenceChild);
    return this.createMorph(element, insertion, insertion, contextualElement);
  };

  prototype.appendMorph = function (element, contextualElement) {
    var insertion = this.document.createComment('');
    element.appendChild(insertion);
    return this.createMorph(element, insertion, insertion, contextualElement);
  };

  prototype.insertBoundary = function (fragment, index) {
    // this will always be null or firstChild
    var child = index === null ? null : this.childAtIndex(fragment, index);
    this.insertBefore(fragment, this.createTextNode(''), child);
  };

  prototype.setMorphHTML = function (morph$$1, html) {
    morph$$1.setHTML(html);
  };

  prototype.parseHTML = function (html, contextualElement) {
    var childNodes;

    if (interiorNamespace(contextualElement) === buildHtmlDom.svgNamespace) {
      childNodes = buildSVGDOM(html, this);
    } else {
      var nodes = buildHtmlDom.buildHTMLDOM(html, contextualElement, this);
      if (detectOmittedStartTag(html, contextualElement)) {
        var node = nodes[0];
        while (node && node.nodeType !== 1) {
          node = node.nextSibling;
        }
        childNodes = node.childNodes;
      } else {
        childNodes = nodes;
      }
    }

    // Copy node list to a fragment.
    var fragment = this.document.createDocumentFragment();

    if (childNodes && childNodes.length > 0) {
      var currentNode = childNodes[0];

      // We prepend an <option> to <select> boxes to absorb any browser bugs
      // related to auto-select behavior. Skip past it.
      if (contextualElement.tagName === 'SELECT') {
        currentNode = currentNode.nextSibling;
      }

      while (currentNode) {
        var tempNode = currentNode;
        currentNode = currentNode.nextSibling;

        fragment.appendChild(tempNode);
      }
    }

    return fragment;
  };

  var nodeURL;
  var parsingNode;

  function installEnvironmentSpecificMethods(domHelper) {
    var protocol = browserProtocolForURL.call(domHelper, 'foobar:baz');

    // Test to see if our DOM implementation parses
    // and normalizes URLs.
    if (protocol === 'foobar:') {
      // Swap in the method that doesn't do this test now that
      // we know it works.
      domHelper.protocolForURL = browserProtocolForURL;
    } else if (typeof URL === 'object') {
      // URL globally provided, likely from FastBoot's sandbox
      nodeURL = URL;
      domHelper.protocolForURL = nodeProtocolForURL;
    } else if (typeof module.require === 'function') {
      // Otherwise, we need to fall back to our own URL parsing.
      // Global `require` is shadowed by Ember's loader so we have to use the fully
      // qualified `module.require`.
      nodeURL = module.require('url');
      domHelper.protocolForURL = nodeProtocolForURL;
    } else {
      throw new Error("DOM Helper could not find valid URL parsing mechanism");
    }

    // A SimpleDOM-specific extension that allows us to place HTML directly
    // into the DOM tree, for when the output target is always serialized HTML.
    if (domHelper.document.createRawHTMLSection) {
      domHelper.setMorphHTML = nodeSetMorphHTML;
    }
  }

  function nodeSetMorphHTML(morph$$1, html) {
    var section = this.document.createRawHTMLSection(html);
    morph$$1.setNode(section);
  }

  function browserProtocolForURL(url) {
    if (!parsingNode) {
      parsingNode = this.document.createElement('a');
    }

    parsingNode.href = url;
    return parsingNode.protocol;
  }

  function nodeProtocolForURL(url) {
    var protocol = null;
    if (typeof url === 'string') {
      protocol = nodeURL.parse(url).protocol;
    }
    return protocol === null ? ':' : protocol;
  }

  exports.default = DOMHelper;
  module.exports = exports.default;

  });

  var DOMHelper = unwrapExports(domHelper);

  var expressionVisitor = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.acceptParams = acceptParams;
  exports.acceptHash = acceptHash;
  /**
    # Expression Nodes:

    These nodes are not directly responsible for any part of the DOM, but are
    eventually passed to a Statement Node.

    * get
    * subexpr
    * concat
  */

  function acceptParams(nodes, env, scope) {
    var array = [];

    for (var i = 0, l = nodes.length; i < l; i++) {
      array.push(acceptExpression(nodes[i], env, scope).value);
    }

    return array;
  }

  function acceptHash(pairs, env, scope) {
    var object = {};

    for (var i = 0, l = pairs.length; i < l; i += 2) {
      var key = pairs[i];
      var value = pairs[i + 1];
      object[key] = acceptExpression(value, env, scope).value;
    }

    return object;
  }

  function acceptExpression(node, env, scope) {
    var ret = { value: null };

    // Primitive literals are unambiguously non-array representations of
    // themselves.
    if (Array.isArray(node)) {
      // if (node.length !== 7) { throw new Error('FIXME: Invalid statement length!'); }

      ret.value = evaluateNode(node, env, scope);
    } else {
      ret.value = node;
    }

    return ret;
  }

  function evaluateNode(node, env, scope) {
    switch (node[0]) {
      // can be used by manualElement
      case 'value':
        return node[1];
      case 'get':
        return evaluateGet(node, env, scope);
      case 'subexpr':
        return evaluateSubexpr(node, env, scope);
      case 'concat':
        return evaluateConcat(node, env, scope);
    }
  }

  function evaluateGet(node, env, scope) {
    var path = node[1];

    return env.hooks.get(env, scope, path);
  }

  function evaluateSubexpr(node, env, scope) {
    var path = node[1];
    var rawParams = node[2];
    var rawHash = node[3];

    var params = acceptParams(rawParams, env, scope);
    var hash = acceptHash(rawHash, env, scope);

    return env.hooks.subexpr(env, scope, path, params, hash);
  }

  function evaluateConcat(node, env, scope) {
    var rawParts = node[1];

    var parts = acceptParams(rawParts, env, scope);

    return env.hooks.concat(env, parts);
  }

  });

  unwrapExports(expressionVisitor);
  var expressionVisitor_1 = expressionVisitor.acceptParams;
  var expressionVisitor_2 = expressionVisitor.acceptHash;

  var nodeVisitor = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;





  /**
    Node classification:

    # Primary Statement Nodes:

    These nodes are responsible for a render node that represents a morph-range.

    * block
    * inline
    * content
    * element
    * component

    # Leaf Statement Nodes:

    This node is responsible for a render node that represents a morph-attr.

    * attribute
  */

  function linkParamsAndHash(env, scope, morph, path, params, hash) {
    if (morph.linkedParams) {
      params = morph.linkedParams.params;
      hash = morph.linkedParams.hash;
    } else {
      params = params && expressionVisitor.acceptParams(params, env, scope);
      hash = hash && expressionVisitor.acceptHash(hash, env, scope);
    }

    morphUtils.linkParams(env, scope, morph, path, params, hash);
    return [params, hash];
  }

  var AlwaysDirtyVisitor = {

    block: function (node, morph, env, scope, template, visitor) {
      var path = node[1];
      var params = node[2];
      var hash = node[3];
      var templateId = node[4];
      var inverseId = node[5];

      var paramsAndHash = linkParamsAndHash(env, scope, morph, path, params, hash);

      morph.isDirty = morph.isSubtreeDirty = false;
      env.hooks.block(morph, env, scope, path, paramsAndHash[0], paramsAndHash[1], templateId === null ? null : template.templates[templateId], inverseId === null ? null : template.templates[inverseId], visitor);
    },

    inline: function (node, morph, env, scope, visitor) {
      var path = node[1];
      var params = node[2];
      var hash = node[3];

      var paramsAndHash = linkParamsAndHash(env, scope, morph, path, params, hash);

      morph.isDirty = morph.isSubtreeDirty = false;
      env.hooks.inline(morph, env, scope, path, paramsAndHash[0], paramsAndHash[1], visitor);
    },

    content: function (node, morph, env, scope, visitor) {
      var path = node[1];

      morph.isDirty = morph.isSubtreeDirty = false;

      if (isHelper(env, scope, path)) {
        env.hooks.inline(morph, env, scope, path, [], {}, visitor);
        if (morph.linkedResult) {
          morphUtils.linkParams(env, scope, morph, '@content-helper', [morph.linkedResult], null);
        }
        return;
      }

      var params = undefined;
      if (morph.linkedParams) {
        params = morph.linkedParams.params;
      } else {
        params = [env.hooks.get(env, scope, path)];
      }

      morphUtils.linkParams(env, scope, morph, '@range', params, null);
      env.hooks.range(morph, env, scope, path, params[0], visitor);
    },

    element: function (node, morph, env, scope, visitor) {
      var path = node[1];
      var params = node[2];
      var hash = node[3];

      var paramsAndHash = linkParamsAndHash(env, scope, morph, path, params, hash);

      morph.isDirty = morph.isSubtreeDirty = false;
      env.hooks.element(morph, env, scope, path, paramsAndHash[0], paramsAndHash[1], visitor);
    },

    attribute: function (node, morph, env, scope) {
      var name = node[1];
      var value = node[2];

      var paramsAndHash = linkParamsAndHash(env, scope, morph, '@attribute', [value], null);

      morph.isDirty = morph.isSubtreeDirty = false;
      env.hooks.attribute(morph, env, scope, name, paramsAndHash[0][0]);
    },

    component: function (node, morph, env, scope, template, visitor) {
      var path = node[1];
      var attrs = node[2];
      var templateId = node[3];
      var inverseId = node[4];

      var paramsAndHash = linkParamsAndHash(env, scope, morph, path, [], attrs);
      var templates = {
        default: template.templates[templateId],
        inverse: template.templates[inverseId]
      };

      morph.isDirty = morph.isSubtreeDirty = false;
      env.hooks.component(morph, env, scope, path, paramsAndHash[0], paramsAndHash[1], templates, visitor);
    },

    attributes: function (node, morph, env, scope, parentMorph, visitor) {
      var template = node[1];

      env.hooks.attributes(morph, env, scope, template, parentMorph, visitor);
    }

  };

  exports.AlwaysDirtyVisitor = AlwaysDirtyVisitor;
  exports.default = {
    block: function (node, morph, env, scope, template, visitor) {
      dirtyCheck(env, morph, visitor, function (visitor) {
        AlwaysDirtyVisitor.block(node, morph, env, scope, template, visitor);
      });
    },

    inline: function (node, morph, env, scope, visitor) {
      dirtyCheck(env, morph, visitor, function (visitor) {
        AlwaysDirtyVisitor.inline(node, morph, env, scope, visitor);
      });
    },

    content: function (node, morph, env, scope, visitor) {
      dirtyCheck(env, morph, visitor, function (visitor) {
        AlwaysDirtyVisitor.content(node, morph, env, scope, visitor);
      });
    },

    element: function (node, morph, env, scope, template, visitor) {
      dirtyCheck(env, morph, visitor, function (visitor) {
        AlwaysDirtyVisitor.element(node, morph, env, scope, template, visitor);
      });
    },

    attribute: function (node, morph, env, scope, template) {
      dirtyCheck(env, morph, null, function () {
        AlwaysDirtyVisitor.attribute(node, morph, env, scope, template);
      });
    },

    component: function (node, morph, env, scope, template, visitor) {
      dirtyCheck(env, morph, visitor, function (visitor) {
        AlwaysDirtyVisitor.component(node, morph, env, scope, template, visitor);
      });
    },

    attributes: function (node, morph, env, scope, parentMorph, visitor) {
      AlwaysDirtyVisitor.attributes(node, morph, env, scope, parentMorph, visitor);
    }
  };

  function dirtyCheck(_env, morph, visitor, callback) {
    var isDirty = morph.isDirty;
    var isSubtreeDirty = morph.isSubtreeDirty;
    var env = _env;

    if (isSubtreeDirty) {
      visitor = AlwaysDirtyVisitor;
    }

    if (isDirty || isSubtreeDirty) {
      callback(visitor);
    } else {
      if (morph.buildChildEnv) {
        env = morph.buildChildEnv(morph.getState(), env);
      }
      morphUtils.validateChildMorphs(env, morph, visitor);
    }
  }

  function isHelper(env, scope, path) {
    return env.hooks.keywords[path] !== undefined || env.hooks.hasHelper(env, scope, path);
  }

  });

  unwrapExports(nodeVisitor);
  var nodeVisitor_1 = nodeVisitor.AlwaysDirtyVisitor;

  var templateUtils = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  var _slice = Array.prototype.slice;
  exports.RenderState = RenderState;
  exports.blockFor = blockFor;
  exports.renderAndCleanup = renderAndCleanup;
  exports.clearMorph = clearMorph;
  exports.clearMorphList = clearMorphList;
  exports.buildStatement = buildStatement;





  function RenderState(renderNode, morphList) {
    // The morph list that is no longer needed and can be
    // destroyed.
    this.morphListToClear = morphList;

    // The morph list that needs to be pruned of any items
    // that were not yielded on a subsequent render.
    this.morphListToPrune = null;

    // A map of morphs for each item yielded in during this
    // rendering pass. Any morphs in the DOM but not in this map
    // will be pruned during cleanup.
    this.handledMorphs = {};
    this.collisions = undefined;

    // The morph to clear once rendering is complete. By
    // default, we set this to the previous morph (to catch
    // the case where nothing is yielded; in that case, we
    // should just clear the morph). Otherwise this gets set
    // to null if anything is rendered.
    this.morphToClear = renderNode;

    this.shadowOptions = null;
  }

  function Block(render, template, blockOptions) {
    this.render = render;
    this.template = template;
    this.blockOptions = blockOptions;
    this.arity = template.arity;
  }

  Block.prototype.invoke = function (env, blockArguments, _self, renderNode, parentScope, visitor) {
    if (renderNode.lastResult) {
      renderNode.lastResult.revalidateWith(env, undefined, _self, blockArguments, visitor);
    } else {
      this._firstRender(env, blockArguments, _self, renderNode, parentScope);
    }
  };

  Block.prototype._firstRender = function (env, blockArguments, _self, renderNode, parentScope) {
    var options = { renderState: new RenderState(renderNode) };
    var render = this.render;
    var template = this.template;
    var scope = this.blockOptions.scope;

    var shadowScope = scope ? env.hooks.createChildScope(scope) : env.hooks.createFreshScope();

    env.hooks.bindShadowScope(env, parentScope, shadowScope, this.blockOptions.options);

    if (_self !== undefined) {
      env.hooks.bindSelf(env, shadowScope, _self);
    } else if (this.blockOptions.self !== undefined) {
      env.hooks.bindSelf(env, shadowScope, this.blockOptions.self);
    }

    bindBlocks(env, shadowScope, this.blockOptions.yieldTo);

    renderAndCleanup(renderNode, env, options, null, function () {
      options.renderState.morphToClear = null;
      var renderOptions = new render_1.RenderOptions(renderNode, undefined, blockArguments);
      render(template, env, shadowScope, renderOptions);
    });
  };

  function blockFor(render, template, blockOptions) {
    return new Block(render, template, blockOptions);
  }

  function bindBlocks(env, shadowScope, blocks) {
    if (!blocks) {
      return;
    }
    if (blocks instanceof Block) {
      env.hooks.bindBlock(env, shadowScope, blocks);
    } else {
      for (var name in blocks) {
        if (blocks.hasOwnProperty(name)) {
          env.hooks.bindBlock(env, shadowScope, blocks[name], name);
        }
      }
    }
  }

  function renderAndCleanup(morph, env, options, shadowOptions, callback) {
    // The RenderState object is used to collect information about what the
    // helper or hook being invoked has yielded. Once it has finished either
    // yielding multiple items (via yieldItem) or a single template (via
    // yieldTemplate), we detect what was rendered and how it differs from
    // the previous render, cleaning up old state in DOM as appropriate.
    var renderState = options.renderState;
    renderState.collisions = undefined;
    renderState.shadowOptions = shadowOptions;

    // Invoke the callback, instructing it to save information about what it
    // renders into RenderState.
    var result = callback(options);

    // The hook can opt-out of cleanup if it handled cleanup itself.
    if (result && result.handled) {
      return;
    }

    var morphMap = morph.morphMap;

    // Walk the morph list, clearing any items that were yielded in a previous
    // render but were not yielded during this render.
    var morphList = renderState.morphListToPrune;
    if (morphList) {
      var handledMorphs = renderState.handledMorphs;
      var item = morphList.firstChildMorph;

      while (item) {
        var next = item.nextMorph;

        // If we don't see the key in handledMorphs, it wasn't
        // yielded in and we can safely remove it from DOM.
        if (!(item.key in handledMorphs)) {
          morphMap[item.key] = undefined;
          clearMorph(item, env, true);
          item.destroy();
        }

        item = next;
      }
    }

    morphList = renderState.morphListToClear;
    if (morphList) {
      clearMorphList(morphList, morph, env);
    }

    var toClear = renderState.morphToClear;
    if (toClear) {
      clearMorph(toClear, env);
    }
  }

  function clearMorph(morph, env, destroySelf) {
    var cleanup = env.hooks.cleanupRenderNode;
    var destroy = env.hooks.destroyRenderNode;
    var willCleanup = env.hooks.willCleanupTree;
    var didCleanup = env.hooks.didCleanupTree;

    function destroyNode(node) {
      if (cleanup) {
        cleanup(node);
      }
      if (destroy) {
        destroy(node);
      }
    }

    if (willCleanup) {
      willCleanup(env, morph, destroySelf);
    }
    if (cleanup) {
      cleanup(morph);
    }
    if (destroySelf && destroy) {
      destroy(morph);
    }

    morphUtils.visitChildren(morph.childNodes, destroyNode);

    // TODO: Deal with logical children that are not in the DOM tree
    morph.clear();
    if (didCleanup) {
      didCleanup(env, morph, destroySelf);
    }

    morph.lastResult = null;
    morph.lastYielded = null;
    morph.childNodes = null;
  }

  function clearMorphList(morphList, morph, env) {
    var item = morphList.firstChildMorph;

    while (item) {
      var next = item.nextMorph;
      morph.morphMap[item.key] = undefined;
      clearMorph(item, env, true);
      item.destroy();

      item = next;
    }

    // Remove the MorphList from the morph.
    morphList.clear();
    morph.morphList = null;
  }

  function buildStatement() {
    var statement = [].concat(_slice.call(arguments));

    // ensure array length is 7 by padding with 0
    for (var i = arguments.length; i < 7; i++) {
      statement[i] = 0;
    }

    return statement;
  }

  });

  unwrapExports(templateUtils);
  var templateUtils_1 = templateUtils.RenderState;
  var templateUtils_2 = templateUtils.blockFor;
  var templateUtils_3 = templateUtils.renderAndCleanup;
  var templateUtils_4 = templateUtils.clearMorph;
  var templateUtils_5 = templateUtils.clearMorphList;
  var templateUtils_6 = templateUtils.buildStatement;

  var arrayUtils = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.forEach = forEach;
  exports.map = map;

  function forEach(array, callback, binding) {
    var i, l;
    if (binding === undefined) {
      for (i = 0, l = array.length; i < l; i++) {
        callback(array[i], i, array);
      }
    } else {
      for (i = 0, l = array.length; i < l; i++) {
        callback.call(binding, array[i], i, array);
      }
    }
  }

  function map(array, callback) {
    var output = [];
    var i, l;

    for (i = 0, l = array.length; i < l; i++) {
      output.push(callback(array[i], i, array));
    }

    return output;
  }

  var getIdx;
  if (Array.prototype.indexOf) {
    getIdx = function (array, obj, from) {
      return array.indexOf(obj, from);
    };
  } else {
    getIdx = function (array, obj, from) {
      if (from === undefined || from === null) {
        from = 0;
      } else if (from < 0) {
        from = Math.max(0, array.length + from);
      }
      for (var i = from, l = array.length; i < l; i++) {
        if (array[i] === obj) {
          return i;
        }
      }
      return -1;
    };
  }

  var isArray = Array.isArray || function (array) {
    return Object.prototype.toString.call(array) === '[object Array]';
  };

  exports.isArray = isArray;
  var indexOfArray = getIdx;
  exports.indexOfArray = indexOfArray;

  });

  unwrapExports(arrayUtils);
  var arrayUtils_1 = arrayUtils.forEach;
  var arrayUtils_2 = arrayUtils.map;
  var arrayUtils_3 = arrayUtils.isArray;
  var arrayUtils_4 = arrayUtils.indexOfArray;

  var voidTagNames_1 = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;



  // The HTML elements in this list are speced by
  // http://www.w3.org/TR/html-markup/syntax.html#syntax-elements,
  // and will be forced to close regardless of if they have a
  // self-closing /> at the end.
  var voidTagNames = "area base br col command embed hr img input keygen link meta param source track wbr";
  var voidMap = {};

  arrayUtils.forEach(voidTagNames.split(" "), function (tagName) {
    voidMap[tagName] = true;
  });

  exports.default = voidMap;
  module.exports = exports.default;

  });

  unwrapExports(voidTagNames_1);

  var render_1 = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.default = render;
  exports.RenderOptions = RenderOptions;
  exports.manualElement = manualElement;
  exports.attachAttributes = attachAttributes;
  exports.createChildMorph = createChildMorph;
  exports.getCachedFragment = getCachedFragment;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }





  var _nodeVisitor2 = _interopRequireDefault(nodeVisitor);



  var _morph2 = _interopRequireDefault(morph);





  var _htmlbarsUtilVoidTagNames2 = _interopRequireDefault(voidTagNames_1);

  var svgNamespace = "http://www.w3.org/2000/svg";

  function render(template, env, scope, options) {
    var dom = env.dom;
    var contextualElement;

    if (options) {
      if (options.renderNode) {
        contextualElement = options.renderNode.contextualElement;
      } else if (options.contextualElement) {
        contextualElement = options.contextualElement;
      }
    }

    dom.detectNamespace(contextualElement);

    var renderResult = RenderResult.build(env, scope, template, options, contextualElement);
    renderResult.render();

    return renderResult;
  }

  function RenderOptions(renderNode, self, blockArguments, contextualElement) {
    this.renderNode = renderNode || null;
    this.self = self;
    this.blockArguments = blockArguments || null;
    this.contextualElement = contextualElement || null;
  }

  function RenderResult(env, scope, options, rootNode, ownerNode, nodes, fragment, template, shouldSetContent) {
    this.root = rootNode;
    this.fragment = fragment;

    this.nodes = nodes;
    this.template = template;
    this.statements = template.statements.slice();
    this.env = env;
    this.scope = scope;
    this.shouldSetContent = shouldSetContent;

    if (options.self !== undefined) {
      this.bindSelf(options.self);
    }
    if (options.blockArguments !== undefined) {
      this.bindLocals(options.blockArguments);
    }

    this.initializeNodes(ownerNode);
  }

  RenderResult.build = function (env, scope, template, options, contextualElement) {
    var dom = env.dom;
    var fragment = getCachedFragment(template, env);
    var nodes = template.buildRenderNodes(dom, fragment, contextualElement);

    var rootNode, ownerNode, shouldSetContent;

    if (options && options.renderNode) {
      rootNode = options.renderNode;
      ownerNode = rootNode.ownerNode;
      shouldSetContent = true;
    } else {
      rootNode = dom.createMorph(null, fragment.firstChild, fragment.lastChild, contextualElement);
      ownerNode = rootNode;
      rootNode.ownerNode = ownerNode;
      shouldSetContent = false;
    }

    if (rootNode.childNodes) {
      morphUtils.visitChildren(rootNode.childNodes, function (node) {
        templateUtils.clearMorph(node, env, true);
      });
    }

    rootNode.childNodes = nodes;
    return new RenderResult(env, scope, options, rootNode, ownerNode, nodes, fragment, template, shouldSetContent);
  };

  function manualElement(tagName, attributes, _isEmpty) {
    var statements = [];

    for (var key in attributes) {
      if (typeof attributes[key] === 'string') {
        continue;
      }

      statements.push(templateUtils.buildStatement("attribute", key, attributes[key]));
    }

    var isEmpty = _isEmpty || _htmlbarsUtilVoidTagNames2.default[tagName];

    if (!isEmpty) {
      statements.push(templateUtils.buildStatement('content', 'yield'));
    }

    var template = {
      arity: 0,
      cachedFragment: null,
      hasRendered: false,
      buildFragment: function buildFragment(dom) {
        var el0 = dom.createDocumentFragment();
        if (tagName === 'svg') {
          dom.setNamespace(svgNamespace);
        }
        var el1 = dom.createElement(tagName);

        for (var key in attributes) {
          if (typeof attributes[key] !== 'string') {
            continue;
          }
          dom.setAttribute(el1, key, attributes[key]);
        }

        if (!isEmpty) {
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
        }

        dom.appendChild(el0, el1);

        return el0;
      },
      buildRenderNodes: function buildRenderNodes(dom, fragment) {
        var element = dom.childAt(fragment, [0]);
        var morphs = [];

        for (var key in attributes) {
          if (typeof attributes[key] === 'string') {
            continue;
          }
          morphs.push(dom.createAttrMorph(element, key));
        }

        if (!isEmpty) {
          morphs.push(dom.createMorphAt(element, 0, 0));
        }

        return morphs;
      },
      statements: statements,
      locals: [],
      templates: []
    };

    return template;
  }

  function attachAttributes(attributes) {
    var statements = [];

    for (var key in attributes) {
      if (typeof attributes[key] === 'string') {
        continue;
      }
      statements.push(templateUtils.buildStatement("attribute", key, attributes[key]));
    }

    var template = {
      arity: 0,
      cachedFragment: null,
      hasRendered: false,
      buildFragment: function buildFragment(dom) {
        var el0 = this.element;
        if (el0.namespaceURI === "http://www.w3.org/2000/svg") {
          dom.setNamespace(svgNamespace);
        }
        for (var key in attributes) {
          if (typeof attributes[key] !== 'string') {
            continue;
          }
          dom.setAttribute(el0, key, attributes[key]);
        }

        return el0;
      },
      buildRenderNodes: function buildRenderNodes(dom) {
        var element = this.element;
        var morphs = [];

        for (var key in attributes) {
          if (typeof attributes[key] === 'string') {
            continue;
          }
          morphs.push(dom.createAttrMorph(element, key));
        }

        return morphs;
      },
      statements: statements,
      locals: [],
      templates: [],
      element: null
    };

    return template;
  }

  RenderResult.prototype.initializeNodes = function (ownerNode) {
    var childNodes = this.root.childNodes;

    for (var i = 0, l = childNodes.length; i < l; i++) {
      childNodes[i].ownerNode = ownerNode;
    }
  };

  RenderResult.prototype.render = function () {
    this.root.lastResult = this;
    this.root.rendered = true;
    this.populateNodes(nodeVisitor.AlwaysDirtyVisitor);

    if (this.shouldSetContent && this.root.setContent) {
      this.root.setContent(this.fragment);
    }
  };

  RenderResult.prototype.dirty = function () {
    morphUtils.visitChildren([this.root], function (node) {
      node.isDirty = true;
    });
  };

  RenderResult.prototype.revalidate = function (env, self, blockArguments, scope) {
    this.revalidateWith(env, scope, self, blockArguments, _nodeVisitor2.default);
  };

  RenderResult.prototype.rerender = function (env, self, blockArguments, scope) {
    this.revalidateWith(env, scope, self, blockArguments, nodeVisitor.AlwaysDirtyVisitor);
  };

  RenderResult.prototype.revalidateWith = function (env, scope, self, blockArguments, visitor) {
    if (env !== undefined) {
      this.env = env;
    }
    if (scope !== undefined) {
      this.scope = scope;
    }
    this.updateScope();

    if (self !== undefined) {
      this.updateSelf(self);
    }
    if (blockArguments !== undefined) {
      this.updateLocals(blockArguments);
    }

    this.populateNodes(visitor);
  };

  RenderResult.prototype.destroy = function () {
    var rootNode = this.root;
    templateUtils.clearMorph(rootNode, this.env, true);
  };

  RenderResult.prototype.populateNodes = function (visitor) {
    var env = this.env;
    var scope = this.scope;
    var template = this.template;
    var nodes = this.nodes;
    var statements = this.statements;
    var i, l;

    for (i = 0, l = statements.length; i < l; i++) {
      var statement = statements[i];
      var morph$$1 = nodes[i];

      if (env.hooks.willRenderNode) {
        env.hooks.willRenderNode(morph$$1, env, scope);
      }

      switch (statement[0]) {
        case 'block':
          visitor.block(statement, morph$$1, env, scope, template, visitor);break;
        case 'inline':
          visitor.inline(statement, morph$$1, env, scope, visitor);break;
        case 'content':
          visitor.content(statement, morph$$1, env, scope, visitor);break;
        case 'element':
          visitor.element(statement, morph$$1, env, scope, template, visitor);break;
        case 'attribute':
          visitor.attribute(statement, morph$$1, env, scope);break;
        case 'component':
          visitor.component(statement, morph$$1, env, scope, template, visitor);break;
      }

      if (env.hooks.didRenderNode) {
        env.hooks.didRenderNode(morph$$1, env, scope);
      }
    }
  };

  RenderResult.prototype.bindScope = function () {
    this.env.hooks.bindScope(this.env, this.scope);
  };

  RenderResult.prototype.updateScope = function () {
    this.env.hooks.updateScope(this.env, this.scope);
  };

  RenderResult.prototype.bindSelf = function (self) {
    this.env.hooks.bindSelf(this.env, this.scope, self);
  };

  RenderResult.prototype.updateSelf = function (self) {
    this.env.hooks.updateSelf(this.env, this.scope, self);
  };

  RenderResult.prototype.bindLocals = function (blockArguments) {
    var localNames = this.template.locals;

    for (var i = 0, l = localNames.length; i < l; i++) {
      this.env.hooks.bindLocal(this.env, this.scope, localNames[i], blockArguments[i]);
    }
  };

  RenderResult.prototype.updateLocals = function (blockArguments) {
    var localNames = this.template.locals;

    for (var i = 0, l = localNames.length; i < l; i++) {
      this.env.hooks.updateLocal(this.env, this.scope, localNames[i], blockArguments[i]);
    }
  };

  function initializeNode(node, owner) {
    node.ownerNode = owner;
  }

  function createChildMorph(dom, parentMorph, contextualElement) {
    var morph$$1 = _morph2.default.empty(dom, contextualElement || parentMorph.contextualElement);
    initializeNode(morph$$1, parentMorph.ownerNode);
    return morph$$1;
  }

  function getCachedFragment(template, env) {
    var dom = env.dom,
        fragment;
    if (env.useFragmentCache && dom.canClone) {
      if (template.cachedFragment === null) {
        fragment = template.buildFragment(dom);
        if (template.hasRendered) {
          template.cachedFragment = fragment;
        } else {
          template.hasRendered = true;
        }
      }
      if (template.cachedFragment) {
        fragment = dom.cloneNode(template.cachedFragment, true);
      }
    } else if (!fragment) {
      fragment = template.buildFragment(dom);
    }

    return fragment;
  }

  });

  var render = unwrapExports(render_1);
  var render_2 = render_1.RenderOptions;
  var render_3 = render_1.manualElement;
  var render_4 = render_1.attachAttributes;
  var render_5 = render_1.createChildMorph;
  var render_6 = render_1.getCachedFragment;

  var morphList = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;



  function MorphList() {
    // morph graph
    this.firstChildMorph = null;
    this.lastChildMorph = null;

    this.mountedMorph = null;
  }

  var prototype = MorphList.prototype;

  prototype.clear = function MorphList$clear() {
    var current = this.firstChildMorph;

    while (current) {
      var next = current.nextMorph;
      current.previousMorph = null;
      current.nextMorph = null;
      current.parentMorphList = null;
      current = next;
    }

    this.firstChildMorph = this.lastChildMorph = null;
  };

  prototype.destroy = function MorphList$destroy() {};

  prototype.appendMorph = function MorphList$appendMorph(morph) {
    this.insertBeforeMorph(morph, null);
  };

  prototype.insertBeforeMorph = function MorphList$insertBeforeMorph(morph, referenceMorph) {
    if (morph.parentMorphList !== null) {
      morph.unlink();
    }
    if (referenceMorph && referenceMorph.parentMorphList !== this) {
      throw new Error('The morph before which the new morph is to be inserted is not a child of this morph.');
    }

    var mountedMorph = this.mountedMorph;

    if (mountedMorph) {

      var parentNode = mountedMorph.firstNode.parentNode;
      var referenceNode = referenceMorph ? referenceMorph.firstNode : mountedMorph.lastNode.nextSibling;

      utils.insertBefore(parentNode, morph.firstNode, morph.lastNode, referenceNode);

      // was not in list mode replace current content
      if (!this.firstChildMorph) {
        utils.clear(this.mountedMorph.firstNode.parentNode, this.mountedMorph.firstNode, this.mountedMorph.lastNode);
      }
    }

    morph.parentMorphList = this;

    var previousMorph = referenceMorph ? referenceMorph.previousMorph : this.lastChildMorph;
    if (previousMorph) {
      previousMorph.nextMorph = morph;
      morph.previousMorph = previousMorph;
    } else {
      this.firstChildMorph = morph;
    }

    if (referenceMorph) {
      referenceMorph.previousMorph = morph;
      morph.nextMorph = referenceMorph;
    } else {
      this.lastChildMorph = morph;
    }

    this.firstChildMorph._syncFirstNode();
    this.lastChildMorph._syncLastNode();
  };

  prototype.removeChildMorph = function MorphList$removeChildMorph(morph) {
    if (morph.parentMorphList !== this) {
      throw new Error("Cannot remove a morph from a parent it is not inside of");
    }

    morph.destroy();
  };

  exports.default = MorphList;
  module.exports = exports.default;

  });

  unwrapExports(morphList);

  var objectUtils = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.merge = merge;
  exports.shallowCopy = shallowCopy;
  exports.keySet = keySet;
  exports.keyLength = keyLength;

  function merge(options, defaults) {
    for (var prop in defaults) {
      if (options.hasOwnProperty(prop)) {
        continue;
      }
      options[prop] = defaults[prop];
    }
    return options;
  }

  function shallowCopy(obj) {
    return merge({}, obj);
  }

  function keySet(obj) {
    var set = {};

    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        set[prop] = true;
      }
    }

    return set;
  }

  function keyLength(obj) {
    var count = 0;

    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        count++;
      }
    }

    return count;
  }

  });

  unwrapExports(objectUtils);
  var objectUtils_1 = objectUtils.merge;
  var objectUtils_2 = objectUtils.shallowCopy;
  var objectUtils_3 = objectUtils.keySet;
  var objectUtils_4 = objectUtils.keyLength;

  var hooks = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.wrap = wrap;
  exports.wrapForHelper = wrapForHelper;
  exports.createScope = createScope;
  exports.createFreshScope = createFreshScope;
  exports.bindShadowScope = bindShadowScope;
  exports.createChildScope = createChildScope;
  exports.bindSelf = bindSelf;
  exports.updateSelf = updateSelf;
  exports.bindLocal = bindLocal;
  exports.updateLocal = updateLocal;
  exports.bindBlock = bindBlock;
  exports.block = block;
  exports.continueBlock = continueBlock;
  exports.hostBlock = hostBlock;
  exports.handleRedirect = handleRedirect;
  exports.handleKeyword = handleKeyword;
  exports.linkRenderNode = linkRenderNode;
  exports.inline = inline;
  exports.keyword = keyword;
  exports.invokeHelper = invokeHelper;
  exports.classify = classify;
  exports.partial = partial;
  exports.range = range;
  exports.element = element;
  exports.attribute = attribute;
  exports.subexpr = subexpr;
  exports.get = get;
  exports.getRoot = getRoot;
  exports.getBlock = getBlock;
  exports.getChild = getChild;
  exports.getValue = getValue;
  exports.getCellOrValue = getCellOrValue;
  exports.component = component;
  exports.concat = concat;
  exports.hasHelper = hasHelper;
  exports.lookupHelper = lookupHelper;
  exports.bindScope = bindScope;
  exports.updateScope = updateScope;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }



  var _render2 = _interopRequireDefault(render_1);



  var _morphRangeMorphList2 = _interopRequireDefault(morphList);







  /**
    HTMLBars delegates the runtime behavior of a template to
    hooks provided by the host environment. These hooks explain
    the lexical environment of a Handlebars template, the internal
    representation of references, and the interaction between an
    HTMLBars template and the DOM it is managing.

    While HTMLBars host hooks have access to all of this internal
    machinery, templates and helpers have access to the abstraction
    provided by the host hooks.

    ## The Lexical Environment

    The default lexical environment of an HTMLBars template includes:

    * Any local variables, provided by *block arguments*
    * The current value of `self`

    ## Simple Nesting

    Let's look at a simple template with a nested block:

    ```hbs
    <h1>{{title}}</h1>

    {{#if author}}
      <p class="byline">{{author}}</p>
    {{/if}}
    ```

    In this case, the lexical environment at the top-level of the
    template does not change inside of the `if` block. This is
    achieved via an implementation of `if` that looks like this:

    ```js
    registerHelper('if', function(params) {
      if (!!params[0]) {
        return this.yield();
      }
    });
    ```

    A call to `this.yield` invokes the child template using the
    current lexical environment.

    ## Block Arguments

    It is possible for nested blocks to introduce new local
    variables:

    ```hbs
    {{#count-calls as |i|}}
    <h1>{{title}}</h1>
    <p>Called {{i}} times</p>
    {{/count}}
    ```

    In this example, the child block inherits its surrounding
    lexical environment, but augments it with a single new
    variable binding.

    The implementation of `count-calls` supplies the value of
    `i`, but does not otherwise alter the environment:

    ```js
    var count = 0;
    registerHelper('count-calls', function() {
      return this.yield([ ++count ]);
    });
    ```
  */

  function wrap(template) {
    if (template === null) {
      return null;
    }

    return {
      meta: template.meta,
      arity: template.arity,
      raw: template,
      render: function (self, env, options, blockArguments) {
        var scope = env.hooks.createFreshScope();

        var contextualElement = options && options.contextualElement;
        var renderOptions = new render_1.RenderOptions(null, self, blockArguments, contextualElement);

        return _render2.default(template, env, scope, renderOptions);
      }
    };
  }

  function wrapForHelper(template, env, scope, morph, renderState, visitor) {
    if (!template) {
      return {};
    }

    var yieldArgs = yieldTemplate(template, env, scope, morph, renderState, visitor);

    return {
      meta: template.meta,
      arity: template.arity,
      'yield': yieldArgs, // quoted since it's a reserved word, see issue #420
      yieldItem: yieldItem(template, env, scope, morph, renderState, visitor),
      raw: template,

      render: function (self, blockArguments) {
        yieldArgs(blockArguments, self);
      }
    };
  }

  // Called by a user-land helper to render a template.
  function yieldTemplate(template, env, parentScope, morph, renderState, visitor) {
    return function (blockArguments, self) {
      // Render state is used to track the progress of the helper (since it
      // may call into us multiple times). As the user-land helper calls
      // into library code, we track what needs to be cleaned up after the
      // helper has returned.
      //
      // Here, we remember that a template has been yielded and so we do not
      // need to remove the previous template. (If no template is yielded
      // this render by the helper, we assume nothing should be shown and
      // remove any previous rendered templates.)
      renderState.morphToClear = null;

      // In this conditional is true, it means that on the previous rendering pass
      // the helper yielded multiple items via `yieldItem()`, but this time they
      // are yielding a single template. In that case, we mark the morph list for
      // cleanup so it is removed from the DOM.
      if (morph.morphList) {
        templateUtils.clearMorphList(morph.morphList, morph, env);
        renderState.morphListToClear = null;
      }

      var scope = parentScope;

      if (morph.lastYielded && isStableTemplate(template, morph.lastYielded)) {
        return morph.lastResult.revalidateWith(env, undefined, self, blockArguments, visitor);
      }

      // Check to make sure that we actually **need** a new scope, and can't
      // share the parent scope. Note that we need to move this check into
      // a host hook, because the host's notion of scope may require a new
      // scope in more cases than the ones we can determine statically.
      if (self !== undefined || parentScope === null || template.arity) {
        scope = env.hooks.createChildScope(parentScope);
      }

      morph.lastYielded = { self: self, template: template, shadowTemplate: null };

      // Render the template that was selected by the helper
      var renderOptions = new render_1.RenderOptions(morph, self, blockArguments);
      _render2.default(template, env, scope, renderOptions);
    };
  }

  function yieldItem(template, env, parentScope, morph, renderState, visitor) {
    // Initialize state that tracks multiple items being
    // yielded in.
    var currentMorph = null;

    // Candidate morphs for deletion.
    var candidates = {};

    // Reuse existing MorphList if this is not a first-time
    // render.
    var morphList$$1 = morph.morphList;
    if (morphList$$1) {
      currentMorph = morphList$$1.firstChildMorph;
    }

    // Advances the currentMorph pointer to the morph in the previously-rendered
    // list that matches the yielded key. While doing so, it marks any morphs
    // that it advances past as candidates for deletion. Assuming those morphs
    // are not yielded in later, they will be removed in the prune step during
    // cleanup.
    // Note that this helper function assumes that the morph being seeked to is
    // guaranteed to exist in the previous MorphList; if this is called and the
    // morph does not exist, it will result in an infinite loop
    function advanceToKey(key) {
      var seek = currentMorph;

      while (seek.key !== key) {
        candidates[seek.key] = seek;
        seek = seek.nextMorph;
      }

      currentMorph = seek.nextMorph;
      return seek;
    }

    return function (_key, blockArguments, self) {
      if (typeof _key !== 'string') {
        throw new Error("You must provide a string key when calling `yieldItem`; you provided " + _key);
      }

      // At least one item has been yielded, so we do not wholesale
      // clear the last MorphList but instead apply a prune operation.
      renderState.morphListToClear = null;
      morph.lastYielded = null;

      var morphList$$1, morphMap;

      if (!morph.morphList) {
        morph.morphList = new _morphRangeMorphList2.default();
        morph.morphMap = {};
        morph.setMorphList(morph.morphList);
      }

      morphList$$1 = morph.morphList;
      morphMap = morph.morphMap;

      // A map of morphs that have been yielded in on this
      // rendering pass. Any morphs that do not make it into
      // this list will be pruned from the MorphList during the cleanup
      // process.
      var handledMorphs = renderState.handledMorphs;
      var key = undefined;

      if (_key in handledMorphs) {
        // In this branch we are dealing with a duplicate key. The strategy
        // is to take the original key and append a counter to it that is
        // incremented every time the key is reused. In order to greatly
        // reduce the chance of colliding with another valid key we also add
        // an extra string "--z8mS2hvDW0A--" to the new key.
        var collisions = renderState.collisions;
        if (collisions === undefined) {
          collisions = renderState.collisions = {};
        }
        var count = collisions[_key] | 0;
        collisions[_key] = ++count;

        key = _key + '--z8mS2hvDW0A--' + count;
      } else {
        key = _key;
      }

      if (currentMorph && currentMorph.key === key) {
        yieldTemplate(template, env, parentScope, currentMorph, renderState, visitor)(blockArguments, self);
        currentMorph = currentMorph.nextMorph;
        handledMorphs[key] = currentMorph;
      } else if (morphMap[key] !== undefined) {
        var foundMorph = morphMap[key];

        if (key in candidates) {
          // If we already saw this morph, move it forward to this position
          morphList$$1.insertBeforeMorph(foundMorph, currentMorph);
        } else {
          // Otherwise, move the pointer forward to the existing morph for this key
          advanceToKey(key);
        }

        handledMorphs[foundMorph.key] = foundMorph;
        yieldTemplate(template, env, parentScope, foundMorph, renderState, visitor)(blockArguments, self);
      } else {
        var childMorph = render_1.createChildMorph(env.dom, morph);
        childMorph.key = key;
        morphMap[key] = handledMorphs[key] = childMorph;
        morphList$$1.insertBeforeMorph(childMorph, currentMorph);
        yieldTemplate(template, env, parentScope, childMorph, renderState, visitor)(blockArguments, self);
      }

      renderState.morphListToPrune = morphList$$1;
      morph.childNodes = null;
    };
  }

  function isStableTemplate(template, lastYielded) {
    return !lastYielded.shadowTemplate && template === lastYielded.template;
  }
  function optionsFor(template, inverse, env, scope, morph, visitor) {
    // If there was a template yielded last time, set morphToClear so it will be cleared
    // if no template is yielded on this render.
    var morphToClear = morph.lastResult ? morph : null;
    var renderState = new templateUtils.RenderState(morphToClear, morph.morphList || null);

    return {
      templates: {
        template: wrapForHelper(template, env, scope, morph, renderState, visitor),
        inverse: wrapForHelper(inverse, env, scope, morph, renderState, visitor)
      },
      renderState: renderState
    };
  }

  function thisFor(options) {
    return {
      arity: options.template.arity,
      'yield': options.template.yield, // quoted since it's a reserved word, see issue #420
      yieldItem: options.template.yieldItem,
      yieldIn: options.template.yieldIn
    };
  }

  /**
    Host Hook: createScope

    @param {Scope?} parentScope
    @return Scope

    Corresponds to entering a new HTMLBars block.

    This hook is invoked when a block is entered with
    a new `self` or additional local variables.

    When invoked for a top-level template, the
    `parentScope` is `null`, and this hook should return
    a fresh Scope.

    When invoked for a child template, the `parentScope`
    is the scope for the parent environment.

    Note that the `Scope` is an opaque value that is
    passed to other host hooks. For example, the `get`
    hook uses the scope to retrieve a value for a given
    scope and variable name.
  */

  function createScope(env, parentScope) {
    if (parentScope) {
      return env.hooks.createChildScope(parentScope);
    } else {
      return env.hooks.createFreshScope();
    }
  }

  function createFreshScope() {
    // because `in` checks have unpredictable performance, keep a
    // separate dictionary to track whether a local was bound.
    // See `bindLocal` for more information.
    return { self: null, blocks: {}, locals: {}, localPresent: {} };
  }

  /**
    Host Hook: bindShadowScope

    @param {Scope?} parentScope
    @return Scope

    Corresponds to rendering a new template into an existing
    render tree, but with a new top-level lexical scope. This
    template is called the "shadow root".

    If a shadow template invokes `{{yield}}`, it will render
    the block provided to the shadow root in the original
    lexical scope.

    ```hbs
    {{!-- post template --}}
    <p>{{props.title}}</p>
    {{yield}}

    {{!-- blog template --}}
    {{#post title="Hello world"}}
      <p>by {{byline}}</p>
      <article>This is my first post</article>
    {{/post}}

    {{#post title="Goodbye world"}}
      <p>by {{byline}}</p>
      <article>This is my last post</article>
    {{/post}}
    ```

    ```js
    helpers.post = function(params, hash, options) {
      options.template.yieldIn(postTemplate, { props: hash });
    };

    blog.render({ byline: "Yehuda Katz" });
    ```

    Produces:

    ```html
    <p>Hello world</p>
    <p>by Yehuda Katz</p>
    <article>This is my first post</article>

    <p>Goodbye world</p>
    <p>by Yehuda Katz</p>
    <article>This is my last post</article>
    ```

    In short, `yieldIn` creates a new top-level scope for the
    provided template and renders it, making the original block
    available to `{{yield}}` in that template.
  */

  function bindShadowScope(env /*, parentScope, shadowScope */) {
    return env.hooks.createFreshScope();
  }

  function createChildScope(parent) {
    var scope = Object.create(parent);
    scope.locals = Object.create(parent.locals);
    scope.localPresent = Object.create(parent.localPresent);
    scope.blocks = Object.create(parent.blocks);
    return scope;
  }

  /**
    Host Hook: bindSelf

    @param {Scope} scope
    @param {any} self

    Corresponds to entering a template.

    This hook is invoked when the `self` value for a scope is ready to be bound.

    The host must ensure that child scopes reflect the change to the `self` in
    future calls to the `get` hook.
  */

  function bindSelf(env, scope, self) {
    scope.self = self;
  }

  function updateSelf(env, scope, self) {
    env.hooks.bindSelf(env, scope, self);
  }

  /**
    Host Hook: bindLocal

    @param {Environment} env
    @param {Scope} scope
    @param {String} name
    @param {any} value

    Corresponds to entering a template with block arguments.

    This hook is invoked when a local variable for a scope has been provided.

    The host must ensure that child scopes reflect the change in future calls
    to the `get` hook.
  */

  function bindLocal(env, scope, name, value) {
    scope.localPresent[name] = true;
    scope.locals[name] = value;
  }

  function updateLocal(env, scope, name, value) {
    env.hooks.bindLocal(env, scope, name, value);
  }

  /**
    Host Hook: bindBlock

    @param {Environment} env
    @param {Scope} scope
    @param {Function} block

    Corresponds to entering a shadow template that was invoked by a block helper with
    `yieldIn`.

    This hook is invoked with an opaque block that will be passed along
    to the shadow template, and inserted into the shadow template when
    `{{yield}}` is used. Optionally provide a non-default block name
    that can be targeted by `{{yield to=blockName}}`.
  */

  function bindBlock(env, scope, block) {
    var name = arguments.length <= 3 || arguments[3] === undefined ? 'default' : arguments[3];

    scope.blocks[name] = block;
  }

  /**
    Host Hook: block

    @param {RenderNode} renderNode
    @param {Environment} env
    @param {Scope} scope
    @param {String} path
    @param {Array} params
    @param {Object} hash
    @param {Block} block
    @param {Block} elseBlock

    Corresponds to:

    ```hbs
    {{#helper param1 param2 key1=val1 key2=val2}}
      {{!-- child template --}}
    {{/helper}}
    ```

    This host hook is a workhorse of the system. It is invoked
    whenever a block is encountered, and is responsible for
    resolving the helper to call, and then invoke it.

    The helper should be invoked with:

    - `{Array} params`: the parameters passed to the helper
      in the template.
    - `{Object} hash`: an object containing the keys and values passed
      in the hash position in the template.

    The values in `params` and `hash` will already be resolved
    through a previous call to the `get` host hook.

    The helper should be invoked with a `this` value that is
    an object with one field:

    `{Function} yield`: when invoked, this function executes the
    block with the current scope. It takes an optional array of
    block parameters. If block parameters are supplied, HTMLBars
    will invoke the `bindLocal` host hook to bind the supplied
    values to the block arguments provided by the template.

    In general, the default implementation of `block` should work
    for most host environments. It delegates to other host hooks
    where appropriate, and properly invokes the helper with the
    appropriate arguments.
  */

  function block(morph, env, scope, path, params, hash, template, inverse, visitor) {
    if (handleRedirect(morph, env, scope, path, params, hash, template, inverse, visitor)) {
      return;
    }

    continueBlock(morph, env, scope, path, params, hash, template, inverse, visitor);
  }

  function continueBlock(morph, env, scope, path, params, hash, template, inverse, visitor) {
    hostBlock(morph, env, scope, template, inverse, null, visitor, function (options) {
      var helper = env.hooks.lookupHelper(env, scope, path);
      return env.hooks.invokeHelper(morph, env, scope, visitor, params, hash, helper, options.templates, thisFor(options.templates));
    });
  }

  function hostBlock(morph, env, scope, template, inverse, shadowOptions, visitor, callback) {
    var options = optionsFor(template, inverse, env, scope, morph, visitor);
    templateUtils.renderAndCleanup(morph, env, options, shadowOptions, callback);
  }

  function handleRedirect(morph, env, scope, path, params, hash, template, inverse, visitor) {
    if (!path) {
      return false;
    }

    var redirect = env.hooks.classify(env, scope, path);
    if (redirect) {
      switch (redirect) {
        case 'component':
          env.hooks.component(morph, env, scope, path, params, hash, { default: template, inverse: inverse }, visitor);break;
        case 'inline':
          env.hooks.inline(morph, env, scope, path, params, hash, visitor);break;
        case 'block':
          env.hooks.block(morph, env, scope, path, params, hash, template, inverse, visitor);break;
        default:
          throw new Error("Internal HTMLBars redirection to " + redirect + " not supported");
      }
      return true;
    }

    if (handleKeyword(path, morph, env, scope, params, hash, template, inverse, visitor)) {
      return true;
    }

    return false;
  }

  function handleKeyword(path, morph, env, scope, params, hash, template, inverse, visitor) {
    var keyword = env.hooks.keywords[path];
    if (!keyword) {
      return false;
    }

    if (typeof keyword === 'function') {
      return keyword(morph, env, scope, params, hash, template, inverse, visitor);
    }

    if (keyword.willRender) {
      keyword.willRender(morph, env);
    }

    var lastState, newState;
    if (keyword.setupState) {
      lastState = objectUtils.shallowCopy(morph.getState());
      newState = morph.setState(keyword.setupState(lastState, env, scope, params, hash));
    }

    if (keyword.childEnv) {
      // Build the child environment...
      env = keyword.childEnv(morph.getState(), env);

      // ..then save off the child env builder on the render node. If the render
      // node tree is re-rendered and this node is not dirty, the child env
      // builder will still be invoked so that child dirty render nodes still get
      // the correct child env.
      morph.buildChildEnv = keyword.childEnv;
    }

    var firstTime = !morph.rendered;

    if (keyword.isEmpty) {
      var isEmpty = keyword.isEmpty(morph.getState(), env, scope, params, hash);

      if (isEmpty) {
        if (!firstTime) {
          templateUtils.clearMorph(morph, env, false);
        }
        return true;
      }
    }

    if (firstTime) {
      if (keyword.render) {
        keyword.render(morph, env, scope, params, hash, template, inverse, visitor);
      }
      morph.rendered = true;
      return true;
    }

    var isStable;
    if (keyword.isStable) {
      isStable = keyword.isStable(lastState, newState);
    } else {
      isStable = stableState(lastState, newState);
    }

    if (isStable) {
      if (keyword.rerender) {
        var newEnv = keyword.rerender(morph, env, scope, params, hash, template, inverse, visitor);
        env = newEnv || env;
      }
      morphUtils.validateChildMorphs(env, morph, visitor);
      return true;
    } else {
      templateUtils.clearMorph(morph, env, false);
    }

    // If the node is unstable, re-render from scratch
    if (keyword.render) {
      keyword.render(morph, env, scope, params, hash, template, inverse, visitor);
      morph.rendered = true;
      return true;
    }
  }

  function stableState(oldState, newState) {
    if (objectUtils.keyLength(oldState) !== objectUtils.keyLength(newState)) {
      return false;
    }

    for (var prop in oldState) {
      if (oldState[prop] !== newState[prop]) {
        return false;
      }
    }

    return true;
  }

  function linkRenderNode() /* morph, env, scope, params, hash */{
    return;
  }

  /**
    Host Hook: inline

    @param {RenderNode} renderNode
    @param {Environment} env
    @param {Scope} scope
    @param {String} path
    @param {Array} params
    @param {Hash} hash

    Corresponds to:

    ```hbs
    {{helper param1 param2 key1=val1 key2=val2}}
    ```

    This host hook is similar to the `block` host hook, but it
    invokes helpers that do not supply an attached block.

    Like the `block` hook, the helper should be invoked with:

    - `{Array} params`: the parameters passed to the helper
      in the template.
    - `{Object} hash`: an object containing the keys and values passed
      in the hash position in the template.

    The values in `params` and `hash` will already be resolved
    through a previous call to the `get` host hook.

    In general, the default implementation of `inline` should work
    for most host environments. It delegates to other host hooks
    where appropriate, and properly invokes the helper with the
    appropriate arguments.

    The default implementation of `inline` also makes `partial`
    a keyword. Instead of invoking a helper named `partial`,
    it invokes the `partial` host hook.
  */

  function inline(morph, env, scope, path, params, hash, visitor) {
    if (handleRedirect(morph, env, scope, path, params, hash, null, null, visitor)) {
      return;
    }

    var value = undefined,
        hasValue = undefined;
    if (morph.linkedResult) {
      value = env.hooks.getValue(morph.linkedResult);
      hasValue = true;
    } else {
      var options = optionsFor(null, null, env, scope, morph);

      var helper = env.hooks.lookupHelper(env, scope, path);
      var result = env.hooks.invokeHelper(morph, env, scope, visitor, params, hash, helper, options.templates, thisFor(options.templates));

      if (result && result.link) {
        morph.linkedResult = result.value;
        morphUtils.linkParams(env, scope, morph, '@content-helper', [morph.linkedResult], null);
      }

      if (result && 'value' in result) {
        value = env.hooks.getValue(result.value);
        hasValue = true;
      }
    }

    if (hasValue) {
      if (morph.lastValue !== value) {
        morph.setContent(value);
      }
      morph.lastValue = value;
    }
  }

  function keyword(path, morph, env, scope, params, hash, template, inverse, visitor) {
    handleKeyword(path, morph, env, scope, params, hash, template, inverse, visitor);
  }

  function invokeHelper(morph, env, scope, visitor, _params, _hash, helper, templates, context) {
    var params = normalizeArray(env, _params);
    var hash = normalizeObject(env, _hash);
    return { value: helper.call(context, params, hash, templates) };
  }

  function normalizeArray(env, array) {
    var out = new Array(array.length);

    for (var i = 0, l = array.length; i < l; i++) {
      out[i] = env.hooks.getCellOrValue(array[i]);
    }

    return out;
  }

  function normalizeObject(env, object) {
    var out = {};

    for (var prop in object) {
      out[prop] = env.hooks.getCellOrValue(object[prop]);
    }

    return out;
  }

  function classify() /* env, scope, path */{
    return null;
  }

  var keywords = {
    partial: function (morph, env, scope, params) {
      var value = env.hooks.partial(morph, env, scope, params[0]);
      morph.setContent(value);
      return true;
    },

    // quoted since it's a reserved word, see issue #420
    'yield': function (morph, env, scope, params, hash, template, inverse, visitor) {
      // the current scope is provided purely for the creation of shadow
      // scopes; it should not be provided to user code.

      var to = env.hooks.getValue(hash.to) || 'default';
      var block = env.hooks.getBlock(scope, to);

      if (block) {
        block.invoke(env, params, hash.self, morph, scope, visitor);
      }
      return true;
    },

    hasBlock: function (morph, env, scope, params) {
      var name = env.hooks.getValue(params[0]) || 'default';
      return !!env.hooks.getBlock(scope, name);
    },

    hasBlockParams: function (morph, env, scope, params) {
      var name = env.hooks.getValue(params[0]) || 'default';
      var block = env.hooks.getBlock(scope, name);
      return !!(block && block.arity);
    }

  };

  exports.keywords = keywords;
  /**
    Host Hook: partial

    @param {RenderNode} renderNode
    @param {Environment} env
    @param {Scope} scope
    @param {String} path

    Corresponds to:

    ```hbs
    {{partial "location"}}
    ```

    This host hook is invoked by the default implementation of
    the `inline` hook. This makes `partial` a keyword in an
    HTMLBars environment using the default `inline` host hook.

    It is implemented as a host hook so that it can retrieve
    the named partial out of the `Environment`. Helpers, in
    contrast, only have access to the values passed in to them,
    and not to the ambient lexical environment.

    The host hook should invoke the referenced partial with
    the ambient `self`.
  */

  function partial(renderNode, env, scope, path) {
    var template = env.partials[path];
    return template.render(scope.self, env, {}).fragment;
  }

  /**
    Host hook: range

    @param {RenderNode} renderNode
    @param {Environment} env
    @param {Scope} scope
    @param {any} value

    Corresponds to:

    ```hbs
    {{content}}
    {{{unescaped}}}
    ```

    This hook is responsible for updating a render node
    that represents a range of content with a value.
  */

  function range(morph, env, scope, path, value, visitor) {
    if (handleRedirect(morph, env, scope, path, [], {}, null, null, visitor)) {
      return;
    }

    value = env.hooks.getValue(value);

    if (morph.lastValue !== value) {
      morph.setContent(value);
    }

    morph.lastValue = value;
  }

  /**
    Host hook: element

    @param {RenderNode} renderNode
    @param {Environment} env
    @param {Scope} scope
    @param {String} path
    @param {Array} params
    @param {Hash} hash

    Corresponds to:

    ```hbs
    <div {{bind-attr foo=bar}}></div>
    ```

    This hook is responsible for invoking a helper that
    modifies an element.

    Its purpose is largely legacy support for awkward
    idioms that became common when using the string-based
    Handlebars engine.

    Most of the uses of the `element` hook are expected
    to be superseded by component syntax and the
    `attribute` hook.
  */

  function element(morph, env, scope, path, params, hash, visitor) {
    if (handleRedirect(morph, env, scope, path, params, hash, null, null, visitor)) {
      return;
    }

    var helper = env.hooks.lookupHelper(env, scope, path);
    if (helper) {
      env.hooks.invokeHelper(null, env, scope, null, params, hash, helper, { element: morph.element });
    }
  }

  /**
    Host hook: attribute

    @param {RenderNode} renderNode
    @param {Environment} env
    @param {String} name
    @param {any} value

    Corresponds to:

    ```hbs
    <div foo={{bar}}></div>
    ```

    This hook is responsible for updating a render node
    that represents an element's attribute with a value.

    It receives the name of the attribute as well as an
    already-resolved value, and should update the render
    node with the value if appropriate.
  */

  function attribute(morph, env, scope, name, value) {
    value = env.hooks.getValue(value);

    if (morph.lastValue !== value) {
      morph.setContent(value);
    }

    morph.lastValue = value;
  }

  function subexpr(env, scope, helperName, params, hash) {
    var helper = env.hooks.lookupHelper(env, scope, helperName);
    var result = env.hooks.invokeHelper(null, env, scope, null, params, hash, helper, {});
    if (result && 'value' in result) {
      return env.hooks.getValue(result.value);
    }
  }

  /**
    Host Hook: get

    @param {Environment} env
    @param {Scope} scope
    @param {String} path

    Corresponds to:

    ```hbs
    {{foo.bar}}
      ^

    {{helper foo.bar key=value}}
             ^           ^
    ```

    This hook is the "leaf" hook of the system. It is used to
    resolve a path relative to the current scope.
  */

  function get(env, scope, path) {
    if (path === '') {
      return scope.self;
    }

    var keys = path.split('.');
    var value = env.hooks.getRoot(scope, keys[0])[0];

    for (var i = 1; i < keys.length; i++) {
      if (value) {
        value = env.hooks.getChild(value, keys[i]);
      } else {
        break;
      }
    }

    return value;
  }

  function getRoot(scope, key) {
    if (scope.localPresent[key]) {
      return [scope.locals[key]];
    } else if (scope.self) {
      return [scope.self[key]];
    } else {
      return [undefined];
    }
  }

  function getBlock(scope, key) {
    return scope.blocks[key];
  }

  function getChild(value, key) {
    return value[key];
  }

  function getValue(reference) {
    return reference;
  }

  function getCellOrValue(reference) {
    return reference;
  }

  function component(morph, env, scope, tagName, params, attrs, templates, visitor) {
    if (env.hooks.hasHelper(env, scope, tagName)) {
      return env.hooks.block(morph, env, scope, tagName, params, attrs, templates.default, templates.inverse, visitor);
    }

    componentFallback(morph, env, scope, tagName, attrs, templates.default);
  }

  function concat(env, params) {
    var value = "";
    for (var i = 0, l = params.length; i < l; i++) {
      value += env.hooks.getValue(params[i]);
    }
    return value;
  }

  function componentFallback(morph, env, scope, tagName, attrs, template) {
    var element = env.dom.createElement(tagName);
    for (var name in attrs) {
      element.setAttribute(name, env.hooks.getValue(attrs[name]));
    }
    var fragment = _render2.default(template, env, scope, {}).fragment;
    element.appendChild(fragment);
    morph.setNode(element);
  }

  function hasHelper(env, scope, helperName) {
    return env.helpers[helperName] !== undefined;
  }

  function lookupHelper(env, scope, helperName) {
    return env.helpers[helperName];
  }

  function bindScope() /* env, scope */{
    // this function is used to handle host-specified extensions to scope
    // other than `self`, `locals` and `block`.
  }

  function updateScope(env, scope) {
    env.hooks.bindScope(env, scope);
  }

  exports.default = {
    // fundamental hooks that you will likely want to override
    bindLocal: bindLocal,
    bindSelf: bindSelf,
    bindScope: bindScope,
    classify: classify,
    component: component,
    concat: concat,
    createFreshScope: createFreshScope,
    getChild: getChild,
    getRoot: getRoot,
    getBlock: getBlock,
    getValue: getValue,
    getCellOrValue: getCellOrValue,
    keywords: keywords,
    linkRenderNode: linkRenderNode,
    partial: partial,
    subexpr: subexpr,

    // fundamental hooks with good default behavior
    bindBlock: bindBlock,
    bindShadowScope: bindShadowScope,
    updateLocal: updateLocal,
    updateSelf: updateSelf,
    updateScope: updateScope,
    createChildScope: createChildScope,
    hasHelper: hasHelper,
    lookupHelper: lookupHelper,
    invokeHelper: invokeHelper,
    cleanupRenderNode: null,
    destroyRenderNode: null,
    willCleanupTree: null,
    didCleanupTree: null,
    willRenderNode: null,
    didRenderNode: null,

    // derived hooks
    attribute: attribute,
    block: block,
    createScope: createScope,
    element: element,
    get: get,
    inline: inline,
    range: range,
    keyword: keyword
  };

  });

  var Hooks = unwrapExports(hooks);
  var hooks_1 = hooks.wrap;
  var hooks_2 = hooks.wrapForHelper;
  var hooks_3 = hooks.createScope;
  var hooks_4 = hooks.createFreshScope;
  var hooks_5 = hooks.bindShadowScope;
  var hooks_6 = hooks.createChildScope;
  var hooks_7 = hooks.bindSelf;
  var hooks_8 = hooks.updateSelf;
  var hooks_9 = hooks.bindLocal;
  var hooks_10 = hooks.updateLocal;
  var hooks_11 = hooks.bindBlock;
  var hooks_12 = hooks.block;
  var hooks_13 = hooks.continueBlock;
  var hooks_14 = hooks.hostBlock;
  var hooks_15 = hooks.handleRedirect;
  var hooks_16 = hooks.handleKeyword;
  var hooks_17 = hooks.linkRenderNode;
  var hooks_18 = hooks.inline;
  var hooks_19 = hooks.keyword;
  var hooks_20 = hooks.invokeHelper;
  var hooks_21 = hooks.classify;
  var hooks_22 = hooks.partial;
  var hooks_23 = hooks.range;
  var hooks_24 = hooks.element;
  var hooks_25 = hooks.attribute;
  var hooks_26 = hooks.subexpr;
  var hooks_27 = hooks.get;
  var hooks_28 = hooks.getRoot;
  var hooks_29 = hooks.getBlock;
  var hooks_30 = hooks.getChild;
  var hooks_31 = hooks.getValue;
  var hooks_32 = hooks.getCellOrValue;
  var hooks_33 = hooks.component;
  var hooks_34 = hooks.concat;
  var hooks_35 = hooks.hasHelper;
  var hooks_36 = hooks.lookupHelper;
  var hooks_37 = hooks.bindScope;
  var hooks_38 = hooks.updateScope;
  var hooks_39 = hooks.keywords;

  /**
   * @module Core
   */

  var ObservableArray =
  /*#__PURE__*/
  function (_Obj) {
    _inherits(ObservableArray, _Obj);

    /**
     * An ObservableArray is a simple list that notifies listeners
     * of any changes in the list or any of it's observable items.
     *
     * @class Core.ObservableArray
     *
     * @constructor
     * @param  {Array}  [initValues=[]]        			 An array of values to initialize the object with
     * @param  {Boolean} [convertToObservables=true]	 Whether to convert any Object and Array values in the `initValues` parameter into Observable and ObservableArray instance
     */
    function ObservableArray() {
      var _this;

      var initValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var convertToObservables = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      _classCallCheck(this, ObservableArray);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ObservableArray).call(this)); // Properties

      _this.items = []; // Single initvalue given

      if (!(initValues instanceof Array)) initValues = [initValues]; // Import start values

      _this.import(initValues, convertToObservables, true);
      /**
       * Whenever this property is true, no notifications will be triggered
       * 
       * @attribute notificationsDisabled
       * @type {Boolean}
       */


      _this.notificationsDisabled = false;
      _this.isStudyingChildren = false;
      _this.allowStudyChildren = true;

      _this.childStudyCallback = function () {
        // Trigger on.
        _this._scheduleChanged();
      };

      return _this;
    }

    _createClass(ObservableArray, [{
      key: "import",
      value: function _import(arr) {
        var _this2 = this;

        var convertToObservables = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        // Go through to the object's first level
        underscore.each(arr, function (value) {
          // Is the value an array or object?
          if ((Array.isArray(value) || _typeof(value) === 'object') && convertToObservables === true) {
            // Array or object?
            if (Array.isArray(value)) {
              // Put a new observable array in there
              _this2.items.push(new ObservableArray(value));
            } else {
              // Put a new observable in there
              _this2.items.push(ClassMap.create('Observable', [value]));
            }
          } else {
            // Just add the value (don't notify)
            _this2.items.push(value);
          }
        }); // Trigger changes


        if (!this.notificationsDisabled) {
          this.trigger(ObservableArray.Events.Import);
          this.trigger(ObservableArray.Events.Change);
          this.trigger(ObservableArray.Events.Add, arr);
        }

        return this;
      }
    }, {
      key: "get",
      value: function get(key) {
        // Split
        var parts = Number.isInteger(key) ? [key] : key.split(/\./);
        var currentPart = parts.shift(); // Is it a wildcard?

        var value = undefined;

        if (currentPart === '*') {
          // We will return an array containg all the values we retrieve!
          var restKey = parts.join('.');
          return underscore.map(this.items, function (item) {
            return item.get(restKey);
          });
        } else if (Number.isInteger(currentPart) || currentPart.match(/^\d+$/)) {
          // Get the value
          value = this.items[currentPart];
        } else {
          throw new TypeError('Invalid key: ' + key);
        } // Value found?


        if (value === undefined || parts.length === 0) {
          return value;
        } // Check if the value is also an observable


        if (ObservableArray.isObservable(value)) {
          // Pass the rest along to go a level deeper
          return value.get(parts.join('.'));
        } else {
          throw new Error('The found value for ' + key + ' is not an Observable and cannot be used with dot-notation to retreive subvalues. Value is ' + _typeof(value));
        }
      }
    }, {
      key: "set",
      value: function set(key, value) {
        var _this3 = this;

        var convertToObservables = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        // Convert?
        if (convertToObservables === true && _typeof(value) === 'object' && value.constructor === Object) {
          value = ClassMap.create('Observable', value);
        } // Numeric?


        if (Number.isInteger(key) || typeof key === 'string' && key.match(/^\d+$/)) {
          // Set it
          this.items[key] = value;
          return this;
        } // Is there a dot in there?


        if (typeof key === 'string' && key.match(/\.\w/)) {
          ////////////////////////
          // Split and deep set //
          ////////////////////////
          var parts = key.split(/\./);
          var currentPart = parts.shift(); // Does the first key exist?

          var item = this.items[currentPart];

          if (item === undefined) {
            // Should it be an array or an observable?
            var newValue;

            if (Number.isInteger(parts[0]) || typeof parts[0] === 'string' && parts[0].match(/^\d+$/)) {
              // Create list (using classmap to prevent circular dependencies)
              newValue = new ObservableArray();
            } else {
              // Create it
              newValue = ClassMap.create('Observable');
            } // Study it


            if (this.isStudyingChildren) {
              newValue.study(function () {
                _this3.trigger(ObservableArray.Events.Change);
              });
            } // Store it


            this.items[currentPart] = newValue;
          } // Do deep setting


          this.get(currentPart).set(parts.join('.'), value);
          return this;
        }

        throw new TypeError('Invalid key');
      }
      /**
       * Add one or more items to the array
       *
       * @method add
       * @param {...[mixed]} values One or more values to add
       * @chainable
       */

    }, {
      key: "add",
      value: function add() {
        var _this4 = this;

        // Is the last value a boolean?
        var doNotNotify = false;

        for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
          values[_key] = arguments[_key];
        }

        if (values.length > 1 && typeof values[values.length - 1] === 'boolean') {
          doNotNotify = values.pop();
        } // Add items


        underscore.each(values, function (value) {
          _this4._add(value);
        }); // Trigger events


        if (!doNotNotify) {
          this.trigger(ObservableArray.Events.Change);
          this.trigger(ObservableArray.Events.Add, values);
        }

        return this;
      }
    }, {
      key: "_add",
      value: function _add(value) {
        var _this5 = this;

        // Add it.
        this.items.push(value); // Studying?

        if (this.isStudyingChildren && this.allowStudyChildren) {
          if (ObservableArray.isObservable(value)) value.study(this.childStudyCallback);
        } // Is it observable?


        if (ObservableArray.isObservable(value)) {
          value.on('change', function () {
            _this5.trigger('change');
          });
        }

        return this;
      }
      /**
       * Delete one or more items from the array
       *
       * @method delete
       * @param  {...[mixed]} values One or more values to delete
       * @chainable
       */

    }, {
      key: "delete",
      value: function _delete() {
        var _this6 = this;

        // Is the last value a boolean?
        var doNotNotify = false;

        for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          values[_key2] = arguments[_key2];
        }

        if (values.length > 1 && typeof values[values.length - 1] === 'boolean') {
          doNotNotify = values.pop();
        } // Add items


        underscore.each(values, function (value) {
          _this6._delete(value);
        }); // Studying?


        if (this.isStudyingChildren) {
          underscore.each(values, function (item) {
            if (ObservableArray.isObservable(item)) item.neglect(_this6.childStudyCallback);
          });
        } // Trigger events


        if (!doNotNotify) {
          this.trigger(ObservableArray.Events.Change);
          this.trigger(ObservableArray.Events.Delete, values);
        }

        return this;
      }
    }, {
      key: "_delete",
      value: function _delete(value) {
        this.items = underscore.without(this.items, value);
      }
      /**
       * Remove all items from the array
       *
       * @method empty
       * @chainable
       */

    }, {
      key: "empty",
      value: function empty() {
        var _this7 = this;

        // Values that are deleted
        var deleted = underscore.difference(this.items, []); // Remove all listeners


        if (this.isStudyingChildren) {
          underscore.each(this.items, function (item) {
            item.neglect(_this7.childStudyCallback);
          });
        } // Now clear


        this.items = []; // Trigger events

        this.trigger(ObservableArray.Events.Change);
        this.trigger(ObservableArray.Events.Delete, deleted);
        this.trigger(ObservableArray.Events.Empty);
        return this;
      }
      /**
       * Get the first item in the collection
       * 
       * @method first
       * @return {mixed} 
       */

    }, {
      key: "first",
      value: function first() {
        return underscore.first(this.items);
      }
      /**
       * Get the last item in the collection
       *
       * @method last
       * @return {mixed} 
       */

    }, {
      key: "last",
      value: function last() {
        return underscore.last(this.items);
      }
      /**
       * Listen for any changes in any of the object's attributes. 
       * The callback will receive an array containing the names of
       * all updates attributes. 
       *
       * Note: This is an alias of the 'changed' event, so calling
       * ```this.on('changed', callback)``` will achieve the same result.
       *
       * @example
       * 	// Initialize object
       * 	var obj = new Chicken.Core.Observable();
       * 	obj.set('foo', 'bar');
       * 	var childObj = new Chicken.Core.Observable();
       * 	childObj.set('free', 'willy');
       * 	obj.set('child', childObj);
       *
       * 	// Listen
       * 	obj.study((changedAttributes) {
       * 		console.log(changedAttributes);
       * 	});
       *
       * 	// Update attributes
       *	obj.set('foo', 'boo');                  // Will log ['foo']
       *	obj.get('child').set('free', 'tibet');  // Will log ['child']
       * 	childObj.set('foo', 'bee');             // Will log ['child']
       *
       * @method study
       * @param  {Function} callback
       * @chainable
       */

    }, {
      key: "study",
      value: function study(callback) {
        var _this8 = this;

        // Already studying?
        if (!this.isStudyingChildren && this.allowStudyChildren) {
          // Set
          this.isStudyingChildren = true; // Watch all current children

          underscore.each(this.items, function (item) {
            if (ObservableArray.isObservable(item)) item.study(_this8.childStudyCallback);
          });
        } // Connect to change-event


        return this.on('change', callback);
      }
      /**
       * Stop listening for changes on the object's attributes.
       *
       * Note: This is an alias of the 'changed' event, so calling
       * ```this.off('changed', callback)``` will achieve the same result.
       *
       * @example
       * 
       * 
       * @method neglect
       * @param  {Function} callback 
       * @chainable
       */

    }, {
      key: "neglect",
      value: function neglect(callback) {
        // This is an alias of the 'changed' event
        return this.off('change', callback);
      }
    }, {
      key: "toArray",
      value: function toArray() {
        var includedUids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        return this.items.map(function (item) {
          // Observable?
          if (ObservableArray.isObservable(item)) {
            // Already included?
            var guid = ClassMap.get('Utils').uidFor(item);

            if (underscore.indexOf(includedUids, guid) !== -1) {
              return '...recursive(' + guid + ')...';
            }

            includedUids.push(guid); // Array?

            if (item instanceof ObservableArray) {
              return item.toArray(includedUids);
            } else {
              return item.toObject(includedUids);
            }
          }

          return item;
        });
      }
      /**
       * Get a keyed array containing all items in this ObservableArray
       * by the value of given key.
       *
       * @method keyBy
       * @param  {string} key 	The attribute key. You can also use dot-notation in this key.
       * @return {Object}     
       */

    }, {
      key: "keyBy",
      value: function keyBy(key) {
        // Loop it.
        var result = {};

        underscore.each(this.items, function (item) {
          var keyValue = item.get(key);
          if (keyValue) result[keyValue] = item;
        });

        return result;
      }
    }, {
      key: "sortBy",
      value: function sortBy(keyOrCallback) {
        // Is it a key?
        var callback = keyOrCallback;

        if (typeof keyOrCallback === 'string') {
          callback = function callback(item) {
            return item.get(keyOrCallback);
          };
        } // Now sort!


        this.items = underscore.sortBy(this.items, callback);
        return this;
      }
    }, {
      key: "reverse",
      value: function reverse() {
        this.items.reverse();
        return this;
      }
      /**
       * Get a keyed array containing ObservableArray's with values that have the same
       * value for given key.
       *
       * @method groupBy
       * @param  {string} keyOrCallback  The attribute key. You can also use dot-notation in this key.
       * @param  {string} [defaultGroup=default] The key under which to put items that have no value for given key
       * @param  {boolean} [makeObservable=false] 
       * @return {Object}
       */

    }, {
      key: "groupBy",
      value: function groupBy(keyOrCallback) {
        var defaultGroup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
        var makeObservable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        // Get called class
        var MyClass = this.constructor; // Loop it

        var result = makeObservable ? ClassMap.create('Observable', []) : {};

        underscore.each(this.items, function (item) {
          // Get value
          var keyValue = typeof keyOrCallback === 'function' ? keyOrCallback(item) : item.get(keyOrCallback); // Nothing?

          if (!keyValue) keyValue = defaultGroup; // Map?

          if (makeObservable) {
            // Group known?
            if (!result.get(keyValue)) result.set(keyValue, new MyClass()); // Add it

            result.get(keyValue).add(item);
          } else {
            // Group known?
            if (!result[keyValue]) result[keyValue] = new MyClass(); // Add it

            result[keyValue].add(item);
          }
        });

        return result;
      }
      /**
       * Get value for given valueAttribute key from all items
       * 
       *
       * @method list 
       * @param  {string} valueAttribute 
       * @param  {string} keyAttribute   
       * @return {[type]}                [description]
       */

    }, {
      key: "list",
      value: function list(valueAttribute) {
        var keyAttribute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var result = keyAttribute ? {} : [];

        underscore.each(this.items, function (item) {
          if (keyAttribute) {
            result[item.get(keyAttribute)] = item.get(valueAttribute);
          } else {
            result.push(item.get(valueAttribute));
          }
        });

        return result;
      }
      /**
       * Get the lowest value for objects in this array
       *
       * @method getLowestValue
       * @param  {string}  key          
       * @return {mixed}
       */

    }, {
      key: "getLowestValue",
      value: function getLowestValue(key) {
        // Get a list.
        var list = this.list(key);
        return underscore.min(list);
      }
    }, {
      key: "each",
      value: function each(callback) {
        underscore.each(this.items, callback);

        return this;
      }
    }, {
      key: "reverseEach",
      value: function reverseEach(callback) {
        for (var q = this.items.length - 1; q >= 0; q--) {
          callback.apply(null, [this.items[q]]);
        }

        return this;
      }
    }, {
      key: "find",
      value: function find(idOrAttributeOrCallback) {
        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        // Callback?
        if (typeof idOrAttributeOrCallback === 'function') {
          return underscore.find(this.items, idOrAttributeOrCallback);
        }

        var attribute = 'id';

        if (value === undefined) {
          value = idOrAttributeOrCallback;
        } else {
          attribute = idOrAttributeOrCallback;
        }

        return underscore.find(this.items, function (item) {
          if (ClassMap.isA(item, 'Observable') || item instanceof ObservableArray) {
            return item.get(attribute) == value;
          } else if (item instanceof Object) {
            return item[attribute] == value;
          } else {
            return item == value;
          }
        });
      }
      /**
       * find object with empty attribute 
       *
       * @method findEmpty
       * @param  {string}	attribute 	the attribute checked for definition
       * @return {mixed}				the object containing the empty property or `undefined`
       */

    }, {
      key: "findEmpty",
      value: function findEmpty(attribute) {
        return underscore.find(this.items, function (item) {
          if (ClassMap.isA(item, 'Observable') || item instanceof ObservableArray) {
            return !item.get(attribute);
          } else if (item instanceof Object) {
            return !item[attribute];
          } else {
            return false;
          }
        });
      }
    }, {
      key: "contains",
      value: function contains(item) {
        return underscore.contains(this.items, item);
      }
    }, {
      key: "sum",
      value: function sum(callback) {
        if (typeof callback === 'string') {
          var key = callback;

          callback = function callback(i) {
            return i.get(key);
          };
        }

        var values = underscore.map(this.items, callback);

        return underscore.reduce(values, function (memo, num) {
          return memo + num;
        }, 0);
      }
    }, {
      key: "map",
      value: function map(callback) {
        return underscore.map(this.items, callback);
      }
    }, {
      key: "extend",
      value: function extend(observableArray) {
        return underscore.extend(this.items, observableArray.items);
      }
    }, {
      key: "filter",
      value: function filter() {
        // Parse arguments
        if (arguments.length === 0) throw new Error('The filter method requires at least one argument.');
        var callback;
        var returnObservableArray = true;

        if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'function') {
          // Use given callback method
          callback = arguments.length <= 0 ? undefined : arguments[0];
          if (arguments.length > 1) returnObservableArray = arguments.length <= 1 ? undefined : arguments[1];
        } else if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
          // Create callback
          var key = arguments.length <= 0 ? undefined : arguments[0];
          var value = arguments.length <= 1 ? undefined : arguments[1];

          callback = function callback(item) {
            return item.get(key) == value;
          };

          if (arguments.length > 2) returnObservableArray = arguments.length <= 2 ? undefined : arguments[2];
        } // Do the filter


        var result = underscore.filter(this.items, callback);

        return returnObservableArray ? new ObservableArray(result, false) : result;
      }
    }, {
      key: "chunk",
      value: function chunk() {
        var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 20;
        // Loop and add
        var cls = this.constructor;
        var chunks = new ObservableArray();
        var chunk = new cls();

        for (var i = 0; i < this.items.length; i++) {
          // New chunk?
          if (i > 0 && i % size === 0) {
            // New chunk
            chunks.add(chunk);
            chunk = new cls();
          } // Add it


          chunk.add(this.items[i]);
        }

        chunks.add(chunk);
        return chunks;
      }
      /**
       * The number of items in the array
       * 
       * @property length
       * @type {Number}
       */

    }, {
      key: "count",
      value: function count() {
        var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (callback) {
          // Count only those
          var c = 0;

          underscore.each(this.items, function (item) {
            if (callback(item) === true) c++;
          });

          return c;
        }

        return this.length;
      }
    }, {
      key: "size",
      value: function size() {
        return this.length;
      }
    }, {
      key: "isObservable",
      value: function isObservable() {
        return true;
      }
    }, {
      key: "_scheduleChanged",
      value: function _scheduleChanged() {
        var _this9 = this;

        // Notifications disabled?
        if (this.notificationsDisabled) return; // Already something scheduled?

        if (!this._scheduleChangedTimeout) {
          // Schedule it
          this._scheduleChangedTimeout = setTimeout(function () {
            // Trigger it now!
            _this9._scheduleChangedTimeout = false;

            _this9._triggerChanged();
          }, ObservableArray.ChangedDelay);
        }
      }
    }, {
      key: "_triggerChanged",
      value: function _triggerChanged() {
        this.trigger(ObservableArray.Events.Change);
      }
    }, {
      key: "length",
      get: function get() {
        return this.items.length;
      }
    }]);

    return ObservableArray;
  }(Obj); ////////////
  // Events //
  ////////////


  ObservableArray.Events = {
    /**
     * This event is fired whenever anything changes in the array
     * of one of its observable items.
     * 
     * @event change
     */
    Change: 'change',

    /**
     * This event is fired whenever one or more items are added
     * 
     * @event add
     * @param {Array} values		The item values that were added
     */
    Add: 'add',

    /**
     * This event is fired whenever one or more items are deleted
     * 
     * @event delete
     * @param {Array} values		The item values that were deleted
     */
    Delete: 'delete',

    /**
     * This event is fired when the array is emptied. Not that the `delete`
     * event is also triggered, right before the `empty` event.
     *
     * @event empty
     */
    Empty: 'empty',

    /**
     * This event is fired whenever an import is completed
     *
     * @event import
     */
    Import: 'import'
  };

  ObservableArray.isObservable = function (obj) {
    return _typeof(obj) === 'object' && obj !== null && typeof obj.isObservable === 'function' && obj.isObservable() === true;
  };

  ObservableArray.ChangedDelay = 100;
  ClassMap.register('ObservableArray', ObservableArray);

  /**
   * @module Dom
   */

  var Binding =
  /*#__PURE__*/
  function () {
    /**
     * @class Dom.Binding
     * 
     * @constructor
     * @param  {Dom.Renderer} 							renderer   
     * @param  {Core.Observable|Core.ObservableArray} 	observable 
     * @param  {string} 								path       	
     */
    function Binding(renderer, observable, path) {
      var _this = this;

      _classCallCheck(this, Binding);

      /**
       * The Renderer this Binding has been created by. This is 
       * used to be able to hook back into Rendere functions.
       *
       * @property renderer
       * @type {Dom.Renderer}
       */
      this.renderer = renderer;
      /**
       * The Observable (or ObservableArray) that contains the data.
       * 
       * @property observable
       * @type {Core.Observable|Core.ObservableArray}
       */

      this.observable = observable;
      /**
       * The path/key in the Observable to observe
       *
       * @property path
       * @type {string}
       */

      this.path = typeof path === 'string' && path.length > 0 ? path : false;
      /**
       * The list of 'morph' objects that are bound by this Binding. A
       * morph refers to a specific part of the DocumentFragment that can be
       * updated. These morphs are provides by the HTMLBars package.
       * 
       * @property morphs
       * @type {Set} 
       */

      this.morphs = new Set(); ////////////////
      // Now watch! //
      ////////////////
      // What to do when value changes

      this.changeCallback = function () {
        // Trigger updates for all morphs
        _this.morphs.forEach(function (morph) {
          morph.isDirty = true;
          if (morph.view) morph.view.scheduleRevalidate();
          if (morph.component) morph.component.scheduleRevalidate();
        });
      }; // Now listen to the object


      if (this.path) {
        try {
          this.observable.observe(path, this.changeCallback);
        } catch (ex) {//...
        }
      } else {
        this.observable.study(this.changeCallback);
      }
    }
    /**
     * Get the current value of the data object
     *
     * @method getValue
     * @return {mixed}
     */


    _createClass(Binding, [{
      key: "getValue",
      value: function getValue() {
        // Get a path value
        if (this.path) {
          return this.observable.get(this.path);
        } // Then return the whole thing


        return this.observable;
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        var morph = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        if (morph) {
          // Make sure the morph is not updated itself by this value setting
          morph.lastValue = value;
        }

        return this.observable.set(this.path, value);
      }
    }, {
      key: "getReference",
      value: function getReference() {
        if (!this.reference) {
          this.reference = new Reference(this.observable, this.path);
        }

        return this.reference;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        // Unlisten the object
        if (this.path) {
          this.observable.disregard(this.path, this.changeCallback);
        } else {
          this.observable.neglect(this.changeCallback);
        }
      }
      /**
       * Add a morph object to the list of morphs, so that it will
       * be updated when the data changes. And in cases when applicable,
       * vice-versa.
       *
       * @method addMorph
       * @param {HTMLBarsMorph} morph 
       * @param {object} scope
       */

    }, {
      key: "addMorph",
      value: function addMorph(morph, scope) {
        // Is this an already bound morph?
        if (this.morphs.has(morph)) return; //////////////////////////////////////////
        // Add the morph, for data->dom binding //
        //////////////////////////////////////////

        this.morphs.add(morph); // Save the component and view

        morph.view = scope.view || scope.self;
        if (scope.component) morph.component = scope.component; ///////////////////////////////////////////
        // Check node type for dom->data binding //
        ///////////////////////////////////////////

        for (var key in Binding.TwoWay) {
          // Check if it applies
          var twoWay = Binding.TwoWay[key];

          if (twoWay.match(morph)) {
            // Let's bind!
            twoWay.bind(this, morph);
            break;
          }
        }
      }
    }]);

    return Binding;
  }();

  Binding.TwoWay = {
    InputValue: {
      match: function match(morph) {
        return morph.element && /^INPUT$/.test(morph.element.tagName) && morph.attrName === 'value' && /^text|search|date|time|password|number|range|email$/.test(morph.element.type);
      },
      bind: function bind(binding, morph) {
        // Listen to key up, etc
        var $element = jquery(morph.element);
        var lastValue = $element.val();
        $element.on('input keyup change paste', function () {
          var v = $element.val();

          if (v !== lastValue) {
            binding.setValue(v, morph);
            lastValue = v;
          }
        });
      }
    },
    TextareaContent: {
      match: function match(morph) {
        return morph.contextualElement && /^TEXTAREA$/.test(morph.contextualElement.tagName) && morph.attributeName === undefined;
      },
      bind: function bind(binding, morph) {
        // Listen to key up, etc
        var $element = jquery(morph.contextualElement);
        $element.on('keyup change paste', function () {
          binding.setValue($element.val(), morph);
        });
      }
    },
    SelectValue: {
      match: function match(morph) {
        return morph.element && /^SELECT$/.test(morph.element.tagName) && morph.attrName === 'value';
      },
      bind: function bind(binding, morph) {
        // Listen to change
        var $element = jquery(morph.element);
        $element.on('change', function () {
          binding.setValue($element.val(), morph);
        });
      }
    },
    CheckboxChecked: {
      match: function match(morph) {
        return morph.element && /^INPUT$/.test(morph.element.tagName) && morph.attrName === 'checked' && /^checkbox$/.test(morph.element.type);
      },
      bind: function bind(binding, morph) {
        // Listen to key up, etc
        var $element = jquery(morph.element);
        $element.on('change', function () {
          binding.setValue($element.prop('checked'), morph);
        });
      }
    }
  };

  var validator = new RegExp("^[a-z0-9]{32}$", "i");

  function gen(count) {
    var out = "";
    for (var i=0; i<count; i++) {
      out += (((1+Math.random())*0x10000)|0).toString(16).substring(1);
    }
    return out;
  }

  function Uuid(uuid) {
    if (!uuid) throw new TypeError("Invalid argument; `value` has no value.");
      
    var value = Uuid.EMPTY;
    
    if (uuid && uuid instanceof Uuid) {
      value = Uuid.toString();

    } else if (uuid && Object.prototype.toString.call(uuid) === "[object String]" && Uuid.isUuid(uuid)) {
      value = uuid;
    }
    
    this.equals = function(other) {
      // Comparing string `value` against provided `uuid` will auto-call
      // toString on `uuid` for comparison
      return Uuid.isUuid(other) && value == other;
    };

    this.isEmpty = function() {
      return value === Uuid.EMPTY;
    };
    
    this.toString = function() {
      return value;
    };
    
    this.toJSON = function() {
      return value;
    };
    
    Object.defineProperty(this, "value", {
      get: function() { return value; },
      enumerable: true
    });
  }
  Object.defineProperty(Uuid, "EMPTY", {
    value: "00000000000000000000000000000000"
  });

  Uuid.isUuid = function(value) {
    return value && (value instanceof Uuid || validator.test(value.toString()));
  };

  Uuid.create = function() {
    return new Uuid(gen(8));
  };

  Uuid.raw = function() {
    return gen(8);
  };

  var uuidLib = Uuid;

  /**
   * @module Dom
   */

  var ActionBinding =
  /*#__PURE__*/
  function () {
    /**
     * @class Dom.ActionBinding
     * 
     * @constructor
     */
    function ActionBinding(renderer, morph, actionName, actionHandler, parameters, options, view) {
      _classCallCheck(this, ActionBinding);

      /**
       * @property renderer
       * @type {Dom.Renderer}
       */
      this.renderer = renderer;
      /**
       * @property morph
       * @type {HTMLBarsMorph}
       */

      this.morph = morph;
      /**
       * The name of the action on the view
       * 
       * @property actionName
       * @type {string}
       */

      this.actionName = actionName;
      /**
       * The function to call when the action is executed
       * 
       * @property actionHandler
       * @type {function}
       */

      this.actionHandler = actionHandler;
      /**
       * @property options
       * @type {object}
       */

      this.options = underscore.defaults(options, {
        preventDefault: true
      });
      /**
       * The parameters that will be passed along to the action handler.
       * 
       * @property parameters
       * @type {array}
       */

      this.parameters = parameters;
      /**
       * @property view
       * @type {Dom.View}
       */

      this.view = view;
      /**
       * The name of the event that is listened to on the element.
       * When not specifically configured in the binding itself, a default
       * event will be decided on, based on the element tag name. 
       * 
       * @property eventName
       * @type {string}
       */

      this.eventName = options.on ? options.on : ActionBinding.getDefaultEventName(morph.element);
      /**
       * Indicator whether the binding is applied
       * to the element
       * 
       * @property isListening
       * @type {Boolean}
       */

      this.isListening = false;
      /**
       * @property $element
       * @type {jQuery}
       */

      this.$element = null;
      /**
       * The unique identifier for this ActionBinding. This is used
       * by the Helper to retrieve this instance and automatically
       * generated in the constructor.
       * 
       * @property id
       * @type {string}
       */

      this.id = ActionBinding.register(this); // Store this binding on the element

      morph.element.setAttribute('data-chicken-action', this.id);
    }

    _createClass(ActionBinding, [{
      key: "apply",
      value: function apply() {
        var _this = this;

        // Already applied?
        if (this.isListening === true) return this;
        this.isListening = true; // Get element

        this.$element = jquery(this.morph.element);
        this.$element.on(this.eventName, function (e) {
          // Prevent default?
          if (_this.options.preventDefault) e.preventDefault(); // Call the handler

          var params = underscore.flatten([underscore.map(_this.parameters, function (value) {
            return _this.renderer.hooks.getValue(value);
          }), _this, _this.view, e]);

          _this.actionHandler.apply(_this.view, params);
        });
        return this;
      }
    }]);

    return ActionBinding;
  }();

  ActionBinding.registry = new Map();

  ActionBinding.register = function (binding) {
    // Generate id
    var id = uuidLib.raw();
    ActionBinding.registry.set(id, binding);
    return id;
  };

  ActionBinding.get = function (id) {
    return ActionBinding.registry.get(id);
  };

  ActionBinding.getDefaultEventName = function (element) {
    // Specific one for this tag?
    var eventName = ActionBinding.DefaultEventNames[element.tagName.toLowerCase()]; // Or the old click.

    if (!eventName) eventName = 'click';
    return eventName;
  };

  ActionBinding.DefaultEventNames = {
    input: 'change keyup paste',
    select: 'change',
    form: 'submit'
  };

  var parser = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  /* istanbul ignore next */
  /* Jison generated parser */
  var handlebars = (function () {
      var parser = { trace: function trace() {},
          yy: {},
          symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "content": 12, "COMMENT": 13, "CONTENT": 14, "openRawBlock": 15, "END_RAW_BLOCK": 16, "OPEN_RAW_BLOCK": 17, "helperName": 18, "openRawBlock_repetition0": 19, "openRawBlock_option0": 20, "CLOSE_RAW_BLOCK": 21, "openBlock": 22, "block_option0": 23, "closeBlock": 24, "openInverse": 25, "block_option1": 26, "OPEN_BLOCK": 27, "openBlock_repetition0": 28, "openBlock_option0": 29, "openBlock_option1": 30, "CLOSE": 31, "OPEN_INVERSE": 32, "openInverse_repetition0": 33, "openInverse_option0": 34, "openInverse_option1": 35, "openInverseChain": 36, "OPEN_INVERSE_CHAIN": 37, "openInverseChain_repetition0": 38, "openInverseChain_option0": 39, "openInverseChain_option1": 40, "inverseAndProgram": 41, "INVERSE": 42, "inverseChain": 43, "inverseChain_option0": 44, "OPEN_ENDBLOCK": 45, "OPEN": 46, "mustache_repetition0": 47, "mustache_option0": 48, "OPEN_UNESCAPED": 49, "mustache_repetition1": 50, "mustache_option1": 51, "CLOSE_UNESCAPED": 52, "OPEN_PARTIAL": 53, "partialName": 54, "partial_repetition0": 55, "partial_option0": 56, "param": 57, "sexpr": 58, "OPEN_SEXPR": 59, "sexpr_repetition0": 60, "sexpr_option0": 61, "CLOSE_SEXPR": 62, "hash": 63, "hash_repetition_plus0": 64, "hashSegment": 65, "ID": 66, "EQUALS": 67, "blockParams": 68, "OPEN_BLOCK_PARAMS": 69, "blockParams_repetition_plus0": 70, "CLOSE_BLOCK_PARAMS": 71, "path": 72, "dataName": 73, "STRING": 74, "NUMBER": 75, "BOOLEAN": 76, "UNDEFINED": 77, "NULL": 78, "DATA": 79, "pathSegments": 80, "SEP": 81, "$accept": 0, "$end": 1 },
          terminals_: { 2: "error", 5: "EOF", 13: "COMMENT", 14: "CONTENT", 16: "END_RAW_BLOCK", 17: "OPEN_RAW_BLOCK", 21: "CLOSE_RAW_BLOCK", 27: "OPEN_BLOCK", 31: "CLOSE", 32: "OPEN_INVERSE", 37: "OPEN_INVERSE_CHAIN", 42: "INVERSE", 45: "OPEN_ENDBLOCK", 46: "OPEN", 49: "OPEN_UNESCAPED", 52: "CLOSE_UNESCAPED", 53: "OPEN_PARTIAL", 59: "OPEN_SEXPR", 62: "CLOSE_SEXPR", 66: "ID", 67: "EQUALS", 69: "OPEN_BLOCK_PARAMS", 71: "CLOSE_BLOCK_PARAMS", 74: "STRING", 75: "NUMBER", 76: "BOOLEAN", 77: "UNDEFINED", 78: "NULL", 79: "DATA", 81: "SEP" },
          productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [12, 1], [10, 3], [15, 5], [9, 4], [9, 4], [22, 6], [25, 6], [36, 6], [41, 2], [43, 3], [43, 1], [24, 3], [8, 5], [8, 5], [11, 5], [57, 1], [57, 1], [58, 5], [63, 1], [65, 3], [68, 3], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [54, 1], [54, 1], [73, 2], [72, 1], [80, 3], [80, 1], [6, 0], [6, 2], [19, 0], [19, 2], [20, 0], [20, 1], [23, 0], [23, 1], [26, 0], [26, 1], [28, 0], [28, 2], [29, 0], [29, 1], [30, 0], [30, 1], [33, 0], [33, 2], [34, 0], [34, 1], [35, 0], [35, 1], [38, 0], [38, 2], [39, 0], [39, 1], [40, 0], [40, 1], [44, 0], [44, 1], [47, 0], [47, 2], [48, 0], [48, 1], [50, 0], [50, 2], [51, 0], [51, 1], [55, 0], [55, 2], [56, 0], [56, 1], [60, 0], [60, 2], [61, 0], [61, 1], [64, 1], [64, 2], [70, 1], [70, 2]],
          performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {

              var $0 = $$.length - 1;
              switch (yystate) {
                  case 1:
                      return $$[$0 - 1];
                      break;
                  case 2:
                      this.$ = new yy.Program($$[$0], null, {}, yy.locInfo(this._$));
                      break;
                  case 3:
                      this.$ = $$[$0];
                      break;
                  case 4:
                      this.$ = $$[$0];
                      break;
                  case 5:
                      this.$ = $$[$0];
                      break;
                  case 6:
                      this.$ = $$[$0];
                      break;
                  case 7:
                      this.$ = $$[$0];
                      break;
                  case 8:
                      this.$ = new yy.CommentStatement(yy.stripComment($$[$0]), yy.stripFlags($$[$0], $$[$0]), yy.locInfo(this._$));
                      break;
                  case 9:
                      this.$ = new yy.ContentStatement($$[$0], yy.locInfo(this._$));
                      break;
                  case 10:
                      this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                      break;
                  case 11:
                      this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
                      break;
                  case 12:
                      this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
                      break;
                  case 13:
                      this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
                      break;
                  case 14:
                      this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                      break;
                  case 15:
                      this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                      break;
                  case 16:
                      this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                      break;
                  case 17:
                      this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
                      break;
                  case 18:
                      var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
                          program = new yy.Program([inverse], null, {}, yy.locInfo(this._$));
                      program.chained = true;

                      this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };

                      break;
                  case 19:
                      this.$ = $$[$0];
                      break;
                  case 20:
                      this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
                      break;
                  case 21:
                      this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                      break;
                  case 22:
                      this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                      break;
                  case 23:
                      this.$ = new yy.PartialStatement($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], yy.stripFlags($$[$0 - 4], $$[$0]), yy.locInfo(this._$));
                      break;
                  case 24:
                      this.$ = $$[$0];
                      break;
                  case 25:
                      this.$ = $$[$0];
                      break;
                  case 26:
                      this.$ = new yy.SubExpression($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], yy.locInfo(this._$));
                      break;
                  case 27:
                      this.$ = new yy.Hash($$[$0], yy.locInfo(this._$));
                      break;
                  case 28:
                      this.$ = new yy.HashPair(yy.id($$[$0 - 2]), $$[$0], yy.locInfo(this._$));
                      break;
                  case 29:
                      this.$ = yy.id($$[$0 - 1]);
                      break;
                  case 30:
                      this.$ = $$[$0];
                      break;
                  case 31:
                      this.$ = $$[$0];
                      break;
                  case 32:
                      this.$ = new yy.StringLiteral($$[$0], yy.locInfo(this._$));
                      break;
                  case 33:
                      this.$ = new yy.NumberLiteral($$[$0], yy.locInfo(this._$));
                      break;
                  case 34:
                      this.$ = new yy.BooleanLiteral($$[$0], yy.locInfo(this._$));
                      break;
                  case 35:
                      this.$ = new yy.UndefinedLiteral(yy.locInfo(this._$));
                      break;
                  case 36:
                      this.$ = new yy.NullLiteral(yy.locInfo(this._$));
                      break;
                  case 37:
                      this.$ = $$[$0];
                      break;
                  case 38:
                      this.$ = $$[$0];
                      break;
                  case 39:
                      this.$ = yy.preparePath(true, $$[$0], this._$);
                      break;
                  case 40:
                      this.$ = yy.preparePath(false, $$[$0], this._$);
                      break;
                  case 41:
                      $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];
                      break;
                  case 42:
                      this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
                      break;
                  case 43:
                      this.$ = [];
                      break;
                  case 44:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 45:
                      this.$ = [];
                      break;
                  case 46:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 53:
                      this.$ = [];
                      break;
                  case 54:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 59:
                      this.$ = [];
                      break;
                  case 60:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 65:
                      this.$ = [];
                      break;
                  case 66:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 73:
                      this.$ = [];
                      break;
                  case 74:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 77:
                      this.$ = [];
                      break;
                  case 78:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 81:
                      this.$ = [];
                      break;
                  case 82:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 85:
                      this.$ = [];
                      break;
                  case 86:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 89:
                      this.$ = [$$[$0]];
                      break;
                  case 90:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 91:
                      this.$ = [$$[$0]];
                      break;
                  case 92:
                      $$[$0 - 1].push($$[$0]);
                      break;
              }
          },
          table: [{ 3: 1, 4: 2, 5: [2, 43], 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: [1, 11], 14: [1, 18], 15: 16, 17: [1, 21], 22: 14, 25: 15, 27: [1, 19], 32: [1, 20], 37: [2, 2], 42: [2, 2], 45: [2, 2], 46: [1, 12], 49: [1, 13], 53: [1, 17] }, { 1: [2, 1] }, { 5: [2, 44], 13: [2, 44], 14: [2, 44], 17: [2, 44], 27: [2, 44], 32: [2, 44], 37: [2, 44], 42: [2, 44], 45: [2, 44], 46: [2, 44], 49: [2, 44], 53: [2, 44] }, { 5: [2, 3], 13: [2, 3], 14: [2, 3], 17: [2, 3], 27: [2, 3], 32: [2, 3], 37: [2, 3], 42: [2, 3], 45: [2, 3], 46: [2, 3], 49: [2, 3], 53: [2, 3] }, { 5: [2, 4], 13: [2, 4], 14: [2, 4], 17: [2, 4], 27: [2, 4], 32: [2, 4], 37: [2, 4], 42: [2, 4], 45: [2, 4], 46: [2, 4], 49: [2, 4], 53: [2, 4] }, { 5: [2, 5], 13: [2, 5], 14: [2, 5], 17: [2, 5], 27: [2, 5], 32: [2, 5], 37: [2, 5], 42: [2, 5], 45: [2, 5], 46: [2, 5], 49: [2, 5], 53: [2, 5] }, { 5: [2, 6], 13: [2, 6], 14: [2, 6], 17: [2, 6], 27: [2, 6], 32: [2, 6], 37: [2, 6], 42: [2, 6], 45: [2, 6], 46: [2, 6], 49: [2, 6], 53: [2, 6] }, { 5: [2, 7], 13: [2, 7], 14: [2, 7], 17: [2, 7], 27: [2, 7], 32: [2, 7], 37: [2, 7], 42: [2, 7], 45: [2, 7], 46: [2, 7], 49: [2, 7], 53: [2, 7] }, { 5: [2, 8], 13: [2, 8], 14: [2, 8], 17: [2, 8], 27: [2, 8], 32: [2, 8], 37: [2, 8], 42: [2, 8], 45: [2, 8], 46: [2, 8], 49: [2, 8], 53: [2, 8] }, { 18: 22, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 33, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 4: 34, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 37: [2, 43], 42: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 4: 35, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 42: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 12: 36, 14: [1, 18] }, { 18: 38, 54: 37, 58: 39, 59: [1, 40], 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 5: [2, 9], 13: [2, 9], 14: [2, 9], 16: [2, 9], 17: [2, 9], 27: [2, 9], 32: [2, 9], 37: [2, 9], 42: [2, 9], 45: [2, 9], 46: [2, 9], 49: [2, 9], 53: [2, 9] }, { 18: 41, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 42, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 43, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 31: [2, 73], 47: 44, 59: [2, 73], 66: [2, 73], 74: [2, 73], 75: [2, 73], 76: [2, 73], 77: [2, 73], 78: [2, 73], 79: [2, 73] }, { 21: [2, 30], 31: [2, 30], 52: [2, 30], 59: [2, 30], 62: [2, 30], 66: [2, 30], 69: [2, 30], 74: [2, 30], 75: [2, 30], 76: [2, 30], 77: [2, 30], 78: [2, 30], 79: [2, 30] }, { 21: [2, 31], 31: [2, 31], 52: [2, 31], 59: [2, 31], 62: [2, 31], 66: [2, 31], 69: [2, 31], 74: [2, 31], 75: [2, 31], 76: [2, 31], 77: [2, 31], 78: [2, 31], 79: [2, 31] }, { 21: [2, 32], 31: [2, 32], 52: [2, 32], 59: [2, 32], 62: [2, 32], 66: [2, 32], 69: [2, 32], 74: [2, 32], 75: [2, 32], 76: [2, 32], 77: [2, 32], 78: [2, 32], 79: [2, 32] }, { 21: [2, 33], 31: [2, 33], 52: [2, 33], 59: [2, 33], 62: [2, 33], 66: [2, 33], 69: [2, 33], 74: [2, 33], 75: [2, 33], 76: [2, 33], 77: [2, 33], 78: [2, 33], 79: [2, 33] }, { 21: [2, 34], 31: [2, 34], 52: [2, 34], 59: [2, 34], 62: [2, 34], 66: [2, 34], 69: [2, 34], 74: [2, 34], 75: [2, 34], 76: [2, 34], 77: [2, 34], 78: [2, 34], 79: [2, 34] }, { 21: [2, 35], 31: [2, 35], 52: [2, 35], 59: [2, 35], 62: [2, 35], 66: [2, 35], 69: [2, 35], 74: [2, 35], 75: [2, 35], 76: [2, 35], 77: [2, 35], 78: [2, 35], 79: [2, 35] }, { 21: [2, 36], 31: [2, 36], 52: [2, 36], 59: [2, 36], 62: [2, 36], 66: [2, 36], 69: [2, 36], 74: [2, 36], 75: [2, 36], 76: [2, 36], 77: [2, 36], 78: [2, 36], 79: [2, 36] }, { 21: [2, 40], 31: [2, 40], 52: [2, 40], 59: [2, 40], 62: [2, 40], 66: [2, 40], 69: [2, 40], 74: [2, 40], 75: [2, 40], 76: [2, 40], 77: [2, 40], 78: [2, 40], 79: [2, 40], 81: [1, 45] }, { 66: [1, 32], 80: 46 }, { 21: [2, 42], 31: [2, 42], 52: [2, 42], 59: [2, 42], 62: [2, 42], 66: [2, 42], 69: [2, 42], 74: [2, 42], 75: [2, 42], 76: [2, 42], 77: [2, 42], 78: [2, 42], 79: [2, 42], 81: [2, 42] }, { 50: 47, 52: [2, 77], 59: [2, 77], 66: [2, 77], 74: [2, 77], 75: [2, 77], 76: [2, 77], 77: [2, 77], 78: [2, 77], 79: [2, 77] }, { 23: 48, 36: 50, 37: [1, 52], 41: 51, 42: [1, 53], 43: 49, 45: [2, 49] }, { 26: 54, 41: 55, 42: [1, 53], 45: [2, 51] }, { 16: [1, 56] }, { 31: [2, 81], 55: 57, 59: [2, 81], 66: [2, 81], 74: [2, 81], 75: [2, 81], 76: [2, 81], 77: [2, 81], 78: [2, 81], 79: [2, 81] }, { 31: [2, 37], 59: [2, 37], 66: [2, 37], 74: [2, 37], 75: [2, 37], 76: [2, 37], 77: [2, 37], 78: [2, 37], 79: [2, 37] }, { 31: [2, 38], 59: [2, 38], 66: [2, 38], 74: [2, 38], 75: [2, 38], 76: [2, 38], 77: [2, 38], 78: [2, 38], 79: [2, 38] }, { 18: 58, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 28: 59, 31: [2, 53], 59: [2, 53], 66: [2, 53], 69: [2, 53], 74: [2, 53], 75: [2, 53], 76: [2, 53], 77: [2, 53], 78: [2, 53], 79: [2, 53] }, { 31: [2, 59], 33: 60, 59: [2, 59], 66: [2, 59], 69: [2, 59], 74: [2, 59], 75: [2, 59], 76: [2, 59], 77: [2, 59], 78: [2, 59], 79: [2, 59] }, { 19: 61, 21: [2, 45], 59: [2, 45], 66: [2, 45], 74: [2, 45], 75: [2, 45], 76: [2, 45], 77: [2, 45], 78: [2, 45], 79: [2, 45] }, { 18: 65, 31: [2, 75], 48: 62, 57: 63, 58: 66, 59: [1, 40], 63: 64, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 66: [1, 70] }, { 21: [2, 39], 31: [2, 39], 52: [2, 39], 59: [2, 39], 62: [2, 39], 66: [2, 39], 69: [2, 39], 74: [2, 39], 75: [2, 39], 76: [2, 39], 77: [2, 39], 78: [2, 39], 79: [2, 39], 81: [1, 45] }, { 18: 65, 51: 71, 52: [2, 79], 57: 72, 58: 66, 59: [1, 40], 63: 73, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 24: 74, 45: [1, 75] }, { 45: [2, 50] }, { 4: 76, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 37: [2, 43], 42: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 45: [2, 19] }, { 18: 77, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 4: 78, 6: 3, 13: [2, 43], 14: [2, 43], 17: [2, 43], 27: [2, 43], 32: [2, 43], 45: [2, 43], 46: [2, 43], 49: [2, 43], 53: [2, 43] }, { 24: 79, 45: [1, 75] }, { 45: [2, 52] }, { 5: [2, 10], 13: [2, 10], 14: [2, 10], 17: [2, 10], 27: [2, 10], 32: [2, 10], 37: [2, 10], 42: [2, 10], 45: [2, 10], 46: [2, 10], 49: [2, 10], 53: [2, 10] }, { 18: 65, 31: [2, 83], 56: 80, 57: 81, 58: 66, 59: [1, 40], 63: 82, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 59: [2, 85], 60: 83, 62: [2, 85], 66: [2, 85], 74: [2, 85], 75: [2, 85], 76: [2, 85], 77: [2, 85], 78: [2, 85], 79: [2, 85] }, { 18: 65, 29: 84, 31: [2, 55], 57: 85, 58: 66, 59: [1, 40], 63: 86, 64: 67, 65: 68, 66: [1, 69], 69: [2, 55], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 65, 31: [2, 61], 34: 87, 57: 88, 58: 66, 59: [1, 40], 63: 89, 64: 67, 65: 68, 66: [1, 69], 69: [2, 61], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 18: 65, 20: 90, 21: [2, 47], 57: 91, 58: 66, 59: [1, 40], 63: 92, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 31: [1, 93] }, { 31: [2, 74], 59: [2, 74], 66: [2, 74], 74: [2, 74], 75: [2, 74], 76: [2, 74], 77: [2, 74], 78: [2, 74], 79: [2, 74] }, { 31: [2, 76] }, { 21: [2, 24], 31: [2, 24], 52: [2, 24], 59: [2, 24], 62: [2, 24], 66: [2, 24], 69: [2, 24], 74: [2, 24], 75: [2, 24], 76: [2, 24], 77: [2, 24], 78: [2, 24], 79: [2, 24] }, { 21: [2, 25], 31: [2, 25], 52: [2, 25], 59: [2, 25], 62: [2, 25], 66: [2, 25], 69: [2, 25], 74: [2, 25], 75: [2, 25], 76: [2, 25], 77: [2, 25], 78: [2, 25], 79: [2, 25] }, { 21: [2, 27], 31: [2, 27], 52: [2, 27], 62: [2, 27], 65: 94, 66: [1, 95], 69: [2, 27] }, { 21: [2, 89], 31: [2, 89], 52: [2, 89], 62: [2, 89], 66: [2, 89], 69: [2, 89] }, { 21: [2, 42], 31: [2, 42], 52: [2, 42], 59: [2, 42], 62: [2, 42], 66: [2, 42], 67: [1, 96], 69: [2, 42], 74: [2, 42], 75: [2, 42], 76: [2, 42], 77: [2, 42], 78: [2, 42], 79: [2, 42], 81: [2, 42] }, { 21: [2, 41], 31: [2, 41], 52: [2, 41], 59: [2, 41], 62: [2, 41], 66: [2, 41], 69: [2, 41], 74: [2, 41], 75: [2, 41], 76: [2, 41], 77: [2, 41], 78: [2, 41], 79: [2, 41], 81: [2, 41] }, { 52: [1, 97] }, { 52: [2, 78], 59: [2, 78], 66: [2, 78], 74: [2, 78], 75: [2, 78], 76: [2, 78], 77: [2, 78], 78: [2, 78], 79: [2, 78] }, { 52: [2, 80] }, { 5: [2, 12], 13: [2, 12], 14: [2, 12], 17: [2, 12], 27: [2, 12], 32: [2, 12], 37: [2, 12], 42: [2, 12], 45: [2, 12], 46: [2, 12], 49: [2, 12], 53: [2, 12] }, { 18: 98, 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 36: 50, 37: [1, 52], 41: 51, 42: [1, 53], 43: 100, 44: 99, 45: [2, 71] }, { 31: [2, 65], 38: 101, 59: [2, 65], 66: [2, 65], 69: [2, 65], 74: [2, 65], 75: [2, 65], 76: [2, 65], 77: [2, 65], 78: [2, 65], 79: [2, 65] }, { 45: [2, 17] }, { 5: [2, 13], 13: [2, 13], 14: [2, 13], 17: [2, 13], 27: [2, 13], 32: [2, 13], 37: [2, 13], 42: [2, 13], 45: [2, 13], 46: [2, 13], 49: [2, 13], 53: [2, 13] }, { 31: [1, 102] }, { 31: [2, 82], 59: [2, 82], 66: [2, 82], 74: [2, 82], 75: [2, 82], 76: [2, 82], 77: [2, 82], 78: [2, 82], 79: [2, 82] }, { 31: [2, 84] }, { 18: 65, 57: 104, 58: 66, 59: [1, 40], 61: 103, 62: [2, 87], 63: 105, 64: 67, 65: 68, 66: [1, 69], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 30: 106, 31: [2, 57], 68: 107, 69: [1, 108] }, { 31: [2, 54], 59: [2, 54], 66: [2, 54], 69: [2, 54], 74: [2, 54], 75: [2, 54], 76: [2, 54], 77: [2, 54], 78: [2, 54], 79: [2, 54] }, { 31: [2, 56], 69: [2, 56] }, { 31: [2, 63], 35: 109, 68: 110, 69: [1, 108] }, { 31: [2, 60], 59: [2, 60], 66: [2, 60], 69: [2, 60], 74: [2, 60], 75: [2, 60], 76: [2, 60], 77: [2, 60], 78: [2, 60], 79: [2, 60] }, { 31: [2, 62], 69: [2, 62] }, { 21: [1, 111] }, { 21: [2, 46], 59: [2, 46], 66: [2, 46], 74: [2, 46], 75: [2, 46], 76: [2, 46], 77: [2, 46], 78: [2, 46], 79: [2, 46] }, { 21: [2, 48] }, { 5: [2, 21], 13: [2, 21], 14: [2, 21], 17: [2, 21], 27: [2, 21], 32: [2, 21], 37: [2, 21], 42: [2, 21], 45: [2, 21], 46: [2, 21], 49: [2, 21], 53: [2, 21] }, { 21: [2, 90], 31: [2, 90], 52: [2, 90], 62: [2, 90], 66: [2, 90], 69: [2, 90] }, { 67: [1, 96] }, { 18: 65, 57: 112, 58: 66, 59: [1, 40], 66: [1, 32], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 5: [2, 22], 13: [2, 22], 14: [2, 22], 17: [2, 22], 27: [2, 22], 32: [2, 22], 37: [2, 22], 42: [2, 22], 45: [2, 22], 46: [2, 22], 49: [2, 22], 53: [2, 22] }, { 31: [1, 113] }, { 45: [2, 18] }, { 45: [2, 72] }, { 18: 65, 31: [2, 67], 39: 114, 57: 115, 58: 66, 59: [1, 40], 63: 116, 64: 67, 65: 68, 66: [1, 69], 69: [2, 67], 72: 23, 73: 24, 74: [1, 25], 75: [1, 26], 76: [1, 27], 77: [1, 28], 78: [1, 29], 79: [1, 31], 80: 30 }, { 5: [2, 23], 13: [2, 23], 14: [2, 23], 17: [2, 23], 27: [2, 23], 32: [2, 23], 37: [2, 23], 42: [2, 23], 45: [2, 23], 46: [2, 23], 49: [2, 23], 53: [2, 23] }, { 62: [1, 117] }, { 59: [2, 86], 62: [2, 86], 66: [2, 86], 74: [2, 86], 75: [2, 86], 76: [2, 86], 77: [2, 86], 78: [2, 86], 79: [2, 86] }, { 62: [2, 88] }, { 31: [1, 118] }, { 31: [2, 58] }, { 66: [1, 120], 70: 119 }, { 31: [1, 121] }, { 31: [2, 64] }, { 14: [2, 11] }, { 21: [2, 28], 31: [2, 28], 52: [2, 28], 62: [2, 28], 66: [2, 28], 69: [2, 28] }, { 5: [2, 20], 13: [2, 20], 14: [2, 20], 17: [2, 20], 27: [2, 20], 32: [2, 20], 37: [2, 20], 42: [2, 20], 45: [2, 20], 46: [2, 20], 49: [2, 20], 53: [2, 20] }, { 31: [2, 69], 40: 122, 68: 123, 69: [1, 108] }, { 31: [2, 66], 59: [2, 66], 66: [2, 66], 69: [2, 66], 74: [2, 66], 75: [2, 66], 76: [2, 66], 77: [2, 66], 78: [2, 66], 79: [2, 66] }, { 31: [2, 68], 69: [2, 68] }, { 21: [2, 26], 31: [2, 26], 52: [2, 26], 59: [2, 26], 62: [2, 26], 66: [2, 26], 69: [2, 26], 74: [2, 26], 75: [2, 26], 76: [2, 26], 77: [2, 26], 78: [2, 26], 79: [2, 26] }, { 13: [2, 14], 14: [2, 14], 17: [2, 14], 27: [2, 14], 32: [2, 14], 37: [2, 14], 42: [2, 14], 45: [2, 14], 46: [2, 14], 49: [2, 14], 53: [2, 14] }, { 66: [1, 125], 71: [1, 124] }, { 66: [2, 91], 71: [2, 91] }, { 13: [2, 15], 14: [2, 15], 17: [2, 15], 27: [2, 15], 32: [2, 15], 42: [2, 15], 45: [2, 15], 46: [2, 15], 49: [2, 15], 53: [2, 15] }, { 31: [1, 126] }, { 31: [2, 70] }, { 31: [2, 29] }, { 66: [2, 92], 71: [2, 92] }, { 13: [2, 16], 14: [2, 16], 17: [2, 16], 27: [2, 16], 32: [2, 16], 37: [2, 16], 42: [2, 16], 45: [2, 16], 46: [2, 16], 49: [2, 16], 53: [2, 16] }],
          defaultActions: { 4: [2, 1], 49: [2, 50], 51: [2, 19], 55: [2, 52], 64: [2, 76], 73: [2, 80], 78: [2, 17], 82: [2, 84], 92: [2, 48], 99: [2, 18], 100: [2, 72], 105: [2, 88], 107: [2, 58], 110: [2, 64], 111: [2, 11], 123: [2, 70], 124: [2, 29] },
          parseError: function parseError(str, hash) {
              throw new Error(str);
          },
          parse: function parse(input) {
              var self = this,
                  stack = [0],
                  vstack = [null],
                  lstack = [],
                  table = this.table,
                  yytext = "",
                  yylineno = 0,
                  yyleng = 0,
                  recovering = 0;
              this.lexer.setInput(input);
              this.lexer.yy = this.yy;
              this.yy.lexer = this.lexer;
              this.yy.parser = this;
              if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
              var yyloc = this.lexer.yylloc;
              lstack.push(yyloc);
              var ranges = this.lexer.options && this.lexer.options.ranges;
              if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
              function lex() {
                  var token;
                  token = self.lexer.lex() || 1;
                  if (typeof token !== "number") {
                      token = self.symbols_[token] || token;
                  }
                  return token;
              }
              var symbol,
                  preErrorSymbol,
                  state,
                  action,
                  r,
                  yyval = {},
                  p,
                  len,
                  newState,
                  expected;
              while (true) {
                  state = stack[stack.length - 1];
                  if (this.defaultActions[state]) {
                      action = this.defaultActions[state];
                  } else {
                      if (symbol === null || typeof symbol == "undefined") {
                          symbol = lex();
                      }
                      action = table[state] && table[state][symbol];
                  }
                  if (typeof action === "undefined" || !action.length || !action[0]) {
                      var errStr = "";
                      if (!recovering) {
                          expected = [];
                          for (p in table[state]) if (this.terminals_[p] && p > 2) {
                              expected.push("'" + this.terminals_[p] + "'");
                          }
                          if (this.lexer.showPosition) {
                              errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                          } else {
                              errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                          }
                          this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
                      }
                  }
                  if (action[0] instanceof Array && action.length > 1) {
                      throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                  }
                  switch (action[0]) {
                      case 1:
                          stack.push(symbol);
                          vstack.push(this.lexer.yytext);
                          lstack.push(this.lexer.yylloc);
                          stack.push(action[1]);
                          symbol = null;
                          if (!preErrorSymbol) {
                              yyleng = this.lexer.yyleng;
                              yytext = this.lexer.yytext;
                              yylineno = this.lexer.yylineno;
                              yyloc = this.lexer.yylloc;
                              if (recovering > 0) recovering--;
                          } else {
                              symbol = preErrorSymbol;
                              preErrorSymbol = null;
                          }
                          break;
                      case 2:
                          len = this.productions_[action[1]][1];
                          yyval.$ = vstack[vstack.length - len];
                          yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                          if (ranges) {
                              yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                          }
                          r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                          if (typeof r !== "undefined") {
                              return r;
                          }
                          if (len) {
                              stack = stack.slice(0, -1 * len * 2);
                              vstack = vstack.slice(0, -1 * len);
                              lstack = lstack.slice(0, -1 * len);
                          }
                          stack.push(this.productions_[action[1]][0]);
                          vstack.push(yyval.$);
                          lstack.push(yyval._$);
                          newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                          stack.push(newState);
                          break;
                      case 3:
                          return true;
                  }
              }
              return true;
          }
      };
      /* Jison generated lexer */
      var lexer = (function () {
          var lexer = { EOF: 1,
              parseError: function parseError(str, hash) {
                  if (this.yy.parser) {
                      this.yy.parser.parseError(str, hash);
                  } else {
                      throw new Error(str);
                  }
              },
              setInput: function (input) {
                  this._input = input;
                  this._more = this._less = this.done = false;
                  this.yylineno = this.yyleng = 0;
                  this.yytext = this.matched = this.match = '';
                  this.conditionStack = ['INITIAL'];
                  this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
                  if (this.options.ranges) this.yylloc.range = [0, 0];
                  this.offset = 0;
                  return this;
              },
              input: function () {
                  var ch = this._input[0];
                  this.yytext += ch;
                  this.yyleng++;
                  this.offset++;
                  this.match += ch;
                  this.matched += ch;
                  var lines = ch.match(/(?:\r\n?|\n).*/g);
                  if (lines) {
                      this.yylineno++;
                      this.yylloc.last_line++;
                  } else {
                      this.yylloc.last_column++;
                  }
                  if (this.options.ranges) this.yylloc.range[1]++;

                  this._input = this._input.slice(1);
                  return ch;
              },
              unput: function (ch) {
                  var len = ch.length;
                  var lines = ch.split(/(?:\r\n?|\n)/g);

                  this._input = ch + this._input;
                  this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
                  //this.yyleng -= len;
                  this.offset -= len;
                  var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                  this.match = this.match.substr(0, this.match.length - 1);
                  this.matched = this.matched.substr(0, this.matched.length - 1);

                  if (lines.length - 1) this.yylineno -= lines.length - 1;
                  var r = this.yylloc.range;

                  this.yylloc = { first_line: this.yylloc.first_line,
                      last_line: this.yylineno + 1,
                      first_column: this.yylloc.first_column,
                      last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                  };

                  if (this.options.ranges) {
                      this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                  }
                  return this;
              },
              more: function () {
                  this._more = true;
                  return this;
              },
              less: function (n) {
                  this.unput(this.match.slice(n));
              },
              pastInput: function () {
                  var past = this.matched.substr(0, this.matched.length - this.match.length);
                  return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
              },
              upcomingInput: function () {
                  var next = this.match;
                  if (next.length < 20) {
                      next += this._input.substr(0, 20 - next.length);
                  }
                  return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
              },
              showPosition: function () {
                  var pre = this.pastInput();
                  var c = new Array(pre.length + 1).join("-");
                  return pre + this.upcomingInput() + "\n" + c + "^";
              },
              next: function () {
                  if (this.done) {
                      return this.EOF;
                  }
                  if (!this._input) this.done = true;

                  var token, match, tempMatch, index, lines;
                  if (!this._more) {
                      this.yytext = '';
                      this.match = '';
                  }
                  var rules = this._currentRules();
                  for (var i = 0; i < rules.length; i++) {
                      tempMatch = this._input.match(this.rules[rules[i]]);
                      if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                          match = tempMatch;
                          index = i;
                          if (!this.options.flex) break;
                      }
                  }
                  if (match) {
                      lines = match[0].match(/(?:\r\n?|\n).*/g);
                      if (lines) this.yylineno += lines.length;
                      this.yylloc = { first_line: this.yylloc.last_line,
                          last_line: this.yylineno + 1,
                          first_column: this.yylloc.last_column,
                          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length };
                      this.yytext += match[0];
                      this.match += match[0];
                      this.matches = match;
                      this.yyleng = this.yytext.length;
                      if (this.options.ranges) {
                          this.yylloc.range = [this.offset, this.offset += this.yyleng];
                      }
                      this._more = false;
                      this._input = this._input.slice(match[0].length);
                      this.matched += match[0];
                      token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                      if (this.done && this._input) this.done = false;
                      if (token) return token;else return;
                  }
                  if (this._input === "") {
                      return this.EOF;
                  } else {
                      return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), { text: "", token: null, line: this.yylineno });
                  }
              },
              lex: function lex() {
                  var r = this.next();
                  if (typeof r !== 'undefined') {
                      return r;
                  } else {
                      return this.lex();
                  }
              },
              begin: function begin(condition) {
                  this.conditionStack.push(condition);
              },
              popState: function popState() {
                  return this.conditionStack.pop();
              },
              _currentRules: function _currentRules() {
                  return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
              },
              topState: function () {
                  return this.conditionStack[this.conditionStack.length - 2];
              },
              pushState: function begin(condition) {
                  this.begin(condition);
              } };
          lexer.options = {};
          lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {

              function strip(start, end) {
                  return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
              }
              switch ($avoiding_name_collisions) {
                  case 0:
                      if (yy_.yytext.slice(-2) === "\\\\") {
                          strip(0, 1);
                          this.begin("mu");
                      } else if (yy_.yytext.slice(-1) === "\\") {
                          strip(0, 1);
                          this.begin("emu");
                      } else {
                          this.begin("mu");
                      }
                      if (yy_.yytext) return 14;

                      break;
                  case 1:
                      return 14;
                      break;
                  case 2:
                      this.popState();
                      return 14;

                      break;
                  case 3:
                      yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
                      this.popState();
                      return 16;

                      break;
                  case 4:
                      return 14;
                      break;
                  case 5:
                      this.popState();
                      return 13;

                      break;
                  case 6:
                      return 59;
                      break;
                  case 7:
                      return 62;
                      break;
                  case 8:
                      return 17;
                      break;
                  case 9:
                      this.popState();
                      this.begin('raw');
                      return 21;

                      break;
                  case 10:
                      return 53;
                      break;
                  case 11:
                      return 27;
                      break;
                  case 12:
                      return 45;
                      break;
                  case 13:
                      this.popState();return 42;
                      break;
                  case 14:
                      this.popState();return 42;
                      break;
                  case 15:
                      return 32;
                      break;
                  case 16:
                      return 37;
                      break;
                  case 17:
                      return 49;
                      break;
                  case 18:
                      return 46;
                      break;
                  case 19:
                      this.unput(yy_.yytext);
                      this.popState();
                      this.begin('com');

                      break;
                  case 20:
                      this.popState();
                      return 13;

                      break;
                  case 21:
                      return 46;
                      break;
                  case 22:
                      return 67;
                      break;
                  case 23:
                      return 66;
                      break;
                  case 24:
                      return 66;
                      break;
                  case 25:
                      return 81;
                      break;
                  case 26:
                      // ignore whitespace
                      break;
                  case 27:
                      this.popState();return 52;
                      break;
                  case 28:
                      this.popState();return 31;
                      break;
                  case 29:
                      yy_.yytext = strip(1, 2).replace(/\\"/g, '"');return 74;
                      break;
                  case 30:
                      yy_.yytext = strip(1, 2).replace(/\\'/g, "'");return 74;
                      break;
                  case 31:
                      return 79;
                      break;
                  case 32:
                      return 76;
                      break;
                  case 33:
                      return 76;
                      break;
                  case 34:
                      return 77;
                      break;
                  case 35:
                      return 78;
                      break;
                  case 36:
                      return 75;
                      break;
                  case 37:
                      return 69;
                      break;
                  case 38:
                      return 71;
                      break;
                  case 39:
                      return 66;
                      break;
                  case 40:
                      return 66;
                      break;
                  case 41:
                      return 'INVALID';
                      break;
                  case 42:
                      return 5;
                      break;
              }
          };
          lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{\/)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[[^\]]*\])/, /^(?:.)/, /^(?:$)/];
          lexer.conditions = { "mu": { "rules": [6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [5], "inclusive": false }, "raw": { "rules": [3, 4], "inclusive": false }, "INITIAL": { "rules": [0, 1, 42], "inclusive": true } };
          return lexer;
      })();
      parser.lexer = lexer;
      function Parser() {
          this.yy = {};
      }Parser.prototype = parser;parser.Parser = Parser;
      return new Parser();
  })();exports.default = handlebars;
  module.exports = exports.default;

  });

  unwrapExports(parser);

  var ast = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  var AST = {
    Program: function (statements, blockParams, strip, locInfo) {
      this.loc = locInfo;
      this.type = 'Program';
      this.body = statements;

      this.blockParams = blockParams;
      this.strip = strip;
    },

    MustacheStatement: function (path, params, hash, escaped, strip, locInfo) {
      this.loc = locInfo;
      this.type = 'MustacheStatement';

      this.path = path;
      this.params = params || [];
      this.hash = hash;
      this.escaped = escaped;

      this.strip = strip;
    },

    BlockStatement: function (path, params, hash, program, inverse, openStrip, inverseStrip, closeStrip, locInfo) {
      this.loc = locInfo;
      this.type = 'BlockStatement';

      this.path = path;
      this.params = params || [];
      this.hash = hash;
      this.program = program;
      this.inverse = inverse;

      this.openStrip = openStrip;
      this.inverseStrip = inverseStrip;
      this.closeStrip = closeStrip;
    },

    PartialStatement: function (name, params, hash, strip, locInfo) {
      this.loc = locInfo;
      this.type = 'PartialStatement';

      this.name = name;
      this.params = params || [];
      this.hash = hash;

      this.indent = '';
      this.strip = strip;
    },

    ContentStatement: function (string, locInfo) {
      this.loc = locInfo;
      this.type = 'ContentStatement';
      this.original = this.value = string;
    },

    CommentStatement: function (comment, strip, locInfo) {
      this.loc = locInfo;
      this.type = 'CommentStatement';
      this.value = comment;

      this.strip = strip;
    },

    SubExpression: function (path, params, hash, locInfo) {
      this.loc = locInfo;

      this.type = 'SubExpression';
      this.path = path;
      this.params = params || [];
      this.hash = hash;
    },

    PathExpression: function (data, depth, parts, original, locInfo) {
      this.loc = locInfo;
      this.type = 'PathExpression';

      this.data = data;
      this.original = original;
      this.parts = parts;
      this.depth = depth;
    },

    StringLiteral: function (string, locInfo) {
      this.loc = locInfo;
      this.type = 'StringLiteral';
      this.original = this.value = string;
    },

    NumberLiteral: function (number, locInfo) {
      this.loc = locInfo;
      this.type = 'NumberLiteral';
      this.original = this.value = Number(number);
    },

    BooleanLiteral: function (bool, locInfo) {
      this.loc = locInfo;
      this.type = 'BooleanLiteral';
      this.original = this.value = bool === 'true';
    },

    UndefinedLiteral: function (locInfo) {
      this.loc = locInfo;
      this.type = 'UndefinedLiteral';
      this.original = this.value = undefined;
    },

    NullLiteral: function (locInfo) {
      this.loc = locInfo;
      this.type = 'NullLiteral';
      this.original = this.value = null;
    },

    Hash: function (pairs, locInfo) {
      this.loc = locInfo;
      this.type = 'Hash';
      this.pairs = pairs;
    },
    HashPair: function (key, value, locInfo) {
      this.loc = locInfo;
      this.type = 'HashPair';
      this.key = key;
      this.value = value;
    },

    // Public API used to evaluate derived attributes regarding AST nodes
    helpers: {
      // a mustache is definitely a helper if:
      // * it is an eligible helper, and
      // * it has at least one parameter or hash segment
      helperExpression: function (node) {
        return !!(node.type === 'SubExpression' || node.params.length || node.hash);
      },

      scopedId: function (path) {
        return (/^\.|this\b/.test(path.original)
        );
      },

      // an ID is simple if it only has one part, and that part is not
      // `..` or `this`.
      simpleId: function (path) {
        return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
      }
    }
  };

  // Must be exported as an object rather than the root of the module as the jison lexer
  // must modify the object to operate properly.
  exports.default = AST;
  module.exports = exports.default;

  });

  unwrapExports(ast);

  var exception = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;

  var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

  function Exception(message, node) {
    var loc = node && node.loc,
        line = undefined,
        column = undefined;
    if (loc) {
      line = loc.start.line;
      column = loc.start.column;

      message += ' - ' + line + ':' + column;
    }

    var tmp = Error.prototype.constructor.call(this, message);

    // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
    for (var idx = 0; idx < errorProps.length; idx++) {
      this[errorProps[idx]] = tmp[errorProps[idx]];
    }

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, Exception);
    }

    if (loc) {
      this.lineNumber = line;
      this.column = column;
    }
  }

  Exception.prototype = new Error();

  exports.default = Exception;
  module.exports = exports.default;

  });

  unwrapExports(exception);

  var visitor = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _exception2 = _interopRequireDefault(exception);



  var _ast2 = _interopRequireDefault(ast);

  function Visitor() {
    this.parents = [];
  }

  Visitor.prototype = {
    constructor: Visitor,
    mutating: false,

    // Visits a given value. If mutating, will replace the value if necessary.
    acceptKey: function (node, name) {
      var value = this.accept(node[name]);
      if (this.mutating) {
        // Hacky sanity check:
        if (value && (!value.type || !_ast2.default[value.type])) {
          throw new _exception2.default('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
        }
        node[name] = value;
      }
    },

    // Performs an accept operation with added sanity check to ensure
    // required keys are not removed.
    acceptRequired: function (node, name) {
      this.acceptKey(node, name);

      if (!node[name]) {
        throw new _exception2.default(node.type + ' requires ' + name);
      }
    },

    // Traverses a given array. If mutating, empty respnses will be removed
    // for child elements.
    acceptArray: function (array) {
      for (var i = 0, l = array.length; i < l; i++) {
        this.acceptKey(array, i);

        if (!array[i]) {
          array.splice(i, 1);
          i--;
          l--;
        }
      }
    },

    accept: function (object) {
      if (!object) {
        return;
      }

      if (this.current) {
        this.parents.unshift(this.current);
      }
      this.current = object;

      var ret = this[object.type](object);

      this.current = this.parents.shift();

      if (!this.mutating || ret) {
        return ret;
      } else if (ret !== false) {
        return object;
      }
    },

    Program: function (program) {
      this.acceptArray(program.body);
    },

    MustacheStatement: function (mustache) {
      this.acceptRequired(mustache, 'path');
      this.acceptArray(mustache.params);
      this.acceptKey(mustache, 'hash');
    },

    BlockStatement: function (block) {
      this.acceptRequired(block, 'path');
      this.acceptArray(block.params);
      this.acceptKey(block, 'hash');

      this.acceptKey(block, 'program');
      this.acceptKey(block, 'inverse');
    },

    PartialStatement: function (partial) {
      this.acceptRequired(partial, 'name');
      this.acceptArray(partial.params);
      this.acceptKey(partial, 'hash');
    },

    ContentStatement: function () /* content */{},
    CommentStatement: function () /* comment */{},

    SubExpression: function (sexpr) {
      this.acceptRequired(sexpr, 'path');
      this.acceptArray(sexpr.params);
      this.acceptKey(sexpr, 'hash');
    },

    PathExpression: function () /* path */{},

    StringLiteral: function () /* string */{},
    NumberLiteral: function () /* number */{},
    BooleanLiteral: function () /* bool */{},
    UndefinedLiteral: function () /* literal */{},
    NullLiteral: function () /* literal */{},

    Hash: function (hash) {
      this.acceptArray(hash.pairs);
    },
    HashPair: function (pair) {
      this.acceptRequired(pair, 'value');
    }
  };

  exports.default = Visitor;
  module.exports = exports.default;

  });

  unwrapExports(visitor);

  var whitespaceControl = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _visitor2 = _interopRequireDefault(visitor);

  function WhitespaceControl() {}
  WhitespaceControl.prototype = new _visitor2.default();

  WhitespaceControl.prototype.Program = function (program) {
    var isRoot = !this.isRootSeen;
    this.isRootSeen = true;

    var body = program.body;
    for (var i = 0, l = body.length; i < l; i++) {
      var current = body[i],
          strip = this.accept(current);

      if (!strip) {
        continue;
      }

      var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
          _isNextWhitespace = isNextWhitespace(body, i, isRoot),
          openStandalone = strip.openStandalone && _isPrevWhitespace,
          closeStandalone = strip.closeStandalone && _isNextWhitespace,
          inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

      if (strip.close) {
        omitRight(body, i, true);
      }
      if (strip.open) {
        omitLeft(body, i, true);
      }

      if (inlineStandalone) {
        omitRight(body, i);

        if (omitLeft(body, i)) {
          // If we are on a standalone node, save the indent info for partials
          if (current.type === 'PartialStatement') {
            // Pull out the whitespace from the final line
            current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
          }
        }
      }
      if (openStandalone) {
        omitRight((current.program || current.inverse).body);

        // Strip out the previous content node if it's whitespace only
        omitLeft(body, i);
      }
      if (closeStandalone) {
        // Always strip the next node
        omitRight(body, i);

        omitLeft((current.inverse || current.program).body);
      }
    }

    return program;
  };
  WhitespaceControl.prototype.BlockStatement = function (block) {
    this.accept(block.program);
    this.accept(block.inverse);

    // Find the inverse program that is involed with whitespace stripping.
    var program = block.program || block.inverse,
        inverse = block.program && block.inverse,
        firstInverse = inverse,
        lastInverse = inverse;

    if (inverse && inverse.chained) {
      firstInverse = inverse.body[0].program;

      // Walk the inverse chain to find the last inverse that is actually in the chain.
      while (lastInverse.chained) {
        lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
      }
    }

    var strip = {
      open: block.openStrip.open,
      close: block.closeStrip.close,

      // Determine the standalone candiacy. Basically flag our content as being possibly standalone
      // so our parent can determine if we actually are standalone
      openStandalone: isNextWhitespace(program.body),
      closeStandalone: isPrevWhitespace((firstInverse || program).body)
    };

    if (block.openStrip.close) {
      omitRight(program.body, null, true);
    }

    if (inverse) {
      var inverseStrip = block.inverseStrip;

      if (inverseStrip.open) {
        omitLeft(program.body, null, true);
      }

      if (inverseStrip.close) {
        omitRight(firstInverse.body, null, true);
      }
      if (block.closeStrip.open) {
        omitLeft(lastInverse.body, null, true);
      }

      // Find standalone else statments
      if (isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
        omitLeft(program.body);
        omitRight(firstInverse.body);
      }
    } else if (block.closeStrip.open) {
      omitLeft(program.body, null, true);
    }

    return strip;
  };

  WhitespaceControl.prototype.MustacheStatement = function (mustache) {
    return mustache.strip;
  };

  WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
    /* istanbul ignore next */
    var strip = node.strip || {};
    return {
      inlineStandalone: true,
      open: strip.open,
      close: strip.close
    };
  };

  function isPrevWhitespace(body, i, isRoot) {
    if (i === undefined) {
      i = body.length;
    }

    // Nodes that end with newlines are considered whitespace (but are special
    // cased for strip operations)
    var prev = body[i - 1],
        sibling = body[i - 2];
    if (!prev) {
      return isRoot;
    }

    if (prev.type === 'ContentStatement') {
      return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
    }
  }
  function isNextWhitespace(body, i, isRoot) {
    if (i === undefined) {
      i = -1;
    }

    var next = body[i + 1],
        sibling = body[i + 2];
    if (!next) {
      return isRoot;
    }

    if (next.type === 'ContentStatement') {
      return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
    }
  }

  // Marks the node to the right of the position as omitted.
  // I.e. {{foo}}' ' will mark the ' ' node as omitted.
  //
  // If i is undefined, then the first child will be marked as such.
  //
  // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
  // content is met.
  function omitRight(body, i, multiple) {
    var current = body[i == null ? 0 : i + 1];
    if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
      return;
    }

    var original = current.value;
    current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
    current.rightStripped = current.value !== original;
  }

  // Marks the node to the left of the position as omitted.
  // I.e. ' '{{foo}} will mark the ' ' node as omitted.
  //
  // If i is undefined then the last child will be marked as such.
  //
  // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
  // content is met.
  function omitLeft(body, i, multiple) {
    var current = body[i == null ? body.length - 1 : i - 1];
    if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
      return;
    }

    // We omit the last node if it's whitespace only and not preceeded by a non-content node.
    var original = current.value;
    current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
    current.leftStripped = current.value !== original;
    return current.leftStripped;
  }

  exports.default = WhitespaceControl;
  module.exports = exports.default;

  });

  unwrapExports(whitespaceControl);

  var helpers = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.SourceLocation = SourceLocation;
  exports.id = id;
  exports.stripFlags = stripFlags;
  exports.stripComment = stripComment;
  exports.preparePath = preparePath;
  exports.prepareMustache = prepareMustache;
  exports.prepareRawBlock = prepareRawBlock;
  exports.prepareBlock = prepareBlock;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _exception2 = _interopRequireDefault(exception);

  function SourceLocation(source, locInfo) {
    this.source = source;
    this.start = {
      line: locInfo.first_line,
      column: locInfo.first_column
    };
    this.end = {
      line: locInfo.last_line,
      column: locInfo.last_column
    };
  }

  function id(token) {
    if (/^\[.*\]$/.test(token)) {
      return token.substr(1, token.length - 2);
    } else {
      return token;
    }
  }

  function stripFlags(open, close) {
    return {
      open: open.charAt(2) === '~',
      close: close.charAt(close.length - 3) === '~'
    };
  }

  function stripComment(comment) {
    return comment.replace(/^\{\{~?\!-?-?/, '').replace(/-?-?~?\}\}$/, '');
  }

  function preparePath(data, parts, locInfo) {
    locInfo = this.locInfo(locInfo);

    var original = data ? '@' : '',
        dig = [],
        depth = 0;

    for (var i = 0, l = parts.length; i < l; i++) {
      var part = parts[i].part,

      // If we have [] syntax then we do not treat path references as operators,
      // i.e. foo.[this] resolves to approximately context.foo['this']
      isLiteral = parts[i].original !== part;
      original += (parts[i].separator || '') + part;

      if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
        if (dig.length > 0) {
          throw new _exception2.default('Invalid path: ' + original, { loc: locInfo });
        } else if (part === '..') {
          depth++;
        }
      } else {
        dig.push(part);
      }
    }

    return new this.PathExpression(data, depth, dig, original, locInfo);
  }

  function prepareMustache(path, params, hash, open, strip, locInfo) {
    // Must use charAt to support IE pre-10
    var escapeFlag = open.charAt(3) || open.charAt(2),
        escaped = escapeFlag !== '{' && escapeFlag !== '&';

    return new this.MustacheStatement(path, params, hash, escaped, strip, this.locInfo(locInfo));
  }

  function prepareRawBlock(openRawBlock, content, close, locInfo) {
    if (openRawBlock.path.original !== close) {
      var errorNode = { loc: openRawBlock.path.loc };

      throw new _exception2.default(openRawBlock.path.original + " doesn't match " + close, errorNode);
    }

    locInfo = this.locInfo(locInfo);
    var program = new this.Program([content], null, {}, locInfo);

    return new this.BlockStatement(openRawBlock.path, openRawBlock.params, openRawBlock.hash, program, undefined, {}, {}, {}, locInfo);
  }

  function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
    // When we are chaining inverse calls, we will not have a close path
    if (close && close.path && openBlock.path.original !== close.path.original) {
      var errorNode = { loc: openBlock.path.loc };

      throw new _exception2.default(openBlock.path.original + ' doesn\'t match ' + close.path.original, errorNode);
    }

    program.blockParams = openBlock.blockParams;

    var inverse = undefined,
        inverseStrip = undefined;

    if (inverseAndProgram) {
      if (inverseAndProgram.chain) {
        inverseAndProgram.program.body[0].closeStrip = close.strip;
      }

      inverseStrip = inverseAndProgram.strip;
      inverse = inverseAndProgram.program;
    }

    if (inverted) {
      inverted = inverse;
      inverse = program;
      program = inverted;
    }

    return new this.BlockStatement(openBlock.path, openBlock.params, openBlock.hash, program, inverse, openBlock.strip, inverseStrip, close && close.strip, this.locInfo(locInfo));
  }

  });

  unwrapExports(helpers);
  var helpers_1 = helpers.SourceLocation;
  var helpers_2 = helpers.id;
  var helpers_3 = helpers.stripFlags;
  var helpers_4 = helpers.stripComment;
  var helpers_5 = helpers.preparePath;
  var helpers_6 = helpers.prepareMustache;
  var helpers_7 = helpers.prepareRawBlock;
  var helpers_8 = helpers.prepareBlock;

  var utils$4 = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.extend = extend;
  exports.indexOf = indexOf;
  exports.escapeExpression = escapeExpression;
  exports.isEmpty = isEmpty;
  exports.blockParams = blockParams;
  exports.appendContextPath = appendContextPath;
  var escape = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };

  var badChars = /[&<>"'`]/g,
      possible = /[&<>"'`]/;

  function escapeChar(chr) {
    return escape[chr];
  }

  function extend(obj /* , ...source */) {
    for (var i = 1; i < arguments.length; i++) {
      for (var key in arguments[i]) {
        if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
          obj[key] = arguments[i][key];
        }
      }
    }

    return obj;
  }

  var toString = Object.prototype.toString;

  exports.toString = toString;
  // Sourced from lodash
  // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
  /*eslint-disable func-style, no-var */
  var isFunction = function (value) {
    return typeof value === 'function';
  };
  // fallback for older versions of Chrome and Safari
  /* istanbul ignore next */
  if (isFunction(/x/)) {
    exports.isFunction = isFunction = function (value) {
      return typeof value === 'function' && toString.call(value) === '[object Function]';
    };
  }
  var isFunction;
  exports.isFunction = isFunction;
  /*eslint-enable func-style, no-var */

  /* istanbul ignore next */
  var isArray = Array.isArray || function (value) {
    return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
  };

  exports.isArray = isArray;
  // Older IE versions do not directly support indexOf so we must implement our own, sadly.

  function indexOf(array, value) {
    for (var i = 0, len = array.length; i < len; i++) {
      if (array[i] === value) {
        return i;
      }
    }
    return -1;
  }

  function escapeExpression(string) {
    if (typeof string !== 'string') {
      // don't escape SafeStrings, since they're already safe
      if (string && string.toHTML) {
        return string.toHTML();
      } else if (string == null) {
        return '';
      } else if (!string) {
        return string + '';
      }

      // Force a string conversion as this will be done by the append regardless and
      // the regex test will do this transparently behind the scenes, causing issues if
      // an object's to string has escaped characters in it.
      string = '' + string;
    }

    if (!possible.test(string)) {
      return string;
    }
    return string.replace(badChars, escapeChar);
  }

  function isEmpty(value) {
    if (!value && value !== 0) {
      return true;
    } else if (isArray(value) && value.length === 0) {
      return true;
    } else {
      return false;
    }
  }

  function blockParams(params, ids) {
    params.path = ids;
    return params;
  }

  function appendContextPath(contextPath, id) {
    return (contextPath ? contextPath + '.' : '') + id;
  }

  });

  unwrapExports(utils$4);
  var utils_1$2 = utils$4.extend;
  var utils_2$2 = utils$4.indexOf;
  var utils_3$1 = utils$4.escapeExpression;
  var utils_4$1 = utils$4.isEmpty;
  var utils_5$1 = utils$4.blockParams;
  var utils_6$1 = utils$4.appendContextPath;
  var utils_7$1 = utils$4.isFunction;
  var utils_8$1 = utils$4.isArray;

  var base = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.parse = parse;

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _parser2 = _interopRequireDefault(parser);



  var _ast2 = _interopRequireDefault(ast);



  var _whitespaceControl2 = _interopRequireDefault(whitespaceControl);



  var Helpers = _interopRequireWildcard(helpers);



  exports.parser = _parser2.default;

  var yy = {};
  utils$4.extend(yy, Helpers, _ast2.default);

  function parse(input, options) {
    // Just return if an already-compiled AST was passed in.
    if (input.type === 'Program') {
      return input;
    }

    _parser2.default.yy = yy;

    // Altering the shared object here, but this is ok as parser is a sync operation
    yy.locInfo = function (locInfo) {
      return new yy.SourceLocation(options && options.srcName, locInfo);
    };

    var strip = new _whitespaceControl2.default();
    return strip.accept(_parser2.default.parse(input));
  }

  });

  unwrapExports(base);
  var base_1 = base.parse;
  var base_2 = base.parser;

  var builders = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.buildMustache = buildMustache;
  exports.buildBlock = buildBlock;
  exports.buildElementModifier = buildElementModifier;
  exports.buildPartial = buildPartial;
  exports.buildComment = buildComment;
  exports.buildConcat = buildConcat;
  exports.buildElement = buildElement;
  exports.buildComponent = buildComponent;
  exports.buildAttr = buildAttr;
  exports.buildText = buildText;
  exports.buildSexpr = buildSexpr;
  exports.buildPath = buildPath;
  exports.buildString = buildString;
  exports.buildBoolean = buildBoolean;
  exports.buildNumber = buildNumber;
  exports.buildNull = buildNull;
  exports.buildUndefined = buildUndefined;
  exports.buildHash = buildHash;
  exports.buildPair = buildPair;
  exports.buildProgram = buildProgram;
  // Statements

  function buildMustache(path, params, hash, raw, loc) {
    return {
      type: "MustacheStatement",
      path: buildPath(path),
      params: params || [],
      hash: hash || buildHash([]),
      escaped: !raw,
      loc: buildLoc(loc)
    };
  }

  function buildBlock(path, params, hash, program, inverse, loc) {
    return {
      type: "BlockStatement",
      path: buildPath(path),
      params: params || [],
      hash: hash || buildHash([]),
      program: program || null,
      inverse: inverse || null,
      loc: buildLoc(loc)
    };
  }

  function buildElementModifier(path, params, hash, loc) {
    return {
      type: "ElementModifierStatement",
      path: buildPath(path),
      params: params || [],
      hash: hash || buildHash([]),
      loc: buildLoc(loc)
    };
  }

  function buildPartial(name, params, hash, indent) {
    return {
      type: "PartialStatement",
      name: name,
      params: params || [],
      hash: hash || buildHash([]),
      indent: indent
    };
  }

  function buildComment(value) {
    return {
      type: "CommentStatement",
      value: value
    };
  }

  function buildConcat(parts) {
    return {
      type: "ConcatStatement",
      parts: parts || []
    };
  }

  // Nodes

  function buildElement(tag, attributes, modifiers, children, loc) {
    return {
      type: "ElementNode",
      tag: tag || "",
      attributes: attributes || [],
      modifiers: modifiers || [],
      children: children || [],
      loc: buildLoc(loc)
    };
  }

  function buildComponent(tag, attributes, program, loc) {
    return {
      type: "ComponentNode",
      tag: tag,
      attributes: attributes,
      program: program,
      loc: buildLoc(loc),

      // this should be true only if this component node is guaranteed
      // to produce start and end points that can never change after the
      // initial render, regardless of changes to dynamic inputs. If
      // a component represents a "fragment" (any number of top-level nodes),
      // this will usually not be true.
      isStatic: false
    };
  }

  function buildAttr(name, value, loc) {
    return {
      type: "AttrNode",
      name: name,
      value: value,
      loc: buildLoc(loc)
    };
  }

  function buildText(chars, loc) {
    return {
      type: "TextNode",
      chars: chars || "",
      loc: buildLoc(loc)
    };
  }

  // Expressions

  function buildSexpr(path, params, hash) {
    return {
      type: "SubExpression",
      path: buildPath(path),
      params: params || [],
      hash: hash || buildHash([])
    };
  }

  function buildPath(original) {
    if (typeof original === 'string') {
      return {
        type: "PathExpression",
        original: original,
        parts: original.split('.')
      };
    } else {
      return original;
    }
  }

  function buildString(value) {
    return {
      type: "StringLiteral",
      value: value,
      original: value
    };
  }

  function buildBoolean(value) {
    return {
      type: "BooleanLiteral",
      value: value,
      original: value
    };
  }

  function buildNumber(value) {
    return {
      type: "NumberLiteral",
      value: value,
      original: value
    };
  }

  function buildNull() {
    return {
      type: "NullLiteral",
      value: null,
      original: null
    };
  }

  function buildUndefined() {
    return {
      type: "UndefinedLiteral",
      value: undefined,
      original: undefined
    };
  }

  // Miscellaneous

  function buildHash(pairs) {
    return {
      type: "Hash",
      pairs: pairs || []
    };
  }

  function buildPair(key, value) {
    return {
      type: "HashPair",
      key: key,
      value: value
    };
  }

  function buildProgram(body, blockParams, loc) {
    return {
      type: "Program",
      body: body || [],
      blockParams: blockParams || [],
      loc: buildLoc(loc)
    };
  }

  function buildSource(source) {
    return source || null;
  }

  function buildPosition(line, column) {
    return {
      line: typeof line === 'number' ? line : null,
      column: typeof column === 'number' ? column : null
    };
  }

  function buildLoc(startLine, startColumn, endLine, endColumn, source) {
    if (arguments.length === 1) {
      var loc = startLine;

      if (typeof loc === 'object') {
        return {
          source: buildSource(loc.source),
          start: buildPosition(loc.start.line, loc.start.column),
          end: buildPosition(loc.end.line, loc.end.column)
        };
      } else {
        return null;
      }
    } else {
      return {
        source: buildSource(source),
        start: buildPosition(startLine, startColumn),
        end: buildPosition(endLine, endColumn)
      };
    }
  }

  exports.default = {
    mustache: buildMustache,
    block: buildBlock,
    partial: buildPartial,
    comment: buildComment,
    element: buildElement,
    elementModifier: buildElementModifier,
    component: buildComponent,
    attr: buildAttr,
    text: buildText,
    sexpr: buildSexpr,
    path: buildPath,
    string: buildString,
    boolean: buildBoolean,
    number: buildNumber,
    undefined: buildUndefined,
    null: buildNull,
    concat: buildConcat,
    hash: buildHash,
    pair: buildPair,
    program: buildProgram,
    loc: buildLoc,
    pos: buildPosition
  };

  });

  unwrapExports(builders);
  var builders_1 = builders.buildMustache;
  var builders_2 = builders.buildBlock;
  var builders_3 = builders.buildElementModifier;
  var builders_4 = builders.buildPartial;
  var builders_5 = builders.buildComment;
  var builders_6 = builders.buildConcat;
  var builders_7 = builders.buildElement;
  var builders_8 = builders.buildComponent;
  var builders_9 = builders.buildAttr;
  var builders_10 = builders.buildText;
  var builders_11 = builders.buildSexpr;
  var builders_12 = builders.buildPath;
  var builders_13 = builders.buildString;
  var builders_14 = builders.buildBoolean;
  var builders_15 = builders.buildNumber;
  var builders_16 = builders.buildNull;
  var builders_17 = builders.buildUndefined;
  var builders_18 = builders.buildHash;
  var builders_19 = builders.buildPair;
  var builders_20 = builders.buildProgram;

  var print = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.default = build;

  function build(ast) {
    if (!ast) {
      return '';
    }
    var output = [];

    switch (ast.type) {
      case 'Program':
        {
          var chainBlock = ast.chained && ast.body[0];
          if (chainBlock) {
            chainBlock.chained = true;
          }
          var body = buildEach(ast.body).join('');
          output.push(body);
        }
        break;
      case 'ElementNode':
        output.push('<', ast.tag);
        if (ast.attributes.length) {
          output.push(' ', buildEach(ast.attributes).join(' '));
        }
        if (ast.modifiers.length) {
          output.push(' ', buildEach(ast.modifiers).join(' '));
        }
        output.push('>');
        output.push.apply(output, buildEach(ast.children));
        output.push('</', ast.tag, '>');
        break;
      case 'AttrNode':
        output.push(ast.name, '=');
        var value = build(ast.value);
        if (ast.value.type === 'TextNode') {
          output.push('"', value, '"');
        } else {
          output.push(value);
        }
        break;
      case 'ConcatStatement':
        output.push('"');
        ast.parts.forEach(function (node) {
          if (node.type === 'StringLiteral') {
            output.push(node.original);
          } else {
            output.push(build(node));
          }
        });
        output.push('"');
        break;
      case 'TextNode':
        output.push(ast.chars);
        break;
      case 'MustacheStatement':
        {
          output.push(compactJoin(['{{', pathParams(ast), '}}']));
        }
        break;
      case 'ElementModifierStatement':
        {
          output.push(compactJoin(['{{', pathParams(ast), '}}']));
        }
        break;
      case 'PathExpression':
        output.push(ast.original);
        break;
      case 'SubExpression':
        {
          output.push('(', pathParams(ast), ')');
        }
        break;
      case 'BooleanLiteral':
        output.push(ast.value ? 'true' : false);
        break;
      case 'BlockStatement':
        {
          var lines = [];

          if (ast.chained) {
            lines.push(['{{else ', pathParams(ast), '}}'].join(''));
          } else {
            lines.push(openBlock(ast));
          }

          lines.push(build(ast.program));

          if (ast.inverse) {
            if (!ast.inverse.chained) {
              lines.push('{{else}}');
            }
            lines.push(build(ast.inverse));
          }

          if (!ast.chained) {
            lines.push(closeBlock(ast));
          }

          output.push(lines.join(''));
        }
        break;
      case 'PartialStatement':
        {
          output.push(compactJoin(['{{>', pathParams(ast), '}}']));
        }
        break;
      case 'CommentStatement':
        {
          output.push(compactJoin(['<!--', ast.value, '-->']));
        }
        break;
      case 'StringLiteral':
        {
          output.push('"' + ast.value + '"');
        }
        break;
      case 'NumberLiteral':
        {
          output.push(ast.value);
        }
        break;
      case 'UndefinedLiteral':
        {
          output.push('undefined');
        }
        break;
      case 'NullLiteral':
        {
          output.push('null');
        }
        break;
      case 'Hash':
        {
          output.push(ast.pairs.map(function (pair) {
            return build(pair);
          }).join(' '));
        }
        break;
      case 'HashPair':
        {
          output.push(ast.key + '=' + build(ast.value));
        }
        break;
    }
    return output.join('');
  }

  function compact(array) {
    var newArray = [];
    array.forEach(function (a) {
      if (typeof a !== 'undefined' && a !== null && a !== '') {
        newArray.push(a);
      }
    });
    return newArray;
  }

  function buildEach(asts) {
    var output = [];
    asts.forEach(function (node) {
      output.push(build(node));
    });
    return output;
  }

  function pathParams(ast) {
    var name = build(ast.name);
    var path = build(ast.path);
    var params = buildEach(ast.params).join(' ');
    var hash = build(ast.hash);
    return compactJoin([name, path, params, hash], ' ');
  }

  function compactJoin(array, delimiter) {
    return compact(array).join(delimiter || '');
  }

  function blockParams(block) {
    var params = block.program.blockParams;
    if (params.length) {
      return ' as |' + params.join(',') + '|';
    }
  }

  function openBlock(block) {
    return ['{{#', pathParams(block), blockParams(block), '}}'].join('');
  }

  function closeBlock(block) {
    return ['{{/', build(block.path), '}}'].join('');
  }
  module.exports = exports.default;

  });

  unwrapExports(print);

  var visitorKeys = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.default = {
    Program: ['body'],

    MustacheStatement: ['path', 'params', 'hash'],
    BlockStatement: ['path', 'params', 'hash', 'program', 'inverse'],
    ElementModifierStatement: ['path', 'params', 'hash'],
    PartialStatement: ['name', 'params', 'hash'],
    CommentStatement: [],
    ElementNode: ['attributes', 'modifiers', 'children'],
    ComponentNode: ['attributes', 'program'],
    AttrNode: ['value'],
    TextNode: [],

    ConcatStatement: ['parts'],
    SubExpression: ['path', 'params', 'hash'],
    PathExpression: [],

    StringLiteral: [],
    BooleanLiteral: [],
    NumberLiteral: [],
    NullLiteral: [],
    UndefinedLiteral: [],

    Hash: ['pairs'],
    HashPair: ['value']
  };
  module.exports = exports.default;

  });

  unwrapExports(visitorKeys);

  var errors = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.cannotRemoveNode = cannotRemoveNode;
  exports.cannotReplaceNode = cannotReplaceNode;
  exports.cannotReplaceOrRemoveInKeyHandlerYet = cannotReplaceOrRemoveInKeyHandlerYet;
  function TraversalError(message, node, parent, key) {
    this.name = "TraversalError";
    this.message = message;
    this.node = node;
    this.parent = parent;
    this.key = key;
  }

  TraversalError.prototype = Object.create(Error.prototype);
  TraversalError.prototype.constructor = TraversalError;

  exports.default = TraversalError;

  function cannotRemoveNode(node, parent, key) {
    return new TraversalError("Cannot remove a node unless it is part of an array", node, parent, key);
  }

  function cannotReplaceNode(node, parent, key) {
    return new TraversalError("Cannot replace a node with multiple nodes unless it is part of an array", node, parent, key);
  }

  function cannotReplaceOrRemoveInKeyHandlerYet(node, key) {
    return new TraversalError("Replacing and removing in key handlers is not yet supported.", node, null, key);
  }

  });

  unwrapExports(errors);
  var errors_1 = errors.cannotRemoveNode;
  var errors_2 = errors.cannotReplaceNode;
  var errors_3 = errors.cannotReplaceOrRemoveInKeyHandlerYet;

  var traverse_1 = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.default = traverse;
  exports.normalizeVisitor = normalizeVisitor;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _typesVisitorKeys2 = _interopRequireDefault(visitorKeys);



  function visitNode(visitor, node) {
    var handler = visitor[node.type] || visitor.All;
    var result = undefined;

    if (handler && handler.enter) {
      result = handler.enter.call(null, node);
    }

    if (result === undefined) {
      var keys = _typesVisitorKeys2.default[node.type];

      for (var i = 0; i < keys.length; i++) {
        visitKey(visitor, handler, node, keys[i]);
      }

      if (handler && handler.exit) {
        result = handler.exit.call(null, node);
      }
    }

    return result;
  }

  function visitKey(visitor, handler, node, key) {
    var value = node[key];
    if (!value) {
      return;
    }

    var keyHandler = handler && (handler.keys[key] || handler.keys.All);
    var result = undefined;

    if (keyHandler && keyHandler.enter) {
      result = keyHandler.enter.call(null, node, key);
      if (result !== undefined) {
        throw errors.cannotReplaceOrRemoveInKeyHandlerYet(node, key);
      }
    }

    if (Array.isArray(value)) {
      visitArray(visitor, value);
    } else {
      var _result = visitNode(visitor, value);
      if (_result !== undefined) {
        assignKey(node, key, _result);
      }
    }

    if (keyHandler && keyHandler.exit) {
      result = keyHandler.exit.call(null, node, key);
      if (result !== undefined) {
        throw errors.cannotReplaceOrRemoveInKeyHandlerYet(node, key);
      }
    }
  }

  function visitArray(visitor, array) {
    for (var i = 0; i < array.length; i++) {
      var result = visitNode(visitor, array[i]);
      if (result !== undefined) {
        i += spliceArray(array, i, result) - 1;
      }
    }
  }

  function assignKey(node, key, result) {
    if (result === null) {
      throw errors.cannotRemoveNode(node[key], node, key);
    } else if (Array.isArray(result)) {
      if (result.length === 1) {
        node[key] = result[0];
      } else {
        if (result.length === 0) {
          throw errors.cannotRemoveNode(node[key], node, key);
        } else {
          throw errors.cannotReplaceNode(node[key], node, key);
        }
      }
    } else {
      node[key] = result;
    }
  }

  function spliceArray(array, index, result) {
    if (result === null) {
      array.splice(index, 1);
      return 0;
    } else if (Array.isArray(result)) {
      array.splice.apply(array, [index, 1].concat(result));
      return result.length;
    } else {
      array.splice(index, 1, result);
      return 1;
    }
  }

  function traverse(node, visitor) {
    visitNode(normalizeVisitor(visitor), node);
  }

  function normalizeVisitor(visitor) {
    var normalizedVisitor = {};

    for (var type in visitor) {
      var handler = visitor[type] || visitor.All;
      var normalizedKeys = {};

      if (typeof handler === 'object') {
        var keys = handler.keys;
        if (keys) {
          for (var key in keys) {
            var keyHandler = keys[key];
            if (typeof keyHandler === 'object') {
              normalizedKeys[key] = {
                enter: typeof keyHandler.enter === 'function' ? keyHandler.enter : null,
                exit: typeof keyHandler.exit === 'function' ? keyHandler.exit : null
              };
            } else if (typeof keyHandler === 'function') {
              normalizedKeys[key] = {
                enter: keyHandler,
                exit: null
              };
            }
          }
        }

        normalizedVisitor[type] = {
          enter: typeof handler.enter === 'function' ? handler.enter : null,
          exit: typeof handler.exit === 'function' ? handler.exit : null,
          keys: normalizedKeys
        };
      } else if (typeof handler === 'function') {
        normalizedVisitor[type] = {
          enter: handler,
          exit: null,
          keys: normalizedKeys
        };
      }
    }

    return normalizedVisitor;
  }

  });

  unwrapExports(traverse_1);
  var traverse_2 = traverse_1.normalizeVisitor;

  var walker = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  function Walker(order) {
    this.order = order;
    this.stack = [];
  }

  exports.default = Walker;

  Walker.prototype.visit = function (node, callback) {
    if (!node) {
      return;
    }

    this.stack.push(node);

    if (this.order === 'post') {
      this.children(node, callback);
      callback(node, this);
    } else {
      callback(node, this);
      this.children(node, callback);
    }

    this.stack.pop();
  };

  var visitors = {
    Program: function (walker, node, callback) {
      for (var i = 0; i < node.body.length; i++) {
        walker.visit(node.body[i], callback);
      }
    },

    ElementNode: function (walker, node, callback) {
      for (var i = 0; i < node.children.length; i++) {
        walker.visit(node.children[i], callback);
      }
    },

    BlockStatement: function (walker, node, callback) {
      walker.visit(node.program, callback);
      walker.visit(node.inverse, callback);
    },

    ComponentNode: function (walker, node, callback) {
      walker.visit(node.program, callback);
    }
  };

  Walker.prototype.children = function (node, callback) {
    var visitor = visitors[node.type];
    if (visitor) {
      visitor(this, node, callback);
    }
  };
  module.exports = exports.default;

  });

  unwrapExports(walker);

  var htmlbarsSyntax = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }



  var _htmlbarsSyntaxBuilders2 = _interopRequireDefault(builders);



  var _htmlbarsSyntaxParser2 = _interopRequireDefault(parser$2);



  var _htmlbarsSyntaxGenerationPrint2 = _interopRequireDefault(print);



  var _htmlbarsSyntaxTraversalTraverse2 = _interopRequireDefault(traverse_1);



  var _htmlbarsSyntaxTraversalWalker2 = _interopRequireDefault(walker);

  exports.builders = _htmlbarsSyntaxBuilders2.default;
  exports.parse = _htmlbarsSyntaxParser2.default;
  exports.print = _htmlbarsSyntaxGenerationPrint2.default;
  exports.traverse = _htmlbarsSyntaxTraversalTraverse2.default;
  exports.Walker = _htmlbarsSyntaxTraversalWalker2.default;

  });

  unwrapExports(htmlbarsSyntax);
  var htmlbarsSyntax_1 = htmlbarsSyntax.builders;
  var htmlbarsSyntax_2 = htmlbarsSyntax.parse;
  var htmlbarsSyntax_3 = htmlbarsSyntax.print;
  var htmlbarsSyntax_4 = htmlbarsSyntax.traverse;
  var htmlbarsSyntax_5 = htmlbarsSyntax.Walker;

  var utils$6 = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.isSpace = isSpace;
  exports.isAlpha = isAlpha;
  exports.preprocessInput = preprocessInput;
  var WSP = /[\t\n\f ]/;
  var ALPHA = /[A-Za-z]/;
  var CRLF = /\r\n?/g;

  function isSpace(char) {
    return WSP.test(char);
  }

  function isAlpha(char) {
    return ALPHA.test(char);
  }

  function preprocessInput(input) {
    return input.replace(CRLF, "\n");
  }

  });

  unwrapExports(utils$6);
  var utils_1$3 = utils$6.isSpace;
  var utils_2$3 = utils$6.isAlpha;
  var utils_3$2 = utils$6.preprocessInput;

  var eventedTokenizer = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;



  function EventedTokenizer(delegate, entityParser) {
    this.delegate = delegate;
    this.entityParser = entityParser;

    this.state = null;
    this.input = null;

    this.index = -1;
    this.line = -1;
    this.column = -1;
    this.tagLine = -1;
    this.tagColumn = -1;

    this.reset();
  }

  EventedTokenizer.prototype = {
    reset: function () {
      this.state = 'beforeData';
      this.input = '';

      this.index = 0;
      this.line = 1;
      this.column = 0;

      this.tagLine = -1;
      this.tagColumn = -1;

      this.delegate.reset();
    },

    tokenize: function (input) {
      this.reset();
      this.tokenizePart(input);
      this.tokenizeEOF();
    },

    tokenizePart: function (input) {
      this.input += utils$6.preprocessInput(input);

      while (this.index < this.input.length) {
        this.states[this.state].call(this);
      }
    },

    tokenizeEOF: function () {
      this.flushData();
    },

    flushData: function () {
      if (this.state === 'data') {
        this.delegate.finishData();
        this.state = 'beforeData';
      }
    },

    peek: function () {
      return this.input.charAt(this.index);
    },

    consume: function () {
      var char = this.peek();

      this.index++;

      if (char === "\n") {
        this.line++;
        this.column = 0;
      } else {
        this.column++;
      }

      return char;
    },

    consumeCharRef: function () {
      var endIndex = this.input.indexOf(';', this.index);
      if (endIndex === -1) {
        return;
      }
      var entity = this.input.slice(this.index, endIndex);
      var chars = this.entityParser.parse(entity);
      if (chars) {
        var count = entity.length;
        // consume the entity chars
        while (count) {
          this.consume();
          count--;
        }
        // consume the `;`
        this.consume();

        return chars;
      }
    },

    markTagStart: function () {
      // these properties to be removed in next major bump
      this.tagLine = this.line;
      this.tagColumn = this.column;

      if (this.delegate.tagOpen) {
        this.delegate.tagOpen();
      }
    },

    states: {
      beforeData: function () {
        var char = this.peek();

        if (char === "<") {
          this.state = 'tagOpen';
          this.markTagStart();
          this.consume();
        } else {
          this.state = 'data';
          this.delegate.beginData();
        }
      },

      data: function () {
        var char = this.peek();

        if (char === "<") {
          this.delegate.finishData();
          this.state = 'tagOpen';
          this.markTagStart();
          this.consume();
        } else if (char === "&") {
          this.consume();
          this.delegate.appendToData(this.consumeCharRef() || "&");
        } else {
          this.consume();
          this.delegate.appendToData(char);
        }
      },

      tagOpen: function () {
        var char = this.consume();

        if (char === "!") {
          this.state = 'markupDeclaration';
        } else if (char === "/") {
          this.state = 'endTagOpen';
        } else if (utils$6.isAlpha(char)) {
          this.state = 'tagName';
          this.delegate.beginStartTag();
          this.delegate.appendToTagName(char.toLowerCase());
        }
      },

      markupDeclaration: function () {
        var char = this.consume();

        if (char === "-" && this.input.charAt(this.index) === "-") {
          this.consume();
          this.state = 'commentStart';
          this.delegate.beginComment();
        }
      },

      commentStart: function () {
        var char = this.consume();

        if (char === "-") {
          this.state = 'commentStartDash';
        } else if (char === ">") {
          this.delegate.finishComment();
          this.state = 'beforeData';
        } else {
          this.delegate.appendToCommentData(char);
          this.state = 'comment';
        }
      },

      commentStartDash: function () {
        var char = this.consume();

        if (char === "-") {
          this.state = 'commentEnd';
        } else if (char === ">") {
          this.delegate.finishComment();
          this.state = 'beforeData';
        } else {
          this.delegate.appendToCommentData("-");
          this.state = 'comment';
        }
      },

      comment: function () {
        var char = this.consume();

        if (char === "-") {
          this.state = 'commentEndDash';
        } else {
          this.delegate.appendToCommentData(char);
        }
      },

      commentEndDash: function () {
        var char = this.consume();

        if (char === "-") {
          this.state = 'commentEnd';
        } else {
          this.delegate.appendToCommentData("-" + char);
          this.state = 'comment';
        }
      },

      commentEnd: function () {
        var char = this.consume();

        if (char === ">") {
          this.delegate.finishComment();
          this.state = 'beforeData';
        } else {
          this.delegate.appendToCommentData("--" + char);
          this.state = 'comment';
        }
      },

      tagName: function () {
        var char = this.consume();

        if (utils$6.isSpace(char)) {
          this.state = 'beforeAttributeName';
        } else if (char === "/") {
          this.state = 'selfClosingStartTag';
        } else if (char === ">") {
          this.delegate.finishTag();
          this.state = 'beforeData';
        } else {
          this.delegate.appendToTagName(char);
        }
      },

      beforeAttributeName: function () {
        var char = this.peek();

        if (utils$6.isSpace(char)) {
          this.consume();
          return;
        } else if (char === "/") {
          this.state = 'selfClosingStartTag';
          this.consume();
        } else if (char === ">") {
          this.consume();
          this.delegate.finishTag();
          this.state = 'beforeData';
        } else {
          this.state = 'attributeName';
          this.delegate.beginAttribute();
          this.consume();
          this.delegate.appendToAttributeName(char);
        }
      },

      attributeName: function () {
        var char = this.peek();

        if (utils$6.isSpace(char)) {
          this.state = 'afterAttributeName';
          this.consume();
        } else if (char === "/") {
          this.delegate.beginAttributeValue(false);
          this.delegate.finishAttributeValue();
          this.consume();
          this.state = 'selfClosingStartTag';
        } else if (char === "=") {
          this.state = 'beforeAttributeValue';
          this.consume();
        } else if (char === ">") {
          this.delegate.beginAttributeValue(false);
          this.delegate.finishAttributeValue();
          this.consume();
          this.delegate.finishTag();
          this.state = 'beforeData';
        } else {
          this.consume();
          this.delegate.appendToAttributeName(char);
        }
      },

      afterAttributeName: function () {
        var char = this.peek();

        if (utils$6.isSpace(char)) {
          this.consume();
          return;
        } else if (char === "/") {
          this.delegate.beginAttributeValue(false);
          this.delegate.finishAttributeValue();
          this.consume();
          this.state = 'selfClosingStartTag';
        } else if (char === "=") {
          this.consume();
          this.state = 'beforeAttributeValue';
        } else if (char === ">") {
          this.delegate.beginAttributeValue(false);
          this.delegate.finishAttributeValue();
          this.consume();
          this.delegate.finishTag();
          this.state = 'beforeData';
        } else {
          this.delegate.beginAttributeValue(false);
          this.delegate.finishAttributeValue();
          this.consume();
          this.state = 'attributeName';
          this.delegate.beginAttribute();
          this.delegate.appendToAttributeName(char);
        }
      },

      beforeAttributeValue: function () {
        var char = this.peek();

        if (utils$6.isSpace(char)) {
          this.consume();
        } else if (char === '"') {
          this.state = 'attributeValueDoubleQuoted';
          this.delegate.beginAttributeValue(true);
          this.consume();
        } else if (char === "'") {
          this.state = 'attributeValueSingleQuoted';
          this.delegate.beginAttributeValue(true);
          this.consume();
        } else if (char === ">") {
          this.delegate.beginAttributeValue(false);
          this.delegate.finishAttributeValue();
          this.consume();
          this.delegate.finishTag();
          this.state = 'beforeData';
        } else {
          this.state = 'attributeValueUnquoted';
          this.delegate.beginAttributeValue(false);
          this.consume();
          this.delegate.appendToAttributeValue(char);
        }
      },

      attributeValueDoubleQuoted: function () {
        var char = this.consume();

        if (char === '"') {
          this.delegate.finishAttributeValue();
          this.state = 'afterAttributeValueQuoted';
        } else if (char === "&") {
          this.delegate.appendToAttributeValue(this.consumeCharRef('"') || "&");
        } else {
          this.delegate.appendToAttributeValue(char);
        }
      },

      attributeValueSingleQuoted: function () {
        var char = this.consume();

        if (char === "'") {
          this.delegate.finishAttributeValue();
          this.state = 'afterAttributeValueQuoted';
        } else if (char === "&") {
          this.delegate.appendToAttributeValue(this.consumeCharRef("'") || "&");
        } else {
          this.delegate.appendToAttributeValue(char);
        }
      },

      attributeValueUnquoted: function () {
        var char = this.peek();

        if (utils$6.isSpace(char)) {
          this.delegate.finishAttributeValue();
          this.consume();
          this.state = 'beforeAttributeName';
        } else if (char === "&") {
          this.consume();
          this.delegate.appendToAttributeValue(this.consumeCharRef(">") || "&");
        } else if (char === ">") {
          this.delegate.finishAttributeValue();
          this.consume();
          this.delegate.finishTag();
          this.state = 'beforeData';
        } else {
          this.consume();
          this.delegate.appendToAttributeValue(char);
        }
      },

      afterAttributeValueQuoted: function () {
        var char = this.peek();

        if (utils$6.isSpace(char)) {
          this.consume();
          this.state = 'beforeAttributeName';
        } else if (char === "/") {
          this.consume();
          this.state = 'selfClosingStartTag';
        } else if (char === ">") {
          this.consume();
          this.delegate.finishTag();
          this.state = 'beforeData';
        } else {
          this.state = 'beforeAttributeName';
        }
      },

      selfClosingStartTag: function () {
        var char = this.peek();

        if (char === ">") {
          this.consume();
          this.delegate.markTagAsSelfClosing();
          this.delegate.finishTag();
          this.state = 'beforeData';
        } else {
          this.state = 'beforeAttributeName';
        }
      },

      endTagOpen: function () {
        var char = this.consume();

        if (utils$6.isAlpha(char)) {
          this.state = 'tagName';
          this.delegate.beginEndTag();
          this.delegate.appendToTagName(char.toLowerCase());
        }
      }
    }
  };

  exports.default = EventedTokenizer;
  module.exports = exports.default;

  });

  unwrapExports(eventedTokenizer);

  var entityParser = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  function EntityParser(named) {
    this.named = named;
  }

  var HEXCHARCODE = /^#[xX]([A-Fa-f0-9]+)$/;
  var CHARCODE = /^#([0-9]+)$/;
  var NAMED = /^([A-Za-z0-9]+)$/;

  EntityParser.prototype.parse = function (entity) {
    if (!entity) {
      return;
    }
    var matches = entity.match(HEXCHARCODE);
    if (matches) {
      return String.fromCharCode(parseInt(matches[1], 16));
    }
    matches = entity.match(CHARCODE);
    if (matches) {
      return String.fromCharCode(parseInt(matches[1], 10));
    }
    matches = entity.match(NAMED);
    if (matches) {
      return this.named[matches[1]];
    }
  };

  exports.default = EntityParser;
  module.exports = exports.default;

  });

  unwrapExports(entityParser);

  var html5NamedCharRefs = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.default = {
    Aacute: "Á", aacute: "á", Abreve: "Ă", abreve: "ă", ac: "∾", acd: "∿", acE: "∾̳", Acirc: "Â", acirc: "â", acute: "´", Acy: "А", acy: "а", AElig: "Æ", aelig: "æ", af: "\u2061", Afr: "𝔄", afr: "𝔞", Agrave: "À", agrave: "à", alefsym: "ℵ", aleph: "ℵ", Alpha: "Α", alpha: "α", Amacr: "Ā", amacr: "ā", amalg: "⨿", AMP: "&", amp: "&", And: "⩓", and: "∧", andand: "⩕", andd: "⩜", andslope: "⩘", andv: "⩚", ang: "∠", ange: "⦤", angle: "∠", angmsd: "∡", angmsdaa: "⦨", angmsdab: "⦩", angmsdac: "⦪", angmsdad: "⦫", angmsdae: "⦬", angmsdaf: "⦭", angmsdag: "⦮", angmsdah: "⦯", angrt: "∟", angrtvb: "⊾", angrtvbd: "⦝", angsph: "∢", angst: "Å", angzarr: "⍼", Aogon: "Ą", aogon: "ą", Aopf: "𝔸", aopf: "𝕒", ap: "≈", apacir: "⩯", apE: "⩰", ape: "≊", apid: "≋", apos: "'", ApplyFunction: "\u2061", approx: "≈", approxeq: "≊", Aring: "Å", aring: "å", Ascr: "𝒜", ascr: "𝒶", Assign: "≔", ast: "*", asymp: "≈", asympeq: "≍", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", awconint: "∳", awint: "⨑", backcong: "≌", backepsilon: "϶", backprime: "‵", backsim: "∽", backsimeq: "⋍", Backslash: "∖", Barv: "⫧", barvee: "⊽", Barwed: "⌆", barwed: "⌅", barwedge: "⌅", bbrk: "⎵", bbrktbrk: "⎶", bcong: "≌", Bcy: "Б", bcy: "б", bdquo: "„", becaus: "∵", Because: "∵", because: "∵", bemptyv: "⦰", bepsi: "϶", bernou: "ℬ", Bernoullis: "ℬ", Beta: "Β", beta: "β", beth: "ℶ", between: "≬", Bfr: "𝔅", bfr: "𝔟", bigcap: "⋂", bigcirc: "◯", bigcup: "⋃", bigodot: "⨀", bigoplus: "⨁", bigotimes: "⨂", bigsqcup: "⨆", bigstar: "★", bigtriangledown: "▽", bigtriangleup: "△", biguplus: "⨄", bigvee: "⋁", bigwedge: "⋀", bkarow: "⤍", blacklozenge: "⧫", blacksquare: "▪", blacktriangle: "▴", blacktriangledown: "▾", blacktriangleleft: "◂", blacktriangleright: "▸", blank: "␣", blk12: "▒", blk14: "░", blk34: "▓", block: "█", bne: "=⃥", bnequiv: "≡⃥", bNot: "⫭", bnot: "⌐", Bopf: "𝔹", bopf: "𝕓", bot: "⊥", bottom: "⊥", bowtie: "⋈", boxbox: "⧉", boxDL: "╗", boxDl: "╖", boxdL: "╕", boxdl: "┐", boxDR: "╔", boxDr: "╓", boxdR: "╒", boxdr: "┌", boxH: "═", boxh: "─", boxHD: "╦", boxHd: "╤", boxhD: "╥", boxhd: "┬", boxHU: "╩", boxHu: "╧", boxhU: "╨", boxhu: "┴", boxminus: "⊟", boxplus: "⊞", boxtimes: "⊠", boxUL: "╝", boxUl: "╜", boxuL: "╛", boxul: "┘", boxUR: "╚", boxUr: "╙", boxuR: "╘", boxur: "└", boxV: "║", boxv: "│", boxVH: "╬", boxVh: "╫", boxvH: "╪", boxvh: "┼", boxVL: "╣", boxVl: "╢", boxvL: "╡", boxvl: "┤", boxVR: "╠", boxVr: "╟", boxvR: "╞", boxvr: "├", bprime: "‵", Breve: "˘", breve: "˘", brvbar: "¦", Bscr: "ℬ", bscr: "𝒷", bsemi: "⁏", bsim: "∽", bsime: "⋍", bsol: "\\", bsolb: "⧅", bsolhsub: "⟈", bull: "•", bullet: "•", bump: "≎", bumpE: "⪮", bumpe: "≏", Bumpeq: "≎", bumpeq: "≏", Cacute: "Ć", cacute: "ć", Cap: "⋒", cap: "∩", capand: "⩄", capbrcup: "⩉", capcap: "⩋", capcup: "⩇", capdot: "⩀", CapitalDifferentialD: "ⅅ", caps: "∩︀", caret: "⁁", caron: "ˇ", Cayleys: "ℭ", ccaps: "⩍", Ccaron: "Č", ccaron: "č", Ccedil: "Ç", ccedil: "ç", Ccirc: "Ĉ", ccirc: "ĉ", Cconint: "∰", ccups: "⩌", ccupssm: "⩐", Cdot: "Ċ", cdot: "ċ", cedil: "¸", Cedilla: "¸", cemptyv: "⦲", cent: "¢", CenterDot: "·", centerdot: "·", Cfr: "ℭ", cfr: "𝔠", CHcy: "Ч", chcy: "ч", check: "✓", checkmark: "✓", Chi: "Χ", chi: "χ", cir: "○", circ: "ˆ", circeq: "≗", circlearrowleft: "↺", circlearrowright: "↻", circledast: "⊛", circledcirc: "⊚", circleddash: "⊝", CircleDot: "⊙", circledR: "®", circledS: "Ⓢ", CircleMinus: "⊖", CirclePlus: "⊕", CircleTimes: "⊗", cirE: "⧃", cire: "≗", cirfnint: "⨐", cirmid: "⫯", cirscir: "⧂", ClockwiseContourIntegral: "∲", CloseCurlyDoubleQuote: "”", CloseCurlyQuote: "’", clubs: "♣", clubsuit: "♣", Colon: "∷", colon: ":", Colone: "⩴", colone: "≔", coloneq: "≔", comma: ",", commat: "@", comp: "∁", compfn: "∘", complement: "∁", complexes: "ℂ", cong: "≅", congdot: "⩭", Congruent: "≡", Conint: "∯", conint: "∮", ContourIntegral: "∮", Copf: "ℂ", copf: "𝕔", coprod: "∐", Coproduct: "∐", COPY: "©", copy: "©", copysr: "℗", CounterClockwiseContourIntegral: "∳", crarr: "↵", Cross: "⨯", cross: "✗", Cscr: "𝒞", cscr: "𝒸", csub: "⫏", csube: "⫑", csup: "⫐", csupe: "⫒", ctdot: "⋯", cudarrl: "⤸", cudarrr: "⤵", cuepr: "⋞", cuesc: "⋟", cularr: "↶", cularrp: "⤽", Cup: "⋓", cup: "∪", cupbrcap: "⩈", CupCap: "≍", cupcap: "⩆", cupcup: "⩊", cupdot: "⊍", cupor: "⩅", cups: "∪︀", curarr: "↷", curarrm: "⤼", curlyeqprec: "⋞", curlyeqsucc: "⋟", curlyvee: "⋎", curlywedge: "⋏", curren: "¤", curvearrowleft: "↶", curvearrowright: "↷", cuvee: "⋎", cuwed: "⋏", cwconint: "∲", cwint: "∱", cylcty: "⌭", Dagger: "‡", dagger: "†", daleth: "ℸ", Darr: "↡", dArr: "⇓", darr: "↓", dash: "‐", Dashv: "⫤", dashv: "⊣", dbkarow: "⤏", dblac: "˝", Dcaron: "Ď", dcaron: "ď", Dcy: "Д", dcy: "д", DD: "ⅅ", dd: "ⅆ", ddagger: "‡", ddarr: "⇊", DDotrahd: "⤑", ddotseq: "⩷", deg: "°", Del: "∇", Delta: "Δ", delta: "δ", demptyv: "⦱", dfisht: "⥿", Dfr: "𝔇", dfr: "𝔡", dHar: "⥥", dharl: "⇃", dharr: "⇂", DiacriticalAcute: "´", DiacriticalDot: "˙", DiacriticalDoubleAcute: "˝", DiacriticalGrave: "`", DiacriticalTilde: "˜", diam: "⋄", Diamond: "⋄", diamond: "⋄", diamondsuit: "♦", diams: "♦", die: "¨", DifferentialD: "ⅆ", digamma: "ϝ", disin: "⋲", div: "÷", divide: "÷", divideontimes: "⋇", divonx: "⋇", DJcy: "Ђ", djcy: "ђ", dlcorn: "⌞", dlcrop: "⌍", dollar: "$", Dopf: "𝔻", dopf: "𝕕", Dot: "¨", dot: "˙", DotDot: "⃜", doteq: "≐", doteqdot: "≑", DotEqual: "≐", dotminus: "∸", dotplus: "∔", dotsquare: "⊡", doublebarwedge: "⌆", DoubleContourIntegral: "∯", DoubleDot: "¨", DoubleDownArrow: "⇓", DoubleLeftArrow: "⇐", DoubleLeftRightArrow: "⇔", DoubleLeftTee: "⫤", DoubleLongLeftArrow: "⟸", DoubleLongLeftRightArrow: "⟺", DoubleLongRightArrow: "⟹", DoubleRightArrow: "⇒", DoubleRightTee: "⊨", DoubleUpArrow: "⇑", DoubleUpDownArrow: "⇕", DoubleVerticalBar: "∥", DownArrow: "↓", Downarrow: "⇓", downarrow: "↓", DownArrowBar: "⤓", DownArrowUpArrow: "⇵", DownBreve: "̑", downdownarrows: "⇊", downharpoonleft: "⇃", downharpoonright: "⇂", DownLeftRightVector: "⥐", DownLeftTeeVector: "⥞", DownLeftVector: "↽", DownLeftVectorBar: "⥖", DownRightTeeVector: "⥟", DownRightVector: "⇁", DownRightVectorBar: "⥗", DownTee: "⊤", DownTeeArrow: "↧", drbkarow: "⤐", drcorn: "⌟", drcrop: "⌌", Dscr: "𝒟", dscr: "𝒹", DScy: "Ѕ", dscy: "ѕ", dsol: "⧶", Dstrok: "Đ", dstrok: "đ", dtdot: "⋱", dtri: "▿", dtrif: "▾", duarr: "⇵", duhar: "⥯", dwangle: "⦦", DZcy: "Џ", dzcy: "џ", dzigrarr: "⟿", Eacute: "É", eacute: "é", easter: "⩮", Ecaron: "Ě", ecaron: "ě", ecir: "≖", Ecirc: "Ê", ecirc: "ê", ecolon: "≕", Ecy: "Э", ecy: "э", eDDot: "⩷", Edot: "Ė", eDot: "≑", edot: "ė", ee: "ⅇ", efDot: "≒", Efr: "𝔈", efr: "𝔢", eg: "⪚", Egrave: "È", egrave: "è", egs: "⪖", egsdot: "⪘", el: "⪙", Element: "∈", elinters: "⏧", ell: "ℓ", els: "⪕", elsdot: "⪗", Emacr: "Ē", emacr: "ē", empty: "∅", emptyset: "∅", EmptySmallSquare: "◻", emptyv: "∅", EmptyVerySmallSquare: "▫", emsp: " ", emsp13: " ", emsp14: " ", ENG: "Ŋ", eng: "ŋ", ensp: " ", Eogon: "Ę", eogon: "ę", Eopf: "𝔼", eopf: "𝕖", epar: "⋕", eparsl: "⧣", eplus: "⩱", epsi: "ε", Epsilon: "Ε", epsilon: "ε", epsiv: "ϵ", eqcirc: "≖", eqcolon: "≕", eqsim: "≂", eqslantgtr: "⪖", eqslantless: "⪕", Equal: "⩵", equals: "=", EqualTilde: "≂", equest: "≟", Equilibrium: "⇌", equiv: "≡", equivDD: "⩸", eqvparsl: "⧥", erarr: "⥱", erDot: "≓", Escr: "ℰ", escr: "ℯ", esdot: "≐", Esim: "⩳", esim: "≂", Eta: "Η", eta: "η", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", euro: "€", excl: "!", exist: "∃", Exists: "∃", expectation: "ℰ", ExponentialE: "ⅇ", exponentiale: "ⅇ", fallingdotseq: "≒", Fcy: "Ф", fcy: "ф", female: "♀", ffilig: "ﬃ", fflig: "ﬀ", ffllig: "ﬄ", Ffr: "𝔉", ffr: "𝔣", filig: "ﬁ", FilledSmallSquare: "◼", FilledVerySmallSquare: "▪", fjlig: "fj", flat: "♭", fllig: "ﬂ", fltns: "▱", fnof: "ƒ", Fopf: "𝔽", fopf: "𝕗", ForAll: "∀", forall: "∀", fork: "⋔", forkv: "⫙", Fouriertrf: "ℱ", fpartint: "⨍", frac12: "½", frac13: "⅓", frac14: "¼", frac15: "⅕", frac16: "⅙", frac18: "⅛", frac23: "⅔", frac25: "⅖", frac34: "¾", frac35: "⅗", frac38: "⅜", frac45: "⅘", frac56: "⅚", frac58: "⅝", frac78: "⅞", frasl: "⁄", frown: "⌢", Fscr: "ℱ", fscr: "𝒻", gacute: "ǵ", Gamma: "Γ", gamma: "γ", Gammad: "Ϝ", gammad: "ϝ", gap: "⪆", Gbreve: "Ğ", gbreve: "ğ", Gcedil: "Ģ", Gcirc: "Ĝ", gcirc: "ĝ", Gcy: "Г", gcy: "г", Gdot: "Ġ", gdot: "ġ", gE: "≧", ge: "≥", gEl: "⪌", gel: "⋛", geq: "≥", geqq: "≧", geqslant: "⩾", ges: "⩾", gescc: "⪩", gesdot: "⪀", gesdoto: "⪂", gesdotol: "⪄", gesl: "⋛︀", gesles: "⪔", Gfr: "𝔊", gfr: "𝔤", Gg: "⋙", gg: "≫", ggg: "⋙", gimel: "ℷ", GJcy: "Ѓ", gjcy: "ѓ", gl: "≷", gla: "⪥", glE: "⪒", glj: "⪤", gnap: "⪊", gnapprox: "⪊", gnE: "≩", gne: "⪈", gneq: "⪈", gneqq: "≩", gnsim: "⋧", Gopf: "𝔾", gopf: "𝕘", grave: "`", GreaterEqual: "≥", GreaterEqualLess: "⋛", GreaterFullEqual: "≧", GreaterGreater: "⪢", GreaterLess: "≷", GreaterSlantEqual: "⩾", GreaterTilde: "≳", Gscr: "𝒢", gscr: "ℊ", gsim: "≳", gsime: "⪎", gsiml: "⪐", GT: ">", Gt: "≫", gt: ">", gtcc: "⪧", gtcir: "⩺", gtdot: "⋗", gtlPar: "⦕", gtquest: "⩼", gtrapprox: "⪆", gtrarr: "⥸", gtrdot: "⋗", gtreqless: "⋛", gtreqqless: "⪌", gtrless: "≷", gtrsim: "≳", gvertneqq: "≩︀", gvnE: "≩︀", Hacek: "ˇ", hairsp: " ", half: "½", hamilt: "ℋ", HARDcy: "Ъ", hardcy: "ъ", hArr: "⇔", harr: "↔", harrcir: "⥈", harrw: "↭", Hat: "^", hbar: "ℏ", Hcirc: "Ĥ", hcirc: "ĥ", hearts: "♥", heartsuit: "♥", hellip: "…", hercon: "⊹", Hfr: "ℌ", hfr: "𝔥", HilbertSpace: "ℋ", hksearow: "⤥", hkswarow: "⤦", hoarr: "⇿", homtht: "∻", hookleftarrow: "↩", hookrightarrow: "↪", Hopf: "ℍ", hopf: "𝕙", horbar: "―", HorizontalLine: "─", Hscr: "ℋ", hscr: "𝒽", hslash: "ℏ", Hstrok: "Ħ", hstrok: "ħ", HumpDownHump: "≎", HumpEqual: "≏", hybull: "⁃", hyphen: "‐", Iacute: "Í", iacute: "í", ic: "\u2063", Icirc: "Î", icirc: "î", Icy: "И", icy: "и", Idot: "İ", IEcy: "Е", iecy: "е", iexcl: "¡", iff: "⇔", Ifr: "ℑ", ifr: "𝔦", Igrave: "Ì", igrave: "ì", ii: "ⅈ", iiiint: "⨌", iiint: "∭", iinfin: "⧜", iiota: "℩", IJlig: "Ĳ", ijlig: "ĳ", Im: "ℑ", Imacr: "Ī", imacr: "ī", image: "ℑ", ImaginaryI: "ⅈ", imagline: "ℐ", imagpart: "ℑ", imath: "ı", imof: "⊷", imped: "Ƶ", Implies: "⇒", in: "∈", incare: "℅", infin: "∞", infintie: "⧝", inodot: "ı", Int: "∬", int: "∫", intcal: "⊺", integers: "ℤ", Integral: "∫", intercal: "⊺", Intersection: "⋂", intlarhk: "⨗", intprod: "⨼", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "Ё", iocy: "ё", Iogon: "Į", iogon: "į", Iopf: "𝕀", iopf: "𝕚", Iota: "Ι", iota: "ι", iprod: "⨼", iquest: "¿", Iscr: "ℐ", iscr: "𝒾", isin: "∈", isindot: "⋵", isinE: "⋹", isins: "⋴", isinsv: "⋳", isinv: "∈", it: "\u2062", Itilde: "Ĩ", itilde: "ĩ", Iukcy: "І", iukcy: "і", Iuml: "Ï", iuml: "ï", Jcirc: "Ĵ", jcirc: "ĵ", Jcy: "Й", jcy: "й", Jfr: "𝔍", jfr: "𝔧", jmath: "ȷ", Jopf: "𝕁", jopf: "𝕛", Jscr: "𝒥", jscr: "𝒿", Jsercy: "Ј", jsercy: "ј", Jukcy: "Є", jukcy: "є", Kappa: "Κ", kappa: "κ", kappav: "ϰ", Kcedil: "Ķ", kcedil: "ķ", Kcy: "К", kcy: "к", Kfr: "𝔎", kfr: "𝔨", kgreen: "ĸ", KHcy: "Х", khcy: "х", KJcy: "Ќ", kjcy: "ќ", Kopf: "𝕂", kopf: "𝕜", Kscr: "𝒦", kscr: "𝓀", lAarr: "⇚", Lacute: "Ĺ", lacute: "ĺ", laemptyv: "⦴", lagran: "ℒ", Lambda: "Λ", lambda: "λ", Lang: "⟪", lang: "⟨", langd: "⦑", langle: "⟨", lap: "⪅", Laplacetrf: "ℒ", laquo: "«", Larr: "↞", lArr: "⇐", larr: "←", larrb: "⇤", larrbfs: "⤟", larrfs: "⤝", larrhk: "↩", larrlp: "↫", larrpl: "⤹", larrsim: "⥳", larrtl: "↢", lat: "⪫", lAtail: "⤛", latail: "⤙", late: "⪭", lates: "⪭︀", lBarr: "⤎", lbarr: "⤌", lbbrk: "❲", lbrace: "{", lbrack: "[", lbrke: "⦋", lbrksld: "⦏", lbrkslu: "⦍", Lcaron: "Ľ", lcaron: "ľ", Lcedil: "Ļ", lcedil: "ļ", lceil: "⌈", lcub: "{", Lcy: "Л", lcy: "л", ldca: "⤶", ldquo: "“", ldquor: "„", ldrdhar: "⥧", ldrushar: "⥋", ldsh: "↲", lE: "≦", le: "≤", LeftAngleBracket: "⟨", LeftArrow: "←", Leftarrow: "⇐", leftarrow: "←", LeftArrowBar: "⇤", LeftArrowRightArrow: "⇆", leftarrowtail: "↢", LeftCeiling: "⌈", LeftDoubleBracket: "⟦", LeftDownTeeVector: "⥡", LeftDownVector: "⇃", LeftDownVectorBar: "⥙", LeftFloor: "⌊", leftharpoondown: "↽", leftharpoonup: "↼", leftleftarrows: "⇇", LeftRightArrow: "↔", Leftrightarrow: "⇔", leftrightarrow: "↔", leftrightarrows: "⇆", leftrightharpoons: "⇋", leftrightsquigarrow: "↭", LeftRightVector: "⥎", LeftTee: "⊣", LeftTeeArrow: "↤", LeftTeeVector: "⥚", leftthreetimes: "⋋", LeftTriangle: "⊲", LeftTriangleBar: "⧏", LeftTriangleEqual: "⊴", LeftUpDownVector: "⥑", LeftUpTeeVector: "⥠", LeftUpVector: "↿", LeftUpVectorBar: "⥘", LeftVector: "↼", LeftVectorBar: "⥒", lEg: "⪋", leg: "⋚", leq: "≤", leqq: "≦", leqslant: "⩽", les: "⩽", lescc: "⪨", lesdot: "⩿", lesdoto: "⪁", lesdotor: "⪃", lesg: "⋚︀", lesges: "⪓", lessapprox: "⪅", lessdot: "⋖", lesseqgtr: "⋚", lesseqqgtr: "⪋", LessEqualGreater: "⋚", LessFullEqual: "≦", LessGreater: "≶", lessgtr: "≶", LessLess: "⪡", lesssim: "≲", LessSlantEqual: "⩽", LessTilde: "≲", lfisht: "⥼", lfloor: "⌊", Lfr: "𝔏", lfr: "𝔩", lg: "≶", lgE: "⪑", lHar: "⥢", lhard: "↽", lharu: "↼", lharul: "⥪", lhblk: "▄", LJcy: "Љ", ljcy: "љ", Ll: "⋘", ll: "≪", llarr: "⇇", llcorner: "⌞", Lleftarrow: "⇚", llhard: "⥫", lltri: "◺", Lmidot: "Ŀ", lmidot: "ŀ", lmoust: "⎰", lmoustache: "⎰", lnap: "⪉", lnapprox: "⪉", lnE: "≨", lne: "⪇", lneq: "⪇", lneqq: "≨", lnsim: "⋦", loang: "⟬", loarr: "⇽", lobrk: "⟦", LongLeftArrow: "⟵", Longleftarrow: "⟸", longleftarrow: "⟵", LongLeftRightArrow: "⟷", Longleftrightarrow: "⟺", longleftrightarrow: "⟷", longmapsto: "⟼", LongRightArrow: "⟶", Longrightarrow: "⟹", longrightarrow: "⟶", looparrowleft: "↫", looparrowright: "↬", lopar: "⦅", Lopf: "𝕃", lopf: "𝕝", loplus: "⨭", lotimes: "⨴", lowast: "∗", lowbar: "_", LowerLeftArrow: "↙", LowerRightArrow: "↘", loz: "◊", lozenge: "◊", lozf: "⧫", lpar: "(", lparlt: "⦓", lrarr: "⇆", lrcorner: "⌟", lrhar: "⇋", lrhard: "⥭", lrm: "\u200e", lrtri: "⊿", lsaquo: "‹", Lscr: "ℒ", lscr: "𝓁", Lsh: "↰", lsh: "↰", lsim: "≲", lsime: "⪍", lsimg: "⪏", lsqb: "[", lsquo: "‘", lsquor: "‚", Lstrok: "Ł", lstrok: "ł", LT: "<", Lt: "≪", lt: "<", ltcc: "⪦", ltcir: "⩹", ltdot: "⋖", lthree: "⋋", ltimes: "⋉", ltlarr: "⥶", ltquest: "⩻", ltri: "◃", ltrie: "⊴", ltrif: "◂", ltrPar: "⦖", lurdshar: "⥊", luruhar: "⥦", lvertneqq: "≨︀", lvnE: "≨︀", macr: "¯", male: "♂", malt: "✠", maltese: "✠", Map: "⤅", map: "↦", mapsto: "↦", mapstodown: "↧", mapstoleft: "↤", mapstoup: "↥", marker: "▮", mcomma: "⨩", Mcy: "М", mcy: "м", mdash: "—", mDDot: "∺", measuredangle: "∡", MediumSpace: " ", Mellintrf: "ℳ", Mfr: "𝔐", mfr: "𝔪", mho: "℧", micro: "µ", mid: "∣", midast: "*", midcir: "⫰", middot: "·", minus: "−", minusb: "⊟", minusd: "∸", minusdu: "⨪", MinusPlus: "∓", mlcp: "⫛", mldr: "…", mnplus: "∓", models: "⊧", Mopf: "𝕄", mopf: "𝕞", mp: "∓", Mscr: "ℳ", mscr: "𝓂", mstpos: "∾", Mu: "Μ", mu: "μ", multimap: "⊸", mumap: "⊸", nabla: "∇", Nacute: "Ń", nacute: "ń", nang: "∠⃒", nap: "≉", napE: "⩰̸", napid: "≋̸", napos: "ŉ", napprox: "≉", natur: "♮", natural: "♮", naturals: "ℕ", nbsp: " ", nbump: "≎̸", nbumpe: "≏̸", ncap: "⩃", Ncaron: "Ň", ncaron: "ň", Ncedil: "Ņ", ncedil: "ņ", ncong: "≇", ncongdot: "⩭̸", ncup: "⩂", Ncy: "Н", ncy: "н", ndash: "–", ne: "≠", nearhk: "⤤", neArr: "⇗", nearr: "↗", nearrow: "↗", nedot: "≐̸", NegativeMediumSpace: "​", NegativeThickSpace: "​", NegativeThinSpace: "​", NegativeVeryThinSpace: "​", nequiv: "≢", nesear: "⤨", nesim: "≂̸", NestedGreaterGreater: "≫", NestedLessLess: "≪", NewLine: "\u000a", nexist: "∄", nexists: "∄", Nfr: "𝔑", nfr: "𝔫", ngE: "≧̸", nge: "≱", ngeq: "≱", ngeqq: "≧̸", ngeqslant: "⩾̸", nges: "⩾̸", nGg: "⋙̸", ngsim: "≵", nGt: "≫⃒", ngt: "≯", ngtr: "≯", nGtv: "≫̸", nhArr: "⇎", nharr: "↮", nhpar: "⫲", ni: "∋", nis: "⋼", nisd: "⋺", niv: "∋", NJcy: "Њ", njcy: "њ", nlArr: "⇍", nlarr: "↚", nldr: "‥", nlE: "≦̸", nle: "≰", nLeftarrow: "⇍", nleftarrow: "↚", nLeftrightarrow: "⇎", nleftrightarrow: "↮", nleq: "≰", nleqq: "≦̸", nleqslant: "⩽̸", nles: "⩽̸", nless: "≮", nLl: "⋘̸", nlsim: "≴", nLt: "≪⃒", nlt: "≮", nltri: "⋪", nltrie: "⋬", nLtv: "≪̸", nmid: "∤", NoBreak: "\u2060", NonBreakingSpace: " ", Nopf: "ℕ", nopf: "𝕟", Not: "⫬", not: "¬", NotCongruent: "≢", NotCupCap: "≭", NotDoubleVerticalBar: "∦", NotElement: "∉", NotEqual: "≠", NotEqualTilde: "≂̸", NotExists: "∄", NotGreater: "≯", NotGreaterEqual: "≱", NotGreaterFullEqual: "≧̸", NotGreaterGreater: "≫̸", NotGreaterLess: "≹", NotGreaterSlantEqual: "⩾̸", NotGreaterTilde: "≵", NotHumpDownHump: "≎̸", NotHumpEqual: "≏̸", notin: "∉", notindot: "⋵̸", notinE: "⋹̸", notinva: "∉", notinvb: "⋷", notinvc: "⋶", NotLeftTriangle: "⋪", NotLeftTriangleBar: "⧏̸", NotLeftTriangleEqual: "⋬", NotLess: "≮", NotLessEqual: "≰", NotLessGreater: "≸", NotLessLess: "≪̸", NotLessSlantEqual: "⩽̸", NotLessTilde: "≴", NotNestedGreaterGreater: "⪢̸", NotNestedLessLess: "⪡̸", notni: "∌", notniva: "∌", notnivb: "⋾", notnivc: "⋽", NotPrecedes: "⊀", NotPrecedesEqual: "⪯̸", NotPrecedesSlantEqual: "⋠", NotReverseElement: "∌", NotRightTriangle: "⋫", NotRightTriangleBar: "⧐̸", NotRightTriangleEqual: "⋭", NotSquareSubset: "⊏̸", NotSquareSubsetEqual: "⋢", NotSquareSuperset: "⊐̸", NotSquareSupersetEqual: "⋣", NotSubset: "⊂⃒", NotSubsetEqual: "⊈", NotSucceeds: "⊁", NotSucceedsEqual: "⪰̸", NotSucceedsSlantEqual: "⋡", NotSucceedsTilde: "≿̸", NotSuperset: "⊃⃒", NotSupersetEqual: "⊉", NotTilde: "≁", NotTildeEqual: "≄", NotTildeFullEqual: "≇", NotTildeTilde: "≉", NotVerticalBar: "∤", npar: "∦", nparallel: "∦", nparsl: "⫽⃥", npart: "∂̸", npolint: "⨔", npr: "⊀", nprcue: "⋠", npre: "⪯̸", nprec: "⊀", npreceq: "⪯̸", nrArr: "⇏", nrarr: "↛", nrarrc: "⤳̸", nrarrw: "↝̸", nRightarrow: "⇏", nrightarrow: "↛", nrtri: "⋫", nrtrie: "⋭", nsc: "⊁", nsccue: "⋡", nsce: "⪰̸", Nscr: "𝒩", nscr: "𝓃", nshortmid: "∤", nshortparallel: "∦", nsim: "≁", nsime: "≄", nsimeq: "≄", nsmid: "∤", nspar: "∦", nsqsube: "⋢", nsqsupe: "⋣", nsub: "⊄", nsubE: "⫅̸", nsube: "⊈", nsubset: "⊂⃒", nsubseteq: "⊈", nsubseteqq: "⫅̸", nsucc: "⊁", nsucceq: "⪰̸", nsup: "⊅", nsupE: "⫆̸", nsupe: "⊉", nsupset: "⊃⃒", nsupseteq: "⊉", nsupseteqq: "⫆̸", ntgl: "≹", Ntilde: "Ñ", ntilde: "ñ", ntlg: "≸", ntriangleleft: "⋪", ntrianglelefteq: "⋬", ntriangleright: "⋫", ntrianglerighteq: "⋭", Nu: "Ν", nu: "ν", num: "#", numero: "№", numsp: " ", nvap: "≍⃒", nVDash: "⊯", nVdash: "⊮", nvDash: "⊭", nvdash: "⊬", nvge: "≥⃒", nvgt: ">⃒", nvHarr: "⤄", nvinfin: "⧞", nvlArr: "⤂", nvle: "≤⃒", nvlt: "<⃒", nvltrie: "⊴⃒", nvrArr: "⤃", nvrtrie: "⊵⃒", nvsim: "∼⃒", nwarhk: "⤣", nwArr: "⇖", nwarr: "↖", nwarrow: "↖", nwnear: "⤧", Oacute: "Ó", oacute: "ó", oast: "⊛", ocir: "⊚", Ocirc: "Ô", ocirc: "ô", Ocy: "О", ocy: "о", odash: "⊝", Odblac: "Ő", odblac: "ő", odiv: "⨸", odot: "⊙", odsold: "⦼", OElig: "Œ", oelig: "œ", ofcir: "⦿", Ofr: "𝔒", ofr: "𝔬", ogon: "˛", Ograve: "Ò", ograve: "ò", ogt: "⧁", ohbar: "⦵", ohm: "Ω", oint: "∮", olarr: "↺", olcir: "⦾", olcross: "⦻", oline: "‾", olt: "⧀", Omacr: "Ō", omacr: "ō", Omega: "Ω", omega: "ω", Omicron: "Ο", omicron: "ο", omid: "⦶", ominus: "⊖", Oopf: "𝕆", oopf: "𝕠", opar: "⦷", OpenCurlyDoubleQuote: "“", OpenCurlyQuote: "‘", operp: "⦹", oplus: "⊕", Or: "⩔", or: "∨", orarr: "↻", ord: "⩝", order: "ℴ", orderof: "ℴ", ordf: "ª", ordm: "º", origof: "⊶", oror: "⩖", orslope: "⩗", orv: "⩛", oS: "Ⓢ", Oscr: "𝒪", oscr: "ℴ", Oslash: "Ø", oslash: "ø", osol: "⊘", Otilde: "Õ", otilde: "õ", Otimes: "⨷", otimes: "⊗", otimesas: "⨶", Ouml: "Ö", ouml: "ö", ovbar: "⌽", OverBar: "‾", OverBrace: "⏞", OverBracket: "⎴", OverParenthesis: "⏜", par: "∥", para: "¶", parallel: "∥", parsim: "⫳", parsl: "⫽", part: "∂", PartialD: "∂", Pcy: "П", pcy: "п", percnt: "%", period: ".", permil: "‰", perp: "⊥", pertenk: "‱", Pfr: "𝔓", pfr: "𝔭", Phi: "Φ", phi: "φ", phiv: "ϕ", phmmat: "ℳ", phone: "☎", Pi: "Π", pi: "π", pitchfork: "⋔", piv: "ϖ", planck: "ℏ", planckh: "ℎ", plankv: "ℏ", plus: "+", plusacir: "⨣", plusb: "⊞", pluscir: "⨢", plusdo: "∔", plusdu: "⨥", pluse: "⩲", PlusMinus: "±", plusmn: "±", plussim: "⨦", plustwo: "⨧", pm: "±", Poincareplane: "ℌ", pointint: "⨕", Popf: "ℙ", popf: "𝕡", pound: "£", Pr: "⪻", pr: "≺", prap: "⪷", prcue: "≼", prE: "⪳", pre: "⪯", prec: "≺", precapprox: "⪷", preccurlyeq: "≼", Precedes: "≺", PrecedesEqual: "⪯", PrecedesSlantEqual: "≼", PrecedesTilde: "≾", preceq: "⪯", precnapprox: "⪹", precneqq: "⪵", precnsim: "⋨", precsim: "≾", Prime: "″", prime: "′", primes: "ℙ", prnap: "⪹", prnE: "⪵", prnsim: "⋨", prod: "∏", Product: "∏", profalar: "⌮", profline: "⌒", profsurf: "⌓", prop: "∝", Proportion: "∷", Proportional: "∝", propto: "∝", prsim: "≾", prurel: "⊰", Pscr: "𝒫", pscr: "𝓅", Psi: "Ψ", psi: "ψ", puncsp: " ", Qfr: "𝔔", qfr: "𝔮", qint: "⨌", Qopf: "ℚ", qopf: "𝕢", qprime: "⁗", Qscr: "𝒬", qscr: "𝓆", quaternions: "ℍ", quatint: "⨖", quest: "?", questeq: "≟", QUOT: "\"", quot: "\"", rAarr: "⇛", race: "∽̱", Racute: "Ŕ", racute: "ŕ", radic: "√", raemptyv: "⦳", Rang: "⟫", rang: "⟩", rangd: "⦒", range: "⦥", rangle: "⟩", raquo: "»", Rarr: "↠", rArr: "⇒", rarr: "→", rarrap: "⥵", rarrb: "⇥", rarrbfs: "⤠", rarrc: "⤳", rarrfs: "⤞", rarrhk: "↪", rarrlp: "↬", rarrpl: "⥅", rarrsim: "⥴", Rarrtl: "⤖", rarrtl: "↣", rarrw: "↝", rAtail: "⤜", ratail: "⤚", ratio: "∶", rationals: "ℚ", RBarr: "⤐", rBarr: "⤏", rbarr: "⤍", rbbrk: "❳", rbrace: "}", rbrack: "]", rbrke: "⦌", rbrksld: "⦎", rbrkslu: "⦐", Rcaron: "Ř", rcaron: "ř", Rcedil: "Ŗ", rcedil: "ŗ", rceil: "⌉", rcub: "}", Rcy: "Р", rcy: "р", rdca: "⤷", rdldhar: "⥩", rdquo: "”", rdquor: "”", rdsh: "↳", Re: "ℜ", real: "ℜ", realine: "ℛ", realpart: "ℜ", reals: "ℝ", rect: "▭", REG: "®", reg: "®", ReverseElement: "∋", ReverseEquilibrium: "⇋", ReverseUpEquilibrium: "⥯", rfisht: "⥽", rfloor: "⌋", Rfr: "ℜ", rfr: "𝔯", rHar: "⥤", rhard: "⇁", rharu: "⇀", rharul: "⥬", Rho: "Ρ", rho: "ρ", rhov: "ϱ", RightAngleBracket: "⟩", RightArrow: "→", Rightarrow: "⇒", rightarrow: "→", RightArrowBar: "⇥", RightArrowLeftArrow: "⇄", rightarrowtail: "↣", RightCeiling: "⌉", RightDoubleBracket: "⟧", RightDownTeeVector: "⥝", RightDownVector: "⇂", RightDownVectorBar: "⥕", RightFloor: "⌋", rightharpoondown: "⇁", rightharpoonup: "⇀", rightleftarrows: "⇄", rightleftharpoons: "⇌", rightrightarrows: "⇉", rightsquigarrow: "↝", RightTee: "⊢", RightTeeArrow: "↦", RightTeeVector: "⥛", rightthreetimes: "⋌", RightTriangle: "⊳", RightTriangleBar: "⧐", RightTriangleEqual: "⊵", RightUpDownVector: "⥏", RightUpTeeVector: "⥜", RightUpVector: "↾", RightUpVectorBar: "⥔", RightVector: "⇀", RightVectorBar: "⥓", ring: "˚", risingdotseq: "≓", rlarr: "⇄", rlhar: "⇌", rlm: "\u200f", rmoust: "⎱", rmoustache: "⎱", rnmid: "⫮", roang: "⟭", roarr: "⇾", robrk: "⟧", ropar: "⦆", Ropf: "ℝ", ropf: "𝕣", roplus: "⨮", rotimes: "⨵", RoundImplies: "⥰", rpar: ")", rpargt: "⦔", rppolint: "⨒", rrarr: "⇉", Rrightarrow: "⇛", rsaquo: "›", Rscr: "ℛ", rscr: "𝓇", Rsh: "↱", rsh: "↱", rsqb: "]", rsquo: "’", rsquor: "’", rthree: "⋌", rtimes: "⋊", rtri: "▹", rtrie: "⊵", rtrif: "▸", rtriltri: "⧎", RuleDelayed: "⧴", ruluhar: "⥨", rx: "℞", Sacute: "Ś", sacute: "ś", sbquo: "‚", Sc: "⪼", sc: "≻", scap: "⪸", Scaron: "Š", scaron: "š", sccue: "≽", scE: "⪴", sce: "⪰", Scedil: "Ş", scedil: "ş", Scirc: "Ŝ", scirc: "ŝ", scnap: "⪺", scnE: "⪶", scnsim: "⋩", scpolint: "⨓", scsim: "≿", Scy: "С", scy: "с", sdot: "⋅", sdotb: "⊡", sdote: "⩦", searhk: "⤥", seArr: "⇘", searr: "↘", searrow: "↘", sect: "§", semi: ";", seswar: "⤩", setminus: "∖", setmn: "∖", sext: "✶", Sfr: "𝔖", sfr: "𝔰", sfrown: "⌢", sharp: "♯", SHCHcy: "Щ", shchcy: "щ", SHcy: "Ш", shcy: "ш", ShortDownArrow: "↓", ShortLeftArrow: "←", shortmid: "∣", shortparallel: "∥", ShortRightArrow: "→", ShortUpArrow: "↑", shy: "\u00ad", Sigma: "Σ", sigma: "σ", sigmaf: "ς", sigmav: "ς", sim: "∼", simdot: "⩪", sime: "≃", simeq: "≃", simg: "⪞", simgE: "⪠", siml: "⪝", simlE: "⪟", simne: "≆", simplus: "⨤", simrarr: "⥲", slarr: "←", SmallCircle: "∘", smallsetminus: "∖", smashp: "⨳", smeparsl: "⧤", smid: "∣", smile: "⌣", smt: "⪪", smte: "⪬", smtes: "⪬︀", SOFTcy: "Ь", softcy: "ь", sol: "/", solb: "⧄", solbar: "⌿", Sopf: "𝕊", sopf: "𝕤", spades: "♠", spadesuit: "♠", spar: "∥", sqcap: "⊓", sqcaps: "⊓︀", sqcup: "⊔", sqcups: "⊔︀", Sqrt: "√", sqsub: "⊏", sqsube: "⊑", sqsubset: "⊏", sqsubseteq: "⊑", sqsup: "⊐", sqsupe: "⊒", sqsupset: "⊐", sqsupseteq: "⊒", squ: "□", Square: "□", square: "□", SquareIntersection: "⊓", SquareSubset: "⊏", SquareSubsetEqual: "⊑", SquareSuperset: "⊐", SquareSupersetEqual: "⊒", SquareUnion: "⊔", squarf: "▪", squf: "▪", srarr: "→", Sscr: "𝒮", sscr: "𝓈", ssetmn: "∖", ssmile: "⌣", sstarf: "⋆", Star: "⋆", star: "☆", starf: "★", straightepsilon: "ϵ", straightphi: "ϕ", strns: "¯", Sub: "⋐", sub: "⊂", subdot: "⪽", subE: "⫅", sube: "⊆", subedot: "⫃", submult: "⫁", subnE: "⫋", subne: "⊊", subplus: "⪿", subrarr: "⥹", Subset: "⋐", subset: "⊂", subseteq: "⊆", subseteqq: "⫅", SubsetEqual: "⊆", subsetneq: "⊊", subsetneqq: "⫋", subsim: "⫇", subsub: "⫕", subsup: "⫓", succ: "≻", succapprox: "⪸", succcurlyeq: "≽", Succeeds: "≻", SucceedsEqual: "⪰", SucceedsSlantEqual: "≽", SucceedsTilde: "≿", succeq: "⪰", succnapprox: "⪺", succneqq: "⪶", succnsim: "⋩", succsim: "≿", SuchThat: "∋", Sum: "∑", sum: "∑", sung: "♪", Sup: "⋑", sup: "⊃", sup1: "¹", sup2: "²", sup3: "³", supdot: "⪾", supdsub: "⫘", supE: "⫆", supe: "⊇", supedot: "⫄", Superset: "⊃", SupersetEqual: "⊇", suphsol: "⟉", suphsub: "⫗", suplarr: "⥻", supmult: "⫂", supnE: "⫌", supne: "⊋", supplus: "⫀", Supset: "⋑", supset: "⊃", supseteq: "⊇", supseteqq: "⫆", supsetneq: "⊋", supsetneqq: "⫌", supsim: "⫈", supsub: "⫔", supsup: "⫖", swarhk: "⤦", swArr: "⇙", swarr: "↙", swarrow: "↙", swnwar: "⤪", szlig: "ß", Tab: "\u0009", target: "⌖", Tau: "Τ", tau: "τ", tbrk: "⎴", Tcaron: "Ť", tcaron: "ť", Tcedil: "Ţ", tcedil: "ţ", Tcy: "Т", tcy: "т", tdot: "⃛", telrec: "⌕", Tfr: "𝔗", tfr: "𝔱", there4: "∴", Therefore: "∴", therefore: "∴", Theta: "Θ", theta: "θ", thetasym: "ϑ", thetav: "ϑ", thickapprox: "≈", thicksim: "∼", ThickSpace: "  ", thinsp: " ", ThinSpace: " ", thkap: "≈", thksim: "∼", THORN: "Þ", thorn: "þ", Tilde: "∼", tilde: "˜", TildeEqual: "≃", TildeFullEqual: "≅", TildeTilde: "≈", times: "×", timesb: "⊠", timesbar: "⨱", timesd: "⨰", tint: "∭", toea: "⤨", top: "⊤", topbot: "⌶", topcir: "⫱", Topf: "𝕋", topf: "𝕥", topfork: "⫚", tosa: "⤩", tprime: "‴", TRADE: "™", trade: "™", triangle: "▵", triangledown: "▿", triangleleft: "◃", trianglelefteq: "⊴", triangleq: "≜", triangleright: "▹", trianglerighteq: "⊵", tridot: "◬", trie: "≜", triminus: "⨺", TripleDot: "⃛", triplus: "⨹", trisb: "⧍", tritime: "⨻", trpezium: "⏢", Tscr: "𝒯", tscr: "𝓉", TScy: "Ц", tscy: "ц", TSHcy: "Ћ", tshcy: "ћ", Tstrok: "Ŧ", tstrok: "ŧ", twixt: "≬", twoheadleftarrow: "↞", twoheadrightarrow: "↠", Uacute: "Ú", uacute: "ú", Uarr: "↟", uArr: "⇑", uarr: "↑", Uarrocir: "⥉", Ubrcy: "Ў", ubrcy: "ў", Ubreve: "Ŭ", ubreve: "ŭ", Ucirc: "Û", ucirc: "û", Ucy: "У", ucy: "у", udarr: "⇅", Udblac: "Ű", udblac: "ű", udhar: "⥮", ufisht: "⥾", Ufr: "𝔘", ufr: "𝔲", Ugrave: "Ù", ugrave: "ù", uHar: "⥣", uharl: "↿", uharr: "↾", uhblk: "▀", ulcorn: "⌜", ulcorner: "⌜", ulcrop: "⌏", ultri: "◸", Umacr: "Ū", umacr: "ū", uml: "¨", UnderBar: "_", UnderBrace: "⏟", UnderBracket: "⎵", UnderParenthesis: "⏝", Union: "⋃", UnionPlus: "⊎", Uogon: "Ų", uogon: "ų", Uopf: "𝕌", uopf: "𝕦", UpArrow: "↑", Uparrow: "⇑", uparrow: "↑", UpArrowBar: "⤒", UpArrowDownArrow: "⇅", UpDownArrow: "↕", Updownarrow: "⇕", updownarrow: "↕", UpEquilibrium: "⥮", upharpoonleft: "↿", upharpoonright: "↾", uplus: "⊎", UpperLeftArrow: "↖", UpperRightArrow: "↗", Upsi: "ϒ", upsi: "υ", upsih: "ϒ", Upsilon: "Υ", upsilon: "υ", UpTee: "⊥", UpTeeArrow: "↥", upuparrows: "⇈", urcorn: "⌝", urcorner: "⌝", urcrop: "⌎", Uring: "Ů", uring: "ů", urtri: "◹", Uscr: "𝒰", uscr: "𝓊", utdot: "⋰", Utilde: "Ũ", utilde: "ũ", utri: "▵", utrif: "▴", uuarr: "⇈", Uuml: "Ü", uuml: "ü", uwangle: "⦧", vangrt: "⦜", varepsilon: "ϵ", varkappa: "ϰ", varnothing: "∅", varphi: "ϕ", varpi: "ϖ", varpropto: "∝", vArr: "⇕", varr: "↕", varrho: "ϱ", varsigma: "ς", varsubsetneq: "⊊︀", varsubsetneqq: "⫋︀", varsupsetneq: "⊋︀", varsupsetneqq: "⫌︀", vartheta: "ϑ", vartriangleleft: "⊲", vartriangleright: "⊳", Vbar: "⫫", vBar: "⫨", vBarv: "⫩", Vcy: "В", vcy: "в", VDash: "⊫", Vdash: "⊩", vDash: "⊨", vdash: "⊢", Vdashl: "⫦", Vee: "⋁", vee: "∨", veebar: "⊻", veeeq: "≚", vellip: "⋮", Verbar: "‖", verbar: "|", Vert: "‖", vert: "|", VerticalBar: "∣", VerticalLine: "|", VerticalSeparator: "❘", VerticalTilde: "≀", VeryThinSpace: " ", Vfr: "𝔙", vfr: "𝔳", vltri: "⊲", vnsub: "⊂⃒", vnsup: "⊃⃒", Vopf: "𝕍", vopf: "𝕧", vprop: "∝", vrtri: "⊳", Vscr: "𝒱", vscr: "𝓋", vsubnE: "⫋︀", vsubne: "⊊︀", vsupnE: "⫌︀", vsupne: "⊋︀", Vvdash: "⊪", vzigzag: "⦚", Wcirc: "Ŵ", wcirc: "ŵ", wedbar: "⩟", Wedge: "⋀", wedge: "∧", wedgeq: "≙", weierp: "℘", Wfr: "𝔚", wfr: "𝔴", Wopf: "𝕎", wopf: "𝕨", wp: "℘", wr: "≀", wreath: "≀", Wscr: "𝒲", wscr: "𝓌", xcap: "⋂", xcirc: "◯", xcup: "⋃", xdtri: "▽", Xfr: "𝔛", xfr: "𝔵", xhArr: "⟺", xharr: "⟷", Xi: "Ξ", xi: "ξ", xlArr: "⟸", xlarr: "⟵", xmap: "⟼", xnis: "⋻", xodot: "⨀", Xopf: "𝕏", xopf: "𝕩", xoplus: "⨁", xotime: "⨂", xrArr: "⟹", xrarr: "⟶", Xscr: "𝒳", xscr: "𝓍", xsqcup: "⨆", xuplus: "⨄", xutri: "△", xvee: "⋁", xwedge: "⋀", Yacute: "Ý", yacute: "ý", YAcy: "Я", yacy: "я", Ycirc: "Ŷ", ycirc: "ŷ", Ycy: "Ы", ycy: "ы", yen: "¥", Yfr: "𝔜", yfr: "𝔶", YIcy: "Ї", yicy: "ї", Yopf: "𝕐", yopf: "𝕪", Yscr: "𝒴", yscr: "𝓎", YUcy: "Ю", yucy: "ю", Yuml: "Ÿ", yuml: "ÿ", Zacute: "Ź", zacute: "ź", Zcaron: "Ž", zcaron: "ž", Zcy: "З", zcy: "з", Zdot: "Ż", zdot: "ż", zeetrf: "ℨ", ZeroWidthSpace: "​", Zeta: "Ζ", zeta: "ζ", Zfr: "ℨ", zfr: "𝔷", ZHcy: "Ж", zhcy: "ж", zigrarr: "⇝", Zopf: "ℤ", zopf: "𝕫", Zscr: "𝒵", zscr: "𝓏", zwj: "\u200d", zwnj: "\u200c"
  };
  module.exports = exports.default;

  });

  unwrapExports(html5NamedCharRefs);

  var utils$8 = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.parseComponentBlockParams = parseComponentBlockParams;
  exports.childrenFor = childrenFor;
  exports.appendChild = appendChild;
  exports.isHelper = isHelper;
  exports.unwrapMustache = unwrapMustache;



  // Regex to validate the identifier for block parameters.
  // Based on the ID validation regex in Handlebars.

  var ID_INVERSE_PATTERN = /[!"#%-,\.\/;->@\[-\^`\{-~]/;

  // Checks the component's attributes to see if it uses block params.
  // If it does, registers the block params with the program and
  // removes the corresponding attributes from the element.

  function parseComponentBlockParams(element, program) {
    var l = element.attributes.length;
    var attrNames = [];

    for (var i = 0; i < l; i++) {
      attrNames.push(element.attributes[i].name);
    }

    var asIndex = arrayUtils.indexOfArray(attrNames, 'as');

    if (asIndex !== -1 && l > asIndex && attrNames[asIndex + 1].charAt(0) === '|') {
      // Some basic validation, since we're doing the parsing ourselves
      var paramsString = attrNames.slice(asIndex).join(' ');
      if (paramsString.charAt(paramsString.length - 1) !== '|' || paramsString.match(/\|/g).length !== 2) {
        throw new Error('Invalid block parameters syntax: \'' + paramsString + '\'');
      }

      var params = [];
      for (i = asIndex + 1; i < l; i++) {
        var param = attrNames[i].replace(/\|/g, '');
        if (param !== '') {
          if (ID_INVERSE_PATTERN.test(param)) {
            throw new Error('Invalid identifier for block parameters: \'' + param + '\' in \'' + paramsString + '\'');
          }
          params.push(param);
        }
      }

      if (params.length === 0) {
        throw new Error('Cannot use zero block parameters: \'' + paramsString + '\'');
      }

      element.attributes = element.attributes.slice(0, asIndex);
      program.blockParams = params;
    }
  }

  function childrenFor(node) {
    if (node.type === 'Program') {
      return node.body;
    }
    if (node.type === 'ElementNode') {
      return node.children;
    }
  }

  function appendChild(parent, node) {
    childrenFor(parent).push(node);
  }

  function isHelper(mustache) {
    return mustache.params && mustache.params.length > 0 || mustache.hash && mustache.hash.pairs.length > 0;
  }

  function unwrapMustache(mustache) {
    if (isHelper(mustache)) {
      return mustache;
    } else {
      return mustache.path;
    }
  }

  });

  unwrapExports(utils$8);
  var utils_1$4 = utils$8.parseComponentBlockParams;
  var utils_2$4 = utils$8.childrenFor;
  var utils_3$3 = utils$8.appendChild;
  var utils_4$2 = utils$8.isHelper;
  var utils_5$2 = utils$8.unwrapMustache;

  var handlebarsNodeVisitors = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }



  var _builders2 = _interopRequireDefault(builders);



  exports.default = {

    Program: function (program) {
      var body = [];
      var node = _builders2.default.program(body, program.blockParams, program.loc);
      var i,
          l = program.body.length;

      this.elementStack.push(node);

      if (l === 0) {
        return this.elementStack.pop();
      }

      for (i = 0; i < l; i++) {
        this.acceptNode(program.body[i]);
      }

      // Ensure that that the element stack is balanced properly.
      var poppedNode = this.elementStack.pop();
      if (poppedNode !== node) {
        throw new Error("Unclosed element `" + poppedNode.tag + "` (on line " + poppedNode.loc.start.line + ").");
      }

      return node;
    },

    BlockStatement: function (block) {
      delete block.inverseStrip;
      delete block.openString;
      delete block.closeStrip;

      if (this.tokenizer.state === 'comment') {
        this.appendToCommentData('{{' + this.sourceForMustache(block) + '}}');
        return;
      }

      if (this.tokenizer.state !== 'comment' && this.tokenizer.state !== 'data' && this.tokenizer.state !== 'beforeData') {
        throw new Error("A block may only be used inside an HTML element or another block.");
      }

      block = acceptCommonNodes(this, block);
      var program = block.program ? this.acceptNode(block.program) : null;
      var inverse = block.inverse ? this.acceptNode(block.inverse) : null;

      var node = _builders2.default.block(block.path, block.params, block.hash, program, inverse, block.loc);
      var parentProgram = this.currentElement();
      utils$8.appendChild(parentProgram, node);
    },

    MustacheStatement: function (rawMustache) {
      var tokenizer = this.tokenizer;
      var path = rawMustache.path;
      var params = rawMustache.params;
      var hash = rawMustache.hash;
      var escaped = rawMustache.escaped;
      var loc = rawMustache.loc;

      var mustache = _builders2.default.mustache(path, params, hash, !escaped, loc);

      if (tokenizer.state === 'comment') {
        this.appendToCommentData('{{' + this.sourceForMustache(mustache) + '}}');
        return;
      }

      acceptCommonNodes(this, mustache);

      switch (tokenizer.state) {
        // Tag helpers
        case "tagName":
          addElementModifier(this.currentNode, mustache);
          tokenizer.state = "beforeAttributeName";
          break;
        case "beforeAttributeName":
          addElementModifier(this.currentNode, mustache);
          break;
        case "attributeName":
        case "afterAttributeName":
          this.beginAttributeValue(false);
          this.finishAttributeValue();
          addElementModifier(this.currentNode, mustache);
          tokenizer.state = "beforeAttributeName";
          break;
        case "afterAttributeValueQuoted":
          addElementModifier(this.currentNode, mustache);
          tokenizer.state = "beforeAttributeName";
          break;

        // Attribute values
        case "beforeAttributeValue":
          appendDynamicAttributeValuePart(this.currentAttribute, mustache);
          tokenizer.state = 'attributeValueUnquoted';
          break;
        case "attributeValueDoubleQuoted":
        case "attributeValueSingleQuoted":
        case "attributeValueUnquoted":
          appendDynamicAttributeValuePart(this.currentAttribute, mustache);
          break;

        // TODO: Only append child when the tokenizer state makes
        // sense to do so, otherwise throw an error.
        default:
          utils$8.appendChild(this.currentElement(), mustache);
      }

      return mustache;
    },

    ContentStatement: function (content) {
      updateTokenizerLocation(this.tokenizer, content);

      this.tokenizer.tokenizePart(content.value);
      this.tokenizer.flushData();
    },

    CommentStatement: function (comment) {
      return comment;
    },

    PartialStatement: function (partial) {
      utils$8.appendChild(this.currentElement(), partial);
      return partial;
    },

    SubExpression: function (sexpr) {
      return acceptCommonNodes(this, sexpr);
    },

    PathExpression: function (path) {
      delete path.data;
      delete path.depth;

      return path;
    },

    Hash: function (hash) {
      for (var i = 0; i < hash.pairs.length; i++) {
        this.acceptNode(hash.pairs[i].value);
      }

      return hash;
    },

    StringLiteral: function () {},
    BooleanLiteral: function () {},
    NumberLiteral: function () {},
    UndefinedLiteral: function () {},
    NullLiteral: function () {}
  };

  function calculateRightStrippedOffsets(original, value) {
    if (value === '') {
      // if it is empty, just return the count of newlines
      // in original
      return {
        lines: original.split("\n").length - 1,
        columns: 0
      };
    }

    // otherwise, return the number of newlines prior to
    // `value`
    var difference = original.split(value)[0];
    var lines = difference.split(/\n/);
    var lineCount = lines.length - 1;

    return {
      lines: lineCount,
      columns: lines[lineCount].length
    };
  }

  function updateTokenizerLocation(tokenizer, content) {
    var line = content.loc.start.line;
    var column = content.loc.start.column;

    if (content.rightStripped) {
      var offsets = calculateRightStrippedOffsets(content.original, content.value);

      line = line + offsets.lines;
      if (offsets.lines) {
        column = offsets.columns;
      } else {
        column = column + offsets.columns;
      }
    }

    tokenizer.line = line;
    tokenizer.column = column;
  }

  function acceptCommonNodes(compiler, node) {
    compiler.acceptNode(node.path);

    if (node.params) {
      for (var i = 0; i < node.params.length; i++) {
        compiler.acceptNode(node.params[i]);
      }
    } else {
      node.params = [];
    }

    if (node.hash) {
      compiler.acceptNode(node.hash);
    } else {
      node.hash = _builders2.default.hash();
    }

    return node;
  }

  function addElementModifier(element, mustache) {
    var path = mustache.path;
    var params = mustache.params;
    var hash = mustache.hash;
    var loc = mustache.loc;

    var modifier = _builders2.default.elementModifier(path, params, hash, loc);
    element.modifiers.push(modifier);
  }

  function appendDynamicAttributeValuePart(attribute, part) {
    attribute.isDynamic = true;
    attribute.parts.push(part);
  }
  module.exports = exports.default;

  });

  unwrapExports(handlebarsNodeVisitors);

  var tokenizerEventHandlers = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }



  var _htmlbarsUtilVoidTagNames2 = _interopRequireDefault(voidTagNames_1);



  var _builders2 = _interopRequireDefault(builders);



  exports.default = {
    reset: function () {
      this.currentNode = null;
    },

    // Comment

    beginComment: function () {
      this.currentNode = _builders2.default.comment("");
      this.currentNode.loc = {
        source: null,
        start: _builders2.default.pos(this.tagOpenLine, this.tagOpenColumn),
        end: null
      };
    },

    appendToCommentData: function (char) {
      this.currentNode.value += char;
    },

    finishComment: function () {
      this.currentNode.loc.end = _builders2.default.pos(this.tokenizer.line, this.tokenizer.column);

      utils$8.appendChild(this.currentElement(), this.currentNode);
    },

    // Data

    beginData: function () {
      this.currentNode = _builders2.default.text();
      this.currentNode.loc = {
        source: null,
        start: _builders2.default.pos(this.tokenizer.line, this.tokenizer.column),
        end: null
      };
    },

    appendToData: function (char) {
      this.currentNode.chars += char;
    },

    finishData: function () {
      this.currentNode.loc.end = _builders2.default.pos(this.tokenizer.line, this.tokenizer.column);

      utils$8.appendChild(this.currentElement(), this.currentNode);
    },

    // Tags - basic

    tagOpen: function () {
      this.tagOpenLine = this.tokenizer.line;
      this.tagOpenColumn = this.tokenizer.column;
    },

    beginStartTag: function () {
      this.currentNode = {
        type: 'StartTag',
        name: "",
        attributes: [],
        modifiers: [],
        selfClosing: false,
        loc: null
      };
    },

    beginEndTag: function () {
      this.currentNode = {
        type: 'EndTag',
        name: "",
        attributes: [],
        modifiers: [],
        selfClosing: false,
        loc: null
      };
    },

    finishTag: function () {
      var _tokenizer = this.tokenizer;
      var line = _tokenizer.line;
      var column = _tokenizer.column;

      var tag = this.currentNode;
      tag.loc = _builders2.default.loc(this.tagOpenLine, this.tagOpenColumn, line, column);

      if (tag.type === 'StartTag') {
        this.finishStartTag();

        if (_htmlbarsUtilVoidTagNames2.default.hasOwnProperty(tag.name) || tag.selfClosing) {
          this.finishEndTag(true);
        }
      } else if (tag.type === 'EndTag') {
        this.finishEndTag(false);
      }
    },

    finishStartTag: function () {
      var _currentNode = this.currentNode;
      var name = _currentNode.name;
      var attributes = _currentNode.attributes;
      var modifiers = _currentNode.modifiers;

      validateStartTag(this.currentNode, this.tokenizer);

      var loc = _builders2.default.loc(this.tagOpenLine, this.tagOpenColumn);
      var element = _builders2.default.element(name, attributes, modifiers, [], loc);
      this.elementStack.push(element);
    },

    finishEndTag: function (isVoid) {
      var tag = this.currentNode;

      var element = this.elementStack.pop();
      var parent = this.currentElement();
      var disableComponentGeneration = this.options.disableComponentGeneration === true;

      validateEndTag(tag, element, isVoid);

      element.loc.end.line = this.tokenizer.line;
      element.loc.end.column = this.tokenizer.column;

      if (disableComponentGeneration || cannotBeComponent(element.tag)) {
        utils$8.appendChild(parent, element);
      } else {
        var program = _builders2.default.program(element.children);
        utils$8.parseComponentBlockParams(element, program);
        var component = _builders2.default.component(element.tag, element.attributes, program, element.loc);
        utils$8.appendChild(parent, component);
      }
    },

    markTagAsSelfClosing: function () {
      this.currentNode.selfClosing = true;
    },

    // Tags - name

    appendToTagName: function (char) {
      this.currentNode.name += char;
    },

    // Tags - attributes

    beginAttribute: function () {
      var tag = this.currentNode;
      if (tag.type === 'EndTag') {
        throw new Error("Invalid end tag: closing tag must not have attributes, " + ("in `" + tag.name + "` (on line " + this.tokenizer.line + ")."));
      }

      this.currentAttribute = {
        name: "",
        parts: [],
        isQuoted: false,
        isDynamic: false,
        // beginAttribute isn't called until after the first char is consumed
        start: _builders2.default.pos(this.tokenizer.line, this.tokenizer.column),
        valueStartLine: null,
        valueStartColumn: null
      };
    },

    appendToAttributeName: function (char) {
      this.currentAttribute.name += char;
    },

    beginAttributeValue: function (isQuoted) {
      this.currentAttribute.isQuoted = isQuoted;
      this.currentAttribute.valueStartLine = this.tokenizer.line;
      this.currentAttribute.valueStartColumn = this.tokenizer.column;
    },

    appendToAttributeValue: function (char) {
      var parts = this.currentAttribute.parts;

      if (typeof parts[parts.length - 1] === 'string') {
        parts[parts.length - 1] += char;
      } else {
        parts.push(char);
      }
    },

    finishAttributeValue: function () {
      var _currentAttribute = this.currentAttribute;
      var name = _currentAttribute.name;
      var parts = _currentAttribute.parts;
      var isQuoted = _currentAttribute.isQuoted;
      var isDynamic = _currentAttribute.isDynamic;
      var valueStartLine = _currentAttribute.valueStartLine;
      var valueStartColumn = _currentAttribute.valueStartColumn;

      var value = assembleAttributeValue(parts, isQuoted, isDynamic, this.tokenizer.line);
      value.loc = _builders2.default.loc(valueStartLine, valueStartColumn, this.tokenizer.line, this.tokenizer.column);

      var loc = _builders2.default.loc(this.currentAttribute.start.line, this.currentAttribute.start.column, this.tokenizer.line, this.tokenizer.column);

      var attribute = _builders2.default.attr(name, value, loc);

      this.currentNode.attributes.push(attribute);
    }
  };

  function assembleAttributeValue(parts, isQuoted, isDynamic, line) {
    if (isDynamic) {
      if (isQuoted) {
        return assembleConcatenatedValue(parts);
      } else {
        if (parts.length === 1 || parts.length === 2 && parts[1] === '/') {
          return parts[0];
        } else {
          throw new Error("An unquoted attribute value must be a string or a mustache, " + "preceeded by whitespace or a '=' character, and " + ("followed by whitespace, a '>' character or a '/>' (on line " + line + ")"));
        }
      }
    } else {
      return _builders2.default.text(parts.length > 0 ? parts[0] : "");
    }
  }

  function assembleConcatenatedValue(parts) {
    for (var i = 0; i < parts.length; i++) {
      var part = parts[i];

      if (typeof part === 'string') {
        parts[i] = _builders2.default.string(parts[i]);
      } else {
        if (part.type === 'MustacheStatement') {
          parts[i] = utils$8.unwrapMustache(part);
        } else {
          throw new Error("Unsupported node in quoted attribute value: " + part.type);
        }
      }
    }

    return _builders2.default.concat(parts);
  }

  function cannotBeComponent(tagName) {
    return tagName.indexOf("-") === -1 && tagName.indexOf(".") === -1;
  }

  function validateStartTag(tag, tokenizer) {
    // No support for <script> tags
    if (tag.name === "script") {
      throw new Error("`SCRIPT` tags are not allowed in HTMLBars templates (on line " + tokenizer.tagLine + ")");
    }
  }

  function validateEndTag(tag, element, selfClosing) {
    if (_htmlbarsUtilVoidTagNames2.default[tag.name] && !selfClosing) {
      // EngTag is also called by StartTag for void and self-closing tags (i.e.
      // <input> or <br />, so we need to check for that here. Otherwise, we would
      // throw an error for those cases.
      throw new Error("Invalid end tag " + formatEndTagInfo(tag) + " (void elements cannot have end tags).");
    } else if (element.tag === undefined) {
      throw new Error("Closing tag " + formatEndTagInfo(tag) + " without an open tag.");
    } else if (element.tag !== tag.name) {
      throw new Error("Closing tag " + formatEndTagInfo(tag) + " did not match last open tag `" + element.tag + "` (on line " + element.loc.start.line + ").");
    }
  }

  function formatEndTagInfo(tag) {
    return "`" + tag.name + "` (on line " + tag.loc.end.line + ")";
  }
  module.exports = exports.default;

  });

  unwrapExports(tokenizerEventHandlers);

  var parser$2 = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.preprocess = preprocess;
  exports.Parser = Parser;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }





  var syntax = _interopRequireWildcard(htmlbarsSyntax);



  var _simpleHtmlTokenizerEventedTokenizer2 = _interopRequireDefault(eventedTokenizer);



  var _simpleHtmlTokenizerEntityParser2 = _interopRequireDefault(entityParser);



  var _simpleHtmlTokenizerHtml5NamedCharRefs2 = _interopRequireDefault(html5NamedCharRefs);



  var _parserHandlebarsNodeVisitors2 = _interopRequireDefault(handlebarsNodeVisitors);



  var _parserTokenizerEventHandlers2 = _interopRequireDefault(tokenizerEventHandlers);

  function preprocess(html, options) {
    var ast = typeof html === 'object' ? html : base.parse(html);
    var combined = new Parser(html, options).acceptNode(ast);

    if (options && options.plugins && options.plugins.ast) {
      for (var i = 0, l = options.plugins.ast.length; i < l; i++) {
        var plugin = new options.plugins.ast[i](options);

        plugin.syntax = syntax;

        combined = plugin.transform(combined);
      }
    }

    return combined;
  }

  exports.default = preprocess;

  var entityParser$$1 = new _simpleHtmlTokenizerEntityParser2.default(_simpleHtmlTokenizerHtml5NamedCharRefs2.default);

  function Parser(source, options) {
    this.options = options || {};
    this.elementStack = [];
    this.tokenizer = new _simpleHtmlTokenizerEventedTokenizer2.default(this, entityParser$$1);

    this.currentNode = null;
    this.currentAttribute = null;

    if (typeof source === 'string') {
      this.source = source.split(/(?:\r\n?|\n)/g);
    }
  }

  for (var key in _parserHandlebarsNodeVisitors2.default) {
    Parser.prototype[key] = _parserHandlebarsNodeVisitors2.default[key];
  }

  for (var key in _parserTokenizerEventHandlers2.default) {
    Parser.prototype[key] = _parserTokenizerEventHandlers2.default[key];
  }

  Parser.prototype.acceptNode = function (node) {
    return this[node.type](node);
  };

  Parser.prototype.currentElement = function () {
    return this.elementStack[this.elementStack.length - 1];
  };

  Parser.prototype.sourceForMustache = function (mustache) {
    var firstLine = mustache.loc.start.line - 1;
    var lastLine = mustache.loc.end.line - 1;
    var currentLine = firstLine - 1;
    var firstColumn = mustache.loc.start.column + 2;
    var lastColumn = mustache.loc.end.column - 2;
    var string = [];
    var line;

    if (!this.source) {
      return '{{' + mustache.path.id.original + '}}';
    }

    while (currentLine < lastLine) {
      currentLine++;
      line = this.source[currentLine];

      if (currentLine === firstLine) {
        if (firstLine === lastLine) {
          string.push(line.slice(firstColumn, lastColumn));
        } else {
          string.push(line.slice(firstColumn));
        }
      } else if (currentLine === lastLine) {
        string.push(line.slice(0, lastColumn));
      } else {
        string.push(line);
      }
    }

    return string.join('\n');
  };

  });

  unwrapExports(parser$2);
  var parser_1 = parser$2.preprocess;
  var parser_2 = parser$2.Parser;

  var templateVisitor = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  var push = Array.prototype.push;

  function Frame() {
    this.parentNode = null;
    this.children = null;
    this.childIndex = null;
    this.childCount = null;
    this.childTemplateCount = 0;
    this.mustacheCount = 0;
    this.actions = [];
  }

  /**
   * Takes in an AST and outputs a list of actions to be consumed
   * by a compiler. For example, the template
   *
   *     foo{{bar}}<div>baz</div>
   *
   * produces the actions
   *
   *     [['startProgram', [programNode, 0]],
   *      ['text', [textNode, 0, 3]],
   *      ['mustache', [mustacheNode, 1, 3]],
   *      ['openElement', [elementNode, 2, 3, 0]],
   *      ['text', [textNode, 0, 1]],
   *      ['closeElement', [elementNode, 2, 3],
   *      ['endProgram', [programNode]]]
   *
   * This visitor walks the AST depth first and backwards. As
   * a result the bottom-most child template will appear at the
   * top of the actions list whereas the root template will appear
   * at the bottom of the list. For example,
   *
   *     <div>{{#if}}foo{{else}}bar<b></b>{{/if}}</div>
   *
   * produces the actions
   *
   *     [['startProgram', [programNode, 0]],
   *      ['text', [textNode, 0, 2, 0]],
   *      ['openElement', [elementNode, 1, 2, 0]],
   *      ['closeElement', [elementNode, 1, 2]],
   *      ['endProgram', [programNode]],
   *      ['startProgram', [programNode, 0]],
   *      ['text', [textNode, 0, 1]],
   *      ['endProgram', [programNode]],
   *      ['startProgram', [programNode, 2]],
   *      ['openElement', [elementNode, 0, 1, 1]],
   *      ['block', [blockNode, 0, 1]],
   *      ['closeElement', [elementNode, 0, 1]],
   *      ['endProgram', [programNode]]]
   *
   * The state of the traversal is maintained by a stack of frames.
   * Whenever a node with children is entered (either a ProgramNode
   * or an ElementNode) a frame is pushed onto the stack. The frame
   * contains information about the state of the traversal of that
   * node. For example,
   *
   *   - index of the current child node being visited
   *   - the number of mustaches contained within its child nodes
   *   - the list of actions generated by its child nodes
   */

  function TemplateVisitor() {
    this.frameStack = [];
    this.actions = [];
    this.programDepth = -1;
  }

  // Traversal methods

  TemplateVisitor.prototype.visit = function (node) {
    this[node.type](node);
  };

  TemplateVisitor.prototype.Program = function (program) {
    this.programDepth++;

    var parentFrame = this.getCurrentFrame();
    var programFrame = this.pushFrame();

    programFrame.parentNode = program;
    programFrame.children = program.body;
    programFrame.childCount = program.body.length;
    programFrame.blankChildTextNodes = [];
    programFrame.actions.push(['endProgram', [program, this.programDepth]]);

    for (var i = program.body.length - 1; i >= 0; i--) {
      programFrame.childIndex = i;
      this.visit(program.body[i]);
    }

    programFrame.actions.push(['startProgram', [program, programFrame.childTemplateCount, programFrame.blankChildTextNodes.reverse()]]);
    this.popFrame();

    this.programDepth--;

    // Push the completed template into the global actions list
    if (parentFrame) {
      parentFrame.childTemplateCount++;
    }
    push.apply(this.actions, programFrame.actions.reverse());
  };

  TemplateVisitor.prototype.ElementNode = function (element) {
    var parentFrame = this.getCurrentFrame();
    var elementFrame = this.pushFrame();

    elementFrame.parentNode = element;
    elementFrame.children = element.children;
    elementFrame.childCount = element.children.length;
    elementFrame.mustacheCount += element.modifiers.length;
    elementFrame.blankChildTextNodes = [];

    var actionArgs = [element, parentFrame.childIndex, parentFrame.childCount];

    elementFrame.actions.push(['closeElement', actionArgs]);

    for (var i = element.attributes.length - 1; i >= 0; i--) {
      this.visit(element.attributes[i]);
    }

    for (i = element.children.length - 1; i >= 0; i--) {
      elementFrame.childIndex = i;
      this.visit(element.children[i]);
    }

    elementFrame.actions.push(['openElement', actionArgs.concat([elementFrame.mustacheCount, elementFrame.blankChildTextNodes.reverse()])]);
    this.popFrame();

    // Propagate the element's frame state to the parent frame
    if (elementFrame.mustacheCount > 0) {
      parentFrame.mustacheCount++;
    }
    parentFrame.childTemplateCount += elementFrame.childTemplateCount;
    push.apply(parentFrame.actions, elementFrame.actions);
  };

  TemplateVisitor.prototype.AttrNode = function (attr) {
    if (attr.value.type !== 'TextNode') {
      this.getCurrentFrame().mustacheCount++;
    }
  };

  TemplateVisitor.prototype.TextNode = function (text) {
    var frame = this.getCurrentFrame();
    if (text.chars === '') {
      frame.blankChildTextNodes.push(domIndexOf(frame.children, text));
    }
    frame.actions.push(['text', [text, frame.childIndex, frame.childCount]]);
  };

  TemplateVisitor.prototype.BlockStatement = function (node) {
    var frame = this.getCurrentFrame();

    frame.mustacheCount++;
    frame.actions.push(['block', [node, frame.childIndex, frame.childCount]]);

    if (node.inverse) {
      this.visit(node.inverse);
    }
    if (node.program) {
      this.visit(node.program);
    }
  };

  TemplateVisitor.prototype.ComponentNode = function (node) {
    var frame = this.getCurrentFrame();

    frame.mustacheCount++;
    frame.actions.push(['component', [node, frame.childIndex, frame.childCount]]);

    if (node.program) {
      this.visit(node.program);
    }
  };

  TemplateVisitor.prototype.PartialStatement = function (node) {
    var frame = this.getCurrentFrame();
    frame.mustacheCount++;
    frame.actions.push(['mustache', [node, frame.childIndex, frame.childCount]]);
  };

  TemplateVisitor.prototype.CommentStatement = function (text) {
    var frame = this.getCurrentFrame();
    frame.actions.push(['comment', [text, frame.childIndex, frame.childCount]]);
  };

  TemplateVisitor.prototype.MustacheStatement = function (mustache) {
    var frame = this.getCurrentFrame();
    frame.mustacheCount++;
    frame.actions.push(['mustache', [mustache, frame.childIndex, frame.childCount]]);
  };

  // Frame helpers

  TemplateVisitor.prototype.getCurrentFrame = function () {
    return this.frameStack[this.frameStack.length - 1];
  };

  TemplateVisitor.prototype.pushFrame = function () {
    var frame = new Frame();
    this.frameStack.push(frame);
    return frame;
  };

  TemplateVisitor.prototype.popFrame = function () {
    return this.frameStack.pop();
  };

  exports.default = TemplateVisitor;

  // Returns the index of `domNode` in the `nodes` array, skipping
  // over any nodes which do not represent DOM nodes.
  function domIndexOf(nodes, domNode) {
    var index = -1;

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];

      if (node.type !== 'TextNode' && node.type !== 'ElementNode') {
        continue;
      } else {
        index++;
      }

      if (node === domNode) {
        return index;
      }
    }

    return -1;
  }
  module.exports = exports.default;

  });

  unwrapExports(templateVisitor);

  var utils$a = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.processOpcodes = processOpcodes;

  function processOpcodes(compiler, opcodes) {
    for (var i = 0, l = opcodes.length; i < l; i++) {
      var method = opcodes[i][0];
      var params = opcodes[i][1];
      if (params) {
        compiler[method].apply(compiler, params);
      } else {
        compiler[method].call(compiler);
      }
    }
  }

  });

  unwrapExports(utils$a);
  var utils_1$5 = utils$a.processOpcodes;

  var fragmentOpcodeCompiler = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }



  var _templateVisitor2 = _interopRequireDefault(templateVisitor);







  function FragmentOpcodeCompiler() {
    this.opcodes = [];
  }

  exports.default = FragmentOpcodeCompiler;

  FragmentOpcodeCompiler.prototype.compile = function (ast) {
    var templateVisitor$$1 = new _templateVisitor2.default();
    templateVisitor$$1.visit(ast);

    utils$a.processOpcodes(this, templateVisitor$$1.actions);

    return this.opcodes;
  };

  FragmentOpcodeCompiler.prototype.opcode = function (type, params) {
    this.opcodes.push([type, params]);
  };

  FragmentOpcodeCompiler.prototype.text = function (text) {
    this.opcode('createText', [text.chars]);
    this.opcode('appendChild');
  };

  FragmentOpcodeCompiler.prototype.comment = function (comment) {
    this.opcode('createComment', [comment.value]);
    this.opcode('appendChild');
  };

  FragmentOpcodeCompiler.prototype.openElement = function (element) {
    this.opcode('createElement', [element.tag]);
    arrayUtils.forEach(element.attributes, this.attribute, this);
  };

  FragmentOpcodeCompiler.prototype.closeElement = function () {
    this.opcode('appendChild');
  };

  FragmentOpcodeCompiler.prototype.startProgram = function () {
    this.opcodes.length = 0;
    this.opcode('createFragment');
  };

  FragmentOpcodeCompiler.prototype.endProgram = function () {
    this.opcode('returnNode');
  };

  FragmentOpcodeCompiler.prototype.mustache = function () {
    this.pushMorphPlaceholderNode();
  };

  FragmentOpcodeCompiler.prototype.component = function () {
    this.pushMorphPlaceholderNode();
  };

  FragmentOpcodeCompiler.prototype.block = function () {
    this.pushMorphPlaceholderNode();
  };

  FragmentOpcodeCompiler.prototype.pushMorphPlaceholderNode = function () {
    this.opcode('createComment', [""]);
    this.opcode('appendChild');
  };

  FragmentOpcodeCompiler.prototype.attribute = function (attr) {
    if (attr.value.type === 'TextNode') {
      var namespace = htmlbarsUtil.getAttrNamespace(attr.name);
      this.opcode('setAttribute', [attr.name, attr.value.chars, namespace]);
    }
  };

  FragmentOpcodeCompiler.prototype.setNamespace = function (namespace) {
    this.opcode('setNamespace', [namespace]);
  };
  module.exports = exports.default;

  });

  unwrapExports(fragmentOpcodeCompiler);

  var quoting = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.hash = hash;
  exports.repeat = repeat;
  function escapeString(str) {
    str = str.replace(/\\/g, "\\\\");
    str = str.replace(/"/g, '\\"');
    str = str.replace(/\n/g, "\\n");
    return str;
  }

  exports.escapeString = escapeString;

  function string(str) {
    return '"' + escapeString(str) + '"';
  }

  exports.string = string;

  function array(a) {
    return "[" + a + "]";
  }

  exports.array = array;

  function hash(pairs) {
    return "{" + pairs.join(", ") + "}";
  }

  function repeat(chars, times) {
    var str = "";
    while (times--) {
      str += chars;
    }
    return str;
  }

  });

  unwrapExports(quoting);
  var quoting_1 = quoting.hash;
  var quoting_2 = quoting.repeat;
  var quoting_3 = quoting.escapeString;
  var quoting_4 = quoting.string;
  var quoting_5 = quoting.array;

  var fragmentJavascriptCompiler = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;





  var svgNamespace = "http://www.w3.org/2000/svg",

  // http://www.w3.org/html/wg/drafts/html/master/syntax.html#html-integration-point
  svgHTMLIntegrationPoints = { 'foreignObject': true, 'desc': true, 'title': true };

  function FragmentJavaScriptCompiler() {
    this.source = [];
    this.depth = -1;
  }

  exports.default = FragmentJavaScriptCompiler;

  FragmentJavaScriptCompiler.prototype.compile = function (opcodes, options) {
    this.source.length = 0;
    this.depth = -1;
    this.indent = options && options.indent || "";
    this.namespaceFrameStack = [{ namespace: null, depth: null }];
    this.domNamespace = null;

    this.source.push('function buildFragment(dom) {\n');
    utils$a.processOpcodes(this, opcodes);
    this.source.push(this.indent + '}');

    return this.source.join('');
  };

  FragmentJavaScriptCompiler.prototype.createFragment = function () {
    var el = 'el' + ++this.depth;
    this.source.push(this.indent + '  var ' + el + ' = dom.createDocumentFragment();\n');
  };

  FragmentJavaScriptCompiler.prototype.createElement = function (tagName) {
    var el = 'el' + ++this.depth;
    if (tagName === 'svg') {
      this.pushNamespaceFrame({ namespace: svgNamespace, depth: this.depth });
    }
    this.ensureNamespace();
    this.source.push(this.indent + '  var ' + el + ' = dom.createElement(' + quoting.string(tagName) + ');\n');
    if (svgHTMLIntegrationPoints[tagName]) {
      this.pushNamespaceFrame({ namespace: null, depth: this.depth });
    }
  };

  FragmentJavaScriptCompiler.prototype.createText = function (str) {
    var el = 'el' + ++this.depth;
    this.source.push(this.indent + '  var ' + el + ' = dom.createTextNode(' + quoting.string(str) + ');\n');
  };

  FragmentJavaScriptCompiler.prototype.createComment = function (str) {
    var el = 'el' + ++this.depth;
    this.source.push(this.indent + '  var ' + el + ' = dom.createComment(' + quoting.string(str) + ');\n');
  };

  FragmentJavaScriptCompiler.prototype.returnNode = function () {
    var el = 'el' + this.depth;
    this.source.push(this.indent + '  return ' + el + ';\n');
  };

  FragmentJavaScriptCompiler.prototype.setAttribute = function (name, value, namespace) {
    var el = 'el' + this.depth;
    if (namespace) {
      this.source.push(this.indent + '  dom.setAttributeNS(' + el + ',' + quoting.string(namespace) + ',' + quoting.string(name) + ',' + quoting.string(value) + ');\n');
    } else {
      this.source.push(this.indent + '  dom.setAttribute(' + el + ',' + quoting.string(name) + ',' + quoting.string(value) + ');\n');
    }
  };

  FragmentJavaScriptCompiler.prototype.appendChild = function () {
    if (this.depth === this.getCurrentNamespaceFrame().depth) {
      this.popNamespaceFrame();
    }
    var child = 'el' + this.depth--;
    var el = 'el' + this.depth;
    this.source.push(this.indent + '  dom.appendChild(' + el + ', ' + child + ');\n');
  };

  FragmentJavaScriptCompiler.prototype.getCurrentNamespaceFrame = function () {
    return this.namespaceFrameStack[this.namespaceFrameStack.length - 1];
  };

  FragmentJavaScriptCompiler.prototype.pushNamespaceFrame = function (frame) {
    this.namespaceFrameStack.push(frame);
  };

  FragmentJavaScriptCompiler.prototype.popNamespaceFrame = function () {
    return this.namespaceFrameStack.pop();
  };

  FragmentJavaScriptCompiler.prototype.ensureNamespace = function () {
    var correctNamespace = this.getCurrentNamespaceFrame().namespace;
    if (this.domNamespace !== correctNamespace) {
      this.source.push(this.indent + '  dom.setNamespace(' + (correctNamespace ? quoting.string(correctNamespace) : 'null') + ');\n');
      this.domNamespace = correctNamespace;
    }
  };
  module.exports = exports.default;

  });

  unwrapExports(fragmentJavascriptCompiler);

  var hydrationOpcodeCompiler = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }



  var _templateVisitor2 = _interopRequireDefault(templateVisitor);









  function detectIsElementChecked(element) {
    for (var i = 0, len = element.attributes.length; i < len; i++) {
      if (element.attributes[i].name === 'checked') {
        return true;
      }
    }
    return false;
  }

  function HydrationOpcodeCompiler() {
    this.opcodes = [];
    this.paths = [];
    this.templateId = 0;
    this.currentDOMChildIndex = 0;
    this.morphs = [];
    this.morphNum = 0;
    this.element = null;
    this.elementNum = -1;
  }

  exports.default = HydrationOpcodeCompiler;

  HydrationOpcodeCompiler.prototype.compile = function (ast) {
    var templateVisitor$$1 = new _templateVisitor2.default();
    templateVisitor$$1.visit(ast);

    utils$a.processOpcodes(this, templateVisitor$$1.actions);

    return this.opcodes;
  };

  HydrationOpcodeCompiler.prototype.accept = function (node) {
    this[node.type](node);
  };

  HydrationOpcodeCompiler.prototype.opcode = function (type) {
    var params = [].slice.call(arguments, 1);
    this.opcodes.push([type, params]);
  };

  HydrationOpcodeCompiler.prototype.startProgram = function (program, c, blankChildTextNodes) {
    this.opcodes.length = 0;
    this.paths.length = 0;
    this.morphs.length = 0;
    this.templateId = 0;
    this.currentDOMChildIndex = -1;
    this.morphNum = 0;

    var blockParams = program.blockParams || [];

    for (var i = 0; i < blockParams.length; i++) {
      this.opcode('printSetHook', blockParams[i], i);
    }

    if (blankChildTextNodes.length > 0) {
      this.opcode('repairClonedNode', blankChildTextNodes);
    }
  };

  HydrationOpcodeCompiler.prototype.insertBoundary = function (first) {
    this.opcode(first ? 'openBoundary' : 'closeBoundary');
  };

  HydrationOpcodeCompiler.prototype.endProgram = function () {
    distributeMorphs(this.morphs, this.opcodes);
  };

  HydrationOpcodeCompiler.prototype.text = function () {
    ++this.currentDOMChildIndex;
  };

  HydrationOpcodeCompiler.prototype.comment = function () {
    ++this.currentDOMChildIndex;
  };

  HydrationOpcodeCompiler.prototype.openElement = function (element, pos, len, mustacheCount, blankChildTextNodes) {
    distributeMorphs(this.morphs, this.opcodes);
    ++this.currentDOMChildIndex;

    this.element = this.currentDOMChildIndex;

    this.opcode('consumeParent', this.currentDOMChildIndex);

    // If our parent reference will be used more than once, cache its reference.
    if (mustacheCount > 1) {
      shareElement(this);
    }

    var isElementChecked = detectIsElementChecked(element);
    if (blankChildTextNodes.length > 0 || isElementChecked) {
      this.opcode('repairClonedNode', blankChildTextNodes, isElementChecked);
    }

    this.paths.push(this.currentDOMChildIndex);
    this.currentDOMChildIndex = -1;

    arrayUtils.forEach(element.attributes, this.attribute, this);
    arrayUtils.forEach(element.modifiers, this.elementModifier, this);
  };

  HydrationOpcodeCompiler.prototype.closeElement = function () {
    distributeMorphs(this.morphs, this.opcodes);
    this.opcode('popParent');
    this.currentDOMChildIndex = this.paths.pop();
  };

  HydrationOpcodeCompiler.prototype.mustache = function (mustache, childIndex, childCount) {
    this.pushMorphPlaceholderNode(childIndex, childCount);

    var opcode;

    if (utils$8.isHelper(mustache)) {
      prepareHash(this, mustache.hash);
      prepareParams(this, mustache.params);
      preparePath(this, mustache.path);
      opcode = 'printInlineHook';
    } else {
      preparePath(this, mustache.path);
      opcode = 'printContentHook';
    }

    var morphNum = this.morphNum++;
    var start = this.currentDOMChildIndex;
    var end = this.currentDOMChildIndex;
    this.morphs.push([morphNum, this.paths.slice(), start, end, mustache.escaped]);

    this.opcode(opcode, meta(mustache));
  };

  function meta(node) {
    var loc = node.loc;
    if (!loc) {
      return [];
    }

    var source = loc.source;
    var start = loc.start;
    var end = loc.end;

    return ['loc', [source || null, [start.line, start.column], [end.line, end.column]]];
  }

  HydrationOpcodeCompiler.prototype.block = function (block, childIndex, childCount) {
    this.pushMorphPlaceholderNode(childIndex, childCount);

    prepareHash(this, block.hash);
    prepareParams(this, block.params);
    preparePath(this, block.path);

    var morphNum = this.morphNum++;
    var start = this.currentDOMChildIndex;
    var end = this.currentDOMChildIndex;
    this.morphs.push([morphNum, this.paths.slice(), start, end, true]);

    var templateId = this.templateId++;
    var inverseId = block.inverse === null ? null : this.templateId++;

    this.opcode('printBlockHook', templateId, inverseId, meta(block));
  };

  HydrationOpcodeCompiler.prototype.component = function (component, childIndex, childCount) {
    this.pushMorphPlaceholderNode(childIndex, childCount, component.isStatic);

    var program = component.program || {};
    var blockParams = program.blockParams || [];

    var attrs = component.attributes;
    for (var i = attrs.length - 1; i >= 0; i--) {
      var name = attrs[i].name;
      var value = attrs[i].value;

      // TODO: Introduce context specific AST nodes to avoid switching here.
      if (value.type === 'TextNode') {
        this.opcode('pushLiteral', value.chars);
      } else if (value.type === 'MustacheStatement') {
        this.accept(utils$8.unwrapMustache(value));
      } else if (value.type === 'ConcatStatement') {
        prepareParams(this, value.parts);
        this.opcode('pushConcatHook', this.morphNum);
      }

      this.opcode('pushLiteral', name);
    }

    var morphNum = this.morphNum++;
    var start = this.currentDOMChildIndex;
    var end = this.currentDOMChildIndex;
    this.morphs.push([morphNum, this.paths.slice(), start, end, true]);

    this.opcode('prepareObject', attrs.length);
    this.opcode('pushLiteral', component.tag);
    this.opcode('printComponentHook', this.templateId++, blockParams.length, meta(component));
  };

  HydrationOpcodeCompiler.prototype.attribute = function (attr) {
    var value = attr.value;
    var escaped = true;
    var namespace = htmlbarsUtil.getAttrNamespace(attr.name);

    // TODO: Introduce context specific AST nodes to avoid switching here.
    if (value.type === 'TextNode') {
      return;
    } else if (value.type === 'MustacheStatement') {
      escaped = value.escaped;
      this.accept(utils$8.unwrapMustache(value));
    } else if (value.type === 'ConcatStatement') {
      prepareParams(this, value.parts);
      this.opcode('pushConcatHook', this.morphNum);
    }

    this.opcode('pushLiteral', attr.name);

    var attrMorphNum = this.morphNum++;

    if (this.element !== null) {
      shareElement(this);
    }

    this.opcode('createAttrMorph', attrMorphNum, this.elementNum, attr.name, escaped, namespace);
    this.opcode('printAttributeHook');
  };

  HydrationOpcodeCompiler.prototype.elementModifier = function (modifier) {
    prepareHash(this, modifier.hash);
    prepareParams(this, modifier.params);
    preparePath(this, modifier.path);

    // If we have a helper in a node, and this element has not been cached, cache it
    if (this.element !== null) {
      shareElement(this);
    }

    publishElementMorph(this);
    this.opcode('printElementHook', meta(modifier));
  };

  HydrationOpcodeCompiler.prototype.pushMorphPlaceholderNode = function (childIndex, childCount, skipBoundaryNodes) {
    if (!skipBoundaryNodes) {
      if (this.paths.length === 0) {
        if (childIndex === 0) {
          this.opcode('openBoundary');
        }
        if (childIndex === childCount - 1) {
          this.opcode('closeBoundary');
        }
      }
    }

    this.comment();
  };

  HydrationOpcodeCompiler.prototype.MustacheStatement = function (mustache) {
    prepareHash(this, mustache.hash);
    prepareParams(this, mustache.params);
    preparePath(this, mustache.path);
    this.opcode('pushSexprHook', meta(mustache));
  };

  HydrationOpcodeCompiler.prototype.SubExpression = function (sexpr) {
    prepareHash(this, sexpr.hash);
    prepareParams(this, sexpr.params);
    preparePath(this, sexpr.path);
    this.opcode('pushSexprHook', meta(sexpr));
  };

  HydrationOpcodeCompiler.prototype.PathExpression = function (path) {
    this.opcode('pushGetHook', path.original, meta(path));
  };

  HydrationOpcodeCompiler.prototype.StringLiteral = function (node) {
    this.opcode('pushLiteral', node.value);
  };

  HydrationOpcodeCompiler.prototype.BooleanLiteral = function (node) {
    this.opcode('pushLiteral', node.value);
  };

  HydrationOpcodeCompiler.prototype.NumberLiteral = function (node) {
    this.opcode('pushLiteral', node.value);
  };

  HydrationOpcodeCompiler.prototype.UndefinedLiteral = function (node) {
    this.opcode('pushLiteral', node.value);
  };

  HydrationOpcodeCompiler.prototype.NullLiteral = function (node) {
    this.opcode('pushLiteral', node.value);
  };

  function preparePath(compiler, path) {
    compiler.opcode('pushLiteral', path.original);
  }

  function prepareParams(compiler, params) {
    for (var i = params.length - 1; i >= 0; i--) {
      var param = params[i];
      compiler[param.type](param);
    }

    compiler.opcode('prepareArray', params.length);
  }

  function prepareHash(compiler, hash) {
    var pairs = hash.pairs;

    for (var i = pairs.length - 1; i >= 0; i--) {
      var key = pairs[i].key;
      var value = pairs[i].value;

      compiler[value.type](value);
      compiler.opcode('pushLiteral', key);
    }

    compiler.opcode('prepareObject', pairs.length);
  }

  function shareElement(compiler) {
    compiler.opcode('shareElement', ++compiler.elementNum);
    compiler.element = null; // Set element to null so we don't cache it twice
  }

  function publishElementMorph(compiler) {
    var morphNum = compiler.morphNum++;
    compiler.opcode('createElementMorph', morphNum, compiler.elementNum);
  }

  function distributeMorphs(morphs, opcodes) {
    if (morphs.length === 0) {
      return;
    }

    // Splice morphs after the most recent shareParent/consumeParent.
    var o;
    for (o = opcodes.length - 1; o >= 0; --o) {
      var opcode = opcodes[o][0];
      if (opcode === 'shareElement' || opcode === 'consumeParent' || opcode === 'popParent') {
        break;
      }
    }

    var spliceArgs = [o + 1, 0];
    for (var i = 0; i < morphs.length; ++i) {
      spliceArgs.push(['createMorph', morphs[i].slice()]);
    }
    opcodes.splice.apply(opcodes, spliceArgs);
    morphs.length = 0;
  }
  module.exports = exports.default;

  });

  unwrapExports(hydrationOpcodeCompiler);

  var hydrationJavascriptCompiler = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;







  function HydrationJavaScriptCompiler() {
    this.stack = [];
    this.source = [];
    this.mustaches = [];
    this.parents = [['fragment']];
    this.parentCount = 0;
    this.morphs = [];
    this.fragmentProcessing = [];
    this.hooks = undefined;
  }

  exports.default = HydrationJavaScriptCompiler;

  var prototype = HydrationJavaScriptCompiler.prototype;

  prototype.compile = function (opcodes, options) {
    this.stack.length = 0;
    this.mustaches.length = 0;
    this.source.length = 0;
    this.parents.length = 1;
    this.parents[0] = ['fragment'];
    this.morphs.length = 0;
    this.fragmentProcessing.length = 0;
    this.parentCount = 0;
    this.indent = options && options.indent || "";
    this.hooks = {};
    this.hasOpenBoundary = false;
    this.hasCloseBoundary = false;
    this.statements = [];
    this.expressionStack = [];
    this.locals = [];
    this.hasOpenBoundary = false;
    this.hasCloseBoundary = false;

    utils$a.processOpcodes(this, opcodes);

    if (this.hasOpenBoundary) {
      this.source.unshift(this.indent + "  dom.insertBoundary(fragment, 0);\n");
    }

    if (this.hasCloseBoundary) {
      this.source.unshift(this.indent + "  dom.insertBoundary(fragment, null);\n");
    }

    var i, l;

    var indent = this.indent;

    var morphs;

    var result = {
      createMorphsProgram: '',
      hydrateMorphsProgram: '',
      fragmentProcessingProgram: '',
      statements: this.statements,
      locals: this.locals,
      hasMorphs: false
    };

    result.hydrateMorphsProgram = this.source.join('');

    if (this.morphs.length) {
      result.hasMorphs = true;
      morphs = indent + '  var morphs = new Array(' + this.morphs.length + ');\n';

      for (i = 0, l = this.morphs.length; i < l; ++i) {
        var morph = this.morphs[i];
        morphs += indent + '  morphs[' + i + '] = ' + morph + ';\n';
      }
    }

    if (this.fragmentProcessing.length) {
      var processing = "";
      for (i = 0, l = this.fragmentProcessing.length; i < l; ++i) {
        processing += this.indent + '  ' + this.fragmentProcessing[i] + '\n';
      }
      result.fragmentProcessingProgram = processing;
    }

    var createMorphsProgram;
    if (result.hasMorphs) {
      createMorphsProgram = 'function buildRenderNodes(dom, fragment, contextualElement) {\n' + result.fragmentProcessingProgram + morphs;

      if (this.hasOpenBoundary) {
        createMorphsProgram += indent + "  dom.insertBoundary(fragment, 0);\n";
      }

      if (this.hasCloseBoundary) {
        createMorphsProgram += indent + "  dom.insertBoundary(fragment, null);\n";
      }

      createMorphsProgram += indent + '  return morphs;\n' + indent + '}';
    } else {
      createMorphsProgram = 'function buildRenderNodes() { return []; }';
    }

    result.createMorphsProgram = createMorphsProgram;

    return result;
  };

  prototype.prepareArray = function (length) {
    var values = [];

    for (var i = 0; i < length; i++) {
      values.push(this.expressionStack.pop());
    }

    this.expressionStack.push(values);
  };

  prototype.prepareObject = function (size) {
    var pairs = [];

    for (var i = 0; i < size; i++) {
      pairs.push(this.expressionStack.pop(), this.expressionStack.pop());
    }

    this.expressionStack.push(pairs);
  };

  prototype.openBoundary = function () {
    this.hasOpenBoundary = true;
  };

  prototype.closeBoundary = function () {
    this.hasCloseBoundary = true;
  };

  prototype.pushLiteral = function (value) {
    this.expressionStack.push(value);
  };

  prototype.pushGetHook = function (path, meta) {
    this.expressionStack.push(templateUtils.buildStatement('get', path, meta));
  };

  prototype.pushSexprHook = function (meta) {
    var statement = templateUtils.buildStatement('subexpr', this.expressionStack.pop(), this.expressionStack.pop(), this.expressionStack.pop(), meta);

    this.expressionStack.push(statement);
  };

  prototype.pushConcatHook = function () {
    this.expressionStack.push(templateUtils.buildStatement('concat', this.expressionStack.pop()));
  };

  prototype.printSetHook = function (name) {
    this.locals.push(name);
  };

  prototype.printBlockHook = function (templateId, inverseId, meta) {
    this.pushStatement('block', this.expressionStack.pop(), // path
    this.expressionStack.pop(), // params
    this.expressionStack.pop(), // hash
    templateId, inverseId, meta);
  };

  prototype.printInlineHook = function (meta) {
    var path = this.expressionStack.pop();
    var params = this.expressionStack.pop();
    var hash = this.expressionStack.pop();

    this.pushStatement('inline', path, params, hash, meta);
  };

  prototype.printContentHook = function (meta) {
    this.pushStatement('content', this.expressionStack.pop(), meta);
  };

  prototype.printComponentHook = function (templateId) {
    this.pushStatement('component', this.expressionStack.pop(), // path
    this.expressionStack.pop(), // attrs
    templateId);
  };

  prototype.printAttributeHook = function () {
    this.pushStatement('attribute', this.expressionStack.pop(), // name
    this.expressionStack.pop() // value;
    );
  };

  prototype.printElementHook = function (meta) {
    this.pushStatement('element', this.expressionStack.pop(), // path
    this.expressionStack.pop(), // params
    this.expressionStack.pop(), // hash
    meta);
  };

  prototype.createMorph = function (morphNum, parentPath, startIndex, endIndex, escaped) {
    var isRoot = parentPath.length === 0;
    var parent = this.getParent();

    var morphMethod = escaped ? 'createMorphAt' : 'createUnsafeMorphAt';
    var morph = "dom." + morphMethod + "(" + parent + "," + (startIndex === null ? "-1" : startIndex) + "," + (endIndex === null ? "-1" : endIndex) + (isRoot ? ",contextualElement)" : ")");

    this.morphs[morphNum] = morph;
  };

  prototype.createAttrMorph = function (attrMorphNum, elementNum, name, escaped, namespace) {
    var morphMethod = escaped ? 'createAttrMorph' : 'createUnsafeAttrMorph';
    var morph = "dom." + morphMethod + "(element" + elementNum + ", '" + name + (namespace ? "', '" + namespace : '') + "')";
    this.morphs[attrMorphNum] = morph;
  };

  prototype.createElementMorph = function (morphNum, elementNum) {
    var morphMethod = 'createElementMorph';
    var morph = "dom." + morphMethod + "(element" + elementNum + ")";
    this.morphs[morphNum] = morph;
  };

  prototype.repairClonedNode = function (blankChildTextNodes, isElementChecked) {
    var parent = this.getParent(),
        processing = 'if (this.cachedFragment) { dom.repairClonedNode(' + parent + ',' + quoting.array(blankChildTextNodes) + (isElementChecked ? ',true' : '') + '); }';
    this.fragmentProcessing.push(processing);
  };

  prototype.shareElement = function (elementNum) {
    var elementNodesName = "element" + elementNum;
    this.fragmentProcessing.push('var ' + elementNodesName + ' = ' + this.getParent() + ';');
    this.parents[this.parents.length - 1] = [elementNodesName];
  };

  prototype.consumeParent = function (i) {
    var newParent = this.lastParent().slice();
    newParent.push(i);

    this.parents.push(newParent);
  };

  prototype.popParent = function () {
    this.parents.pop();
  };

  prototype.getParent = function () {
    var last = this.lastParent().slice();
    var frag = last.shift();

    if (!last.length) {
      return frag;
    }

    return 'dom.childAt(' + frag + ', [' + last.join(', ') + '])';
  };

  prototype.lastParent = function () {
    return this.parents[this.parents.length - 1];
  };

  prototype.pushStatement = function () {
    this.statements.push(templateUtils.buildStatement.apply(undefined, arguments));
  };
  module.exports = exports.default;

  });

  unwrapExports(hydrationJavascriptCompiler);

  var templateCompiler = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _fragmentOpcodeCompiler2 = _interopRequireDefault(fragmentOpcodeCompiler);



  var _fragmentJavascriptCompiler2 = _interopRequireDefault(fragmentJavascriptCompiler);



  var _hydrationOpcodeCompiler2 = _interopRequireDefault(hydrationOpcodeCompiler);



  var _hydrationJavascriptCompiler2 = _interopRequireDefault(hydrationJavascriptCompiler);



  var _templateVisitor2 = _interopRequireDefault(templateVisitor);







  function TemplateCompiler(options) {
    this.options = options || {};
    this.consumerBuildMeta = this.options.buildMeta || function () {};
    this.fragmentOpcodeCompiler = new _fragmentOpcodeCompiler2.default();
    this.fragmentCompiler = new _fragmentJavascriptCompiler2.default();
    this.hydrationOpcodeCompiler = new _hydrationOpcodeCompiler2.default();
    this.hydrationCompiler = new _hydrationJavascriptCompiler2.default();
    this.templates = [];
    this.childTemplates = [];
  }

  exports.default = TemplateCompiler;

  TemplateCompiler.prototype.compile = function (ast) {
    var templateVisitor$$1 = new _templateVisitor2.default();
    templateVisitor$$1.visit(ast);

    utils$a.processOpcodes(this, templateVisitor$$1.actions);

    return this.templates.pop();
  };

  TemplateCompiler.prototype.startProgram = function (program, childTemplateCount, blankChildTextNodes) {
    this.fragmentOpcodeCompiler.startProgram(program, childTemplateCount, blankChildTextNodes);
    this.hydrationOpcodeCompiler.startProgram(program, childTemplateCount, blankChildTextNodes);

    this.childTemplates.length = 0;
    while (childTemplateCount--) {
      this.childTemplates.push(this.templates.pop());
    }
  };

  TemplateCompiler.prototype.insertBoundary = function (first) {
    this.hydrationOpcodeCompiler.insertBoundary(first);
  };

  TemplateCompiler.prototype.getChildTemplateVars = function (indent) {
    var vars = '';
    if (this.childTemplates) {
      for (var i = 0; i < this.childTemplates.length; i++) {
        vars += indent + 'var child' + i + ' = ' + this.childTemplates[i] + ';\n';
      }
    }
    return vars;
  };

  TemplateCompiler.prototype.getHydrationHooks = function (indent, hooks) {
    var hookVars = [];
    for (var hook in hooks) {
      hookVars.push(hook + ' = hooks.' + hook);
    }

    if (hookVars.length > 0) {
      return indent + 'var hooks = env.hooks, ' + hookVars.join(', ') + ';\n';
    } else {
      return '';
    }
  };

  TemplateCompiler.prototype.endProgram = function (program, programDepth) {
    this.fragmentOpcodeCompiler.endProgram(program);
    this.hydrationOpcodeCompiler.endProgram(program);

    var indent = quoting.repeat("  ", programDepth);
    var options = {
      indent: indent + "    "
    };

    // function build(dom) { return fragment; }
    var fragmentProgram = this.fragmentCompiler.compile(this.fragmentOpcodeCompiler.opcodes, options);

    // function hydrate(fragment) { return mustaches; }
    var hydrationPrograms = this.hydrationCompiler.compile(this.hydrationOpcodeCompiler.opcodes, options);

    var blockParams = program.blockParams || [];
    if (blockParams.length > 0) ;

    var statements = arrayUtils.map(hydrationPrograms.statements, function (s) {
      return indent + '      ' + JSON.stringify(s);
    }).join(",\n");

    var locals = JSON.stringify(hydrationPrograms.locals);

    var templates = arrayUtils.map(this.childTemplates, function (_, index) {
      return 'child' + index;
    }).join(', ');

    var template = '(function() {\n' + this.getChildTemplateVars(indent + '  ') + indent + '  return {\n' + this.buildMeta(indent + '    ', program) + indent + '    isEmpty: ' + (program.body.length ? 'false' : 'true') + ',\n' + indent + '    arity: ' + blockParams.length + ',\n' + indent + '    cachedFragment: null,\n' + indent + '    hasRendered: false,\n' + indent + '    buildFragment: ' + fragmentProgram + ',\n' + indent + '    buildRenderNodes: ' + hydrationPrograms.createMorphsProgram + ',\n' + indent + '    statements: [\n' + statements + '\n' + indent + '    ],\n' + indent + '    locals: ' + locals + ',\n' + indent + '    templates: [' + templates + ']\n' + indent + '  };\n' + indent + '}())';

    this.templates.push(template);
  };

  TemplateCompiler.prototype.buildMeta = function (indent, program) {
    var meta = this.consumerBuildMeta(program) || {};

    var head = indent + 'meta: ';
    var stringMeta = JSON.stringify(meta, null, 2).replace(/\n/g, '\n' + indent);
    var tail = ',\n';

    return head + stringMeta + tail;
  };

  TemplateCompiler.prototype.openElement = function (element, i, l, r, c, b) {
    this.fragmentOpcodeCompiler.openElement(element, i, l, r, c, b);
    this.hydrationOpcodeCompiler.openElement(element, i, l, r, c, b);
  };

  TemplateCompiler.prototype.closeElement = function (element, i, l, r) {
    this.fragmentOpcodeCompiler.closeElement(element, i, l, r);
    this.hydrationOpcodeCompiler.closeElement(element, i, l, r);
  };

  TemplateCompiler.prototype.component = function (component, i, l, s) {
    this.fragmentOpcodeCompiler.component(component, i, l, s);
    this.hydrationOpcodeCompiler.component(component, i, l, s);
  };

  TemplateCompiler.prototype.block = function (block, i, l, s) {
    this.fragmentOpcodeCompiler.block(block, i, l, s);
    this.hydrationOpcodeCompiler.block(block, i, l, s);
  };

  TemplateCompiler.prototype.text = function (string, i, l, r) {
    this.fragmentOpcodeCompiler.text(string, i, l, r);
    this.hydrationOpcodeCompiler.text(string, i, l, r);
  };

  TemplateCompiler.prototype.comment = function (string, i, l, r) {
    this.fragmentOpcodeCompiler.comment(string, i, l, r);
    this.hydrationOpcodeCompiler.comment(string, i, l, r);
  };

  TemplateCompiler.prototype.mustache = function (mustache, i, l, s) {
    this.fragmentOpcodeCompiler.mustache(mustache, i, l, s);
    this.hydrationOpcodeCompiler.mustache(mustache, i, l, s);
  };

  TemplateCompiler.prototype.setNamespace = function (namespace) {
    this.fragmentOpcodeCompiler.setNamespace(namespace);
  };
  module.exports = exports.default;

  });

  unwrapExports(templateCompiler);

  var compiler = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;
  exports.compileSpec = compileSpec;
  exports.template = template;
  exports.compile = compile;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  /*jshint evil:true*/





  var _templateCompiler2 = _interopRequireDefault(templateCompiler);





  var _htmlbarsRuntimeRender2 = _interopRequireDefault(render_1);

  /*
   * Compile a string into a template spec string. The template spec is a string
   * representation of a template. Usually, you would use compileSpec for
   * pre-compilation of a template on the server.
   *
   * Example usage:
   *
   *     var templateSpec = compileSpec("Howdy {{name}}");
   *     // This next step is basically what plain compile does
   *     var template = new Function("return " + templateSpec)();
   *
   * @method compileSpec
   * @param {String} string An HTMLBars template string
   * @return {TemplateSpec} A template spec string
   */

  function compileSpec(string, options) {
    var ast = parser$2.preprocess(string, options);
    var compiler = new _templateCompiler2.default(options);
    var program = compiler.compile(ast);
    return program;
  }

  /*
   * @method template
   * @param {TemplateSpec} templateSpec A precompiled template
   * @return {Template} A template spec string
   */

  function template(templateSpec) {
    return new Function("return " + templateSpec)();
  }

  /*
   * Compile a string into a template rendering function
   *
   * Example usage:
   *
   *     // Template is the hydration portion of the compiled template
   *     var template = compile("Howdy {{name}}");
   *
   *     // Template accepts three arguments:
   *     //
   *     //   1. A context object
   *     //   2. An env object
   *     //   3. A contextualElement (optional, document.body is the default)
   *     //
   *     // The env object *must* have at least these two properties:
   *     //
   *     //   1. `hooks` - Basic hooks for rendering a template
   *     //   2. `dom` - An instance of DOMHelper
   *     //
   *     import {hooks} from 'htmlbars-runtime';
   *     import {DOMHelper} from 'morph';
   *     var context = {name: 'whatever'},
   *         env = {hooks: hooks, dom: new DOMHelper()},
   *         contextualElement = document.body;
   *     var domFragment = template(context, env, contextualElement);
   *
   * @method compile
   * @param {String} string An HTMLBars template string
   * @param {Object} options A set of options to provide to the compiler
   * @return {Template} A function for rendering the template
   */

  function compile(string, options) {
    return hooks.wrap(template(compileSpec(string, options)), _htmlbarsRuntimeRender2.default);
  }

  });

  unwrapExports(compiler);
  var compiler_1 = compiler.compileSpec;
  var compiler_2 = compiler.template;
  var compiler_3 = compiler.compile;

  var htmlbarsCompiler = createCommonjsModule(function (module, exports) {
  exports.__esModule = true;



  exports.compile = compiler.compile;
  exports.compileSpec = compiler.compileSpec;
  exports.template = compiler.template;

  });

  unwrapExports(htmlbarsCompiler);
  var htmlbarsCompiler_1 = htmlbarsCompiler.compile;
  var htmlbarsCompiler_2 = htmlbarsCompiler.compileSpec;
  var htmlbarsCompiler_3 = htmlbarsCompiler.template;

  function App () {
    return ClassMap.get('Application').getInstance();
  }

  /**
   * @module Api
   */
  var ApiError =
  /*#__PURE__*/
  function () {
    function ApiError(apiCall, xhrError) {
      _classCallCheck(this, ApiError);

      /**
       * @property api
       * @type {Api.ApiCall}
       */
      this.apiCall = apiCall;
      /**
       * @property xhrError
       * @type {jqXHR}
       */

      this.xhrError = xhrError;
    }

    _createClass(ApiError, [{
      key: "getStatusCode",
      value: function getStatusCode() {
        return this.xhrError.status;
      }
    }, {
      key: "getMessage",
      value: function getMessage() {
        // JSON body with message?
        if (this.xhrError.responseJSON && this.xhrError.responseJSON.message) {
          return this.xhrError.responseJSON.message;
        } // Text?


        if (this.xhrError.responseText) return this.xhrError.responseText; // Don't know

        return 'Unknown error';
      }
    }, {
      key: "getFormErrors",
      value: function getFormErrors() {
        // JSON body with message?
        if (this.xhrError.responseJSON && this.xhrError.responseJSON.errors) {
          // Get errors
          return this.xhrError.responseJSON.errors;
        }

        return {};
      }
    }, {
      key: "getStatus",
      value: function getStatus() {
        return this.xhrError.status;
      }
    }]);

    return ApiError;
  }();

  var ModelStore =
  /*#__PURE__*/
  function (_Obj) {
    _inherits(ModelStore, _Obj);

    function ModelStore(modelName) {
      var _this;

      _classCallCheck(this, ModelStore);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ModelStore).call(this));
      _this.modelName = modelName;
      _this.records = {};
      return _this;
    }

    _createClass(ModelStore, [{
      key: "has",
      value: function has(id) {
        return this.records[id] !== undefined;
      }
    }, {
      key: "set",
      value: function set(id, model) {
        this.records[id] = model;
        return this;
      }
    }, {
      key: "get",
      value: function get(id) {
        return this.records[id] ? this.records[id] : null;
      }
    }, {
      key: "forget",
      value: function forget(id) {
        delete this.records[id];
        return this;
      }
    }]);

    return ModelStore;
  }(Obj);

  var _this3 = window;

  var Collection =
  /*#__PURE__*/
  function (_ObservableArray) {
    _inherits(Collection, _ObservableArray);

    function Collection() {
      var _this;

      var modelClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      _classCallCheck(this, Collection);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Collection).call(this));
      _this.modelClass = modelClass;
      _this.itemsById = {};
      _this.originalIds = [];
      _this.meta = {};
      _this.page = {};
      return _this;
    }

    _createClass(Collection, [{
      key: "knows",
      value: function knows(id) {
        if (ClassMap.isA(id, 'Model')) id = id.get('id');
        return this.itemsById[id] !== undefined;
      }
    }, {
      key: "setMetaData",
      value: function setMetaData(data) {
        this.meta = underscore.extend(this.meta, data);
        return this;
      }
    }, {
      key: "setPageInfo",
      value: function setPageInfo(currentPage, pageCount) {
        var recordsPerPage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var totalRecordCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        // Basics
        this.page = {
          currentPage: currentPage,
          pageCount: pageCount,
          size: recordsPerPage,
          recordCount: totalRecordCount
        }; // Calculate current

        if (recordsPerPage) {
          this.page.from = (currentPage - 1) * recordsPerPage + 1;
          this.page.through = Math.min(totalRecordCount, currentPage * recordsPerPage);
        }
      }
    }, {
      key: "get",
      value: function get$$1(key) {
        // Page info?
        if (this.page && /^page\.(currentPage|pageCount|size|recordCount|through)$/.test(key)) {
          var _key$split = key.split(/\./),
              _key$split2 = _slicedToArray(_key$split, 2),
              k = _key$split2[1];

          return this.page[k];
        } // Basics


        return _get(_getPrototypeOf(Collection.prototype), "get", this).call(this, key);
      }
    }, {
      key: "addFromApi",
      value: function addFromApi(item) {
        // Add it
        this.add(item); // Store id as original id

        var id = item.get('id');

        if (id && !underscore.contains(this.originalIds, id)) {
          this.originalIds.push(id);
        }

        return this;
      }
    }, {
      key: "_add",
      value: function _add(value) {
        // Is value a model?
        if (!ClassMap.isA(value, 'Model')) {
          throw new TypeError('You cannot add non-Model values to a Collection');
        } // Studying?


        if (this.isStudyingModels) {
          value.study(this.modelStudyCallback);
        } // Not already in there?


        var modelId = value.get('id');

        if (!modelId || !this.itemsById[modelId]) {
          // Store it and add it
          this.items.push(value);

          if (modelId) {
            this.itemsById[modelId] = value;
          }
        }

        return this;
      }
    }, {
      key: "_delete",
      value: function _delete(value) {
        // Is value an id?
        if (typeof value === 'number' || typeof value === 'string') {
          value = this.itemsById[value];
          if (!value) return this;
        } // Is value a model?


        if (!ClassMap.isA(value, 'Model')) {
          throw new TypeError('You cannot delete non-Model values to a Collection');
        } // Basics


        _get(_getPrototypeOf(Collection.prototype), "_delete", this).call(this, value); // And from keyed array


        delete this.itemsById[value.get('id')];
        return this;
      }
    }, {
      key: "empty",
      value: function empty() {
        // Do the basics
        _get(_getPrototypeOf(Collection.prototype), "empty", this).call(this); // Clear ids


        this.itemsById = {};
        return this;
      }
    }, {
      key: "isDirty",
      value: function isDirty() {
        // Compare item id's
        var currentIds = underscore.map(this.items, function (item) {
          return item.get('id');
        });

        var newIds = underscore.difference(currentIds, this.originalIds);

        var removedIds = underscore.difference(this.originalIds, currentIds); // Are any of the id's different?


        return newIds.length > 0 || removedIds.length > 0;
      }
    }, {
      key: "hasDirtyChildren",
      value: function hasDirtyChildren() {
        //check children for dirty
        var dirtyChildren = underscore.filter(this.items, function (item) {
          return item.isDirty();
        });

        return dirtyChildren.length > 0;
      }
      /**
       * Create copy of collection and its items
       *
       * @method clone
       * @return {Collection}
       */

    }, {
      key: "clone",
      value: function clone(cacheMap) {
        //create cacheMap?
        if (!cacheMap) cacheMap = new Map(); //known in cache map? return it

        if (cacheMap.has(this)) return this; //create copy

        var c = this.constructor;
        var copy = new c(this.modelClass); //store in cacheMap1

        cacheMap.set(this, copy); //copy items

        underscore.each(this.items, function (item) {
          copy.items.push(item.clone(cacheMap));
        });

        return copy;
      }
    }, {
      key: "search",
      value: function search(query) {
        var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var fields = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        // No models in me?
        if (this.items.length === 0) return new Collection(this.modelClass); // No fields defined?

        if (!fields) {
          // Try to get fields from definition
          var def = this.modelClass.definition;

          if (def) {
            // Get fields
            fields = def.getSearchFields();
          } // Still no field?


          if (!fields) {
            // Use all but id
            fields = underscore.without(underscore.keys(underscore.first(this.items).attributes), 'id');
          }
        } // Get words


        var words = query.split(/\s+/);
        var result = [];

        underscore.each(this.items, function (model) {
          // How many words are matched by the fields
          var wordsMatched = 0;
          var entireMatch = false;

          underscore.each(words, function (word) {
            // Not empty?
            if (!word) return; // Loop through fields

            underscore.each(fields, function (field) {
              // Entire match?
              var value = model.get(field);

              if (value && value === word) {
                entireMatch = true;
                wordsMatched++;
              } else {
                // Check if it contains me
                value = ('' + value).toLowerCase();
                var w = word.toLowerCase();
                var index = value.indexOf(w);
                if (index > -1) wordsMatched++;
              }
            });
          }); // Match?


          if (wordsMatched > 0) {
            result.push({
              wordsMatched: wordsMatched,
              entireMatch: entireMatch,
              model: model
            });
          }
        }); // Now sort it


        result.sort(function (a, b) {
          // Entire match same?
          if (a.entireMatch !== b.entireMatch) {
            // Entire match is better.
            return a.entireMatch ? -1 : 1;
          } // # words matched


          if (a.wordsMatched === b.wordsMatched) return 0;
          return a.wordsMatched > b.wordsMatched ? -1 : 1;
        }); // Check limit

        limit = limit ? Math.min(result.length, limit) : result.length; // Make collection

        var collectionResult = new Collection(this.modelClass);

        for (var q = 0; q < limit; q++) {
          collectionResult.items.push(result[q].model);
        }

        return collectionResult;
      }
    }, {
      key: "filter",
      value: function filter() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        // Do the basics
        var items = _get(_getPrototypeOf(Collection.prototype), "filter", this).apply(this, args); // Did we receive an ObservableArray?


        if (items instanceof ObservableArray) {
          // Make collection
          var collectionResult = new Collection(this.modelClass);
          collectionResult.items = items.items;
          return collectionResult;
        } else {
          // Return items as they are
          return items;
        }
      }
    }, {
      key: "saveAll",
      value: function saveAll() {
        var _this2 = this;

        var saveOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var breakOnError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var saveOnlyDirtyModels = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        // Create promise
        return new Promise(function (resolve, reject) {
          // Prepare queue
          var queue = underscore.filter(_this2.items, function (item) {
            return saveOnlyDirtyModels ? item.isDirty() : true;
          }); // Next


          var saveNext = function saveNext() {
            // Queue empty?
            if (queue.length === 0) {
              resolve();
              return;
            } // Save next


            var model = queue.shift();
            model.save(saveOptions).then(function () {
              saveNext();
            }, function (error) {
              // Break?
              if (breakOnError) {
                reject(error);
              } else {
                saveNext();
              }
            });
          }; // GO!


          saveNext();
        });
      }
    }]);

    return Collection;
  }(ObservableArray);

  Collection.fromArray = function (arr) {
    // Empty?
    if (arr.length === 0) return new Collection(); // Get class from first item

    var item = underscore.first(arr);

    if (!ClassMap.isA(item, 'Model')) throw new TypeError('The array needs to contain model instances'); // Create collection

    var coll = new Collection(item.constructor);
    coll.items = arr;
    return coll;
  };

  Collection.merge = function () {
    for (var _len2 = arguments.length, collections = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      collections[_key2] = arguments[_key2];
    }

    // Get all items
    collections = underscore.flatten(collections);

    var items = underscore.flatten(underscore.pluck(collections, 'items')); // Create new collection


    var result = new Collection();
    result.import(items, false);
    return result;
  };

  Collection.combine = function () {
    for (var _len3 = arguments.length, collections = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      collections[_key3] = arguments[_key3];
    }

    // Combine items by id
    collections = underscore.flatten(collections);

    var itemArrays = underscore.map(underscore.pluck(collections, 'items'), function (arr) {
      var items = {};

      underscore.each(arr, function (item) {
        items[item.get('id')] = item;
      });

      return items;
    });

    itemArrays.unshift({});

    var resultArray = underscore.extend.apply(_this3, itemArrays); // Create new collection


    var result = new Collection();
    result.import(resultArray, false);
    return result;
  };

  var HelperProxy =
  /*#__PURE__*/
  function () {
    function HelperProxy(name, helperFunction, context) {
      _classCallCheck(this, HelperProxy);

      this.name = name;
      this.callback = helperFunction;
      this.context = context;
    }

    _createClass(HelperProxy, [{
      key: "setArguments",
      value: function setArguments() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        this.arguments = args;
      }
    }, {
      key: "invoke",
      value: function invoke() {
        // Do it
        return this.callback.apply(this.context, this.arguments);
      }
    }]);

    return HelperProxy;
  }();

  var _uid = 0;
  /**
   * @module Helpers
   */

  var Utils = {
    /**
     * @class Helpers.Utils
     * @static
     */
    getValue: function getValue(obj) {
      if (obj instanceof HelperProxy) return obj.invoke();

      if (obj instanceof Binding || obj instanceof ComputedProperty || obj instanceof Reference) {
        return obj.getValue();
      }

      return obj;
    },

    /**
     * @method each
     * @static
     * 
     * @param  {Object}   obj      
     * @param  {Function} callback 
     * @param  {Object}   context  
     */
    each: function each(obj, callback, context) {
      // Map?
      if (obj instanceof Map) {
        obj.forEach(function (value, key) {
          callback.apply(context, [value, key]);
        });
        return;
      } else if (obj instanceof Observable) {
        obj = obj.attributes;
      } else if (obj instanceof ObservableArray) {
        obj = obj.items;
      }

      return underscore.each(obj, callback, context);
    },

    /**
     * @method reverseEach
     * @static
     * 
     * @param  {Object}   obj      
     * @param  {Function} callback 
     * @param  {Object}   context  
     */
    reverseEach: function reverseEach(obj, callback, context) {
      // Map?
      if (obj instanceof Map) {
        obj.forEach(function (value, key) {
          callback.apply(context, [value, key]);
        });
        return;
      } else if (obj instanceof Observable) {
        obj = obj.attributes;
      } else if (obj instanceof ObservableArray) {
        obj = obj.items;
      }

      for (var i = obj.length - 1; i >= 0; i--) {
        callback.apply(context, [obj[i]]);
      }
    },

    /**
     * @method map
     * @static
     * 
     * @param  {Object}   obj      
     * @param  {Function} callback 
     * @param  {Object}   context  
     */
    map: function map(obj, callback, context) {
      if (obj instanceof Observable) {
        obj = obj.attributes;
      } else if (obj instanceof ObservableArray) {
        obj = obj.items;
      }

      return underscore.map(obj, callback, context);
    },

    /**
     * Determine whether given value is truthlike
     * 
     * @method isTruthlike
     * @static
     *	 
     * @param  {mixed} value 
     * @return {boolean}
     */
    isTruthlike: function isTruthlike(value) {
      // Null/undef
      if (value === null || value === undefined) return false; // Bool?

      if (value === true || value === 'true') return true;
      if (value === false || value === 'false') return false; // 0 and 1?

      if (value === 1 || value === '1') return true;
      if (value === 0 || value === '0') return false; // Array?

      if (Array.isArray(value) || value instanceof ObservableArray) {
        return value.length > 0;
      } // Object


      if (_typeof(value) === 'object' && value.contructor === Object) {
        return underscore.key(value).length > 0;
      } // Do it natively


      return !!value;
    },
    areEqual: function areEqual(value1, value2) {
      // Identical?
      if (value1 === value2) return true; // Is one or both a moment?

      if (moment.isMoment(value1) && value2 !== undefined) return value1.isSame(value2);
      if (moment.isMoment(value2) && value1 !== undefined) return value2.isSame(value1); // One of them null or undefined?

      if (value1 === undefined || value2 === undefined || value1 === null || value2 === null) return false;
      if (_typeof(value1) !== 'object' || _typeof(value2) !== 'object') return false;
      if (value1 instanceof Array || value2 instanceof Array) return false; // Same id?

      if (this.uidFor(value1) === this.uidFor(value2)) return true;
      return false;
    },

    /**
     * Get a unique string identifier for given object or variable. For objects
     * this identifier will remain the same, making it useful for comparing objects.
     *
     * @method uidFor
     * @param  {mixed} obj 
     * @return {string}
     */
    uidFor: function uidFor(obj) {
      // Chicken model?
      if (obj.__getUid && typeof obj.__getUid === 'function') {
        return obj.__getUid();
      } // Already set for this object?


      if (obj && obj.__chickenUID !== undefined) return obj.__chickenUID; // Non-existing things?

      if (obj === undefined) return '(undefined)';
      if (obj === null) return '(null)'; // Check what type the value is

      var type = _typeof(obj);

      switch (type) {
        case 'number':
        case 'string':
          return type + ':' + obj;

        case 'boolean':
          return obj ? '(true)' : '(false)';
      } // Is it a standard object?


      if (obj === Object) return '(Object)';
      if (obj === Array) return '(Array)'; // Store the id on the obj

      var uid = Utils.uid();
      obj.__chickenUID = uid;
      return uid;
    },
    uid: function uid() {
      return '*' + ++_uid + '*';
    },

    /**
     * encode an object to a query string
     * @param  {Object}  obj  	the object to convert
     * @param  {Boolean} deep 	use deep-converion, this adds subkeys and array values
     * @return {String}       	the query string
     */
    encodeQueryString: function encodeQueryString(obj) {
      var _this = this;

      var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (deep) {
        //init str
        var propStrings = [],
            str = ''; //convert to simple object

        if (obj instanceof Observable) obj = obj.toObject(); //base url

        if (obj.baseUrl) str += obj.baseUrl + '?'; //add props

        underscore.each(underscore.keys(obj), function (key) {
          //skip baseUrl
          if (key == 'baseUrl') return;
          propStrings = _this._addPropString(propStrings, key, obj[key]);
        }); //add to querystring


        str += propStrings.join('&');
        return str;
      } else {
        return queryString.stringify(obj);
      }
    },

    /**
     * Add an url property from key and value. 
     * Arrays are joined with commas,
     * Objects properties will be processed again, and the key will be sub-keyed,
     * String values will remain unchanged
     * 
     * @param {Array} propStrings 	The list of strings to add the value to
     * @param {String} key         	The variable key
     * @param {mixed} value       	The variable value
     */
    _addPropString: function _addPropString(propStrings, key, value) {
      var _this2 = this;

      if (value instanceof Array) {
        //array
        propStrings.push(key + '=' + value.join(','));
      } else if (value instanceof Object) {
        //object
        underscore.each(underscore.keys(value), function (subKey) {
          propStrings = _this2._addPropString(propStrings, key + '[' + subKey + ']', value[subKey]);
        });
      } else {
        propStrings.push(key + '=' + value);
      }

      return propStrings;
    },

    /**
     * decode a query string to an object
     * @param  {string}  str  	the query string
     * @param  {Boolean} deep 	use deep-conversion, sub-keys and array values will be converted to objects and arrays
     * @return {Object}       	the decoded values
     */
    decodeQueryString: function decodeQueryString(str) {
      var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (deep) {
        //init object
        var props,
            resultObject = {}; //get all properties

        if (str.indexOf('?') !== -1) {
          resultObject['baseUrl'] = str.split('?')[0];
          props = str.split('?')[1].split('&');
        } else {
          props = str.split('&');
        } //convert each property to object


        underscore.each(props, function (prop) {
          //split value and key
          prop = prop.split('=');
          var key = prop[0];
          var value = prop[1]; //value				

          value = value.split(',');
          value = value.length == 1 ? value[0] : value; //key array

          if (key.indexOf('[') !== -1 && key.indexOf(']') !== -1) {
            key = key.split('[');
            var baseKey = key[0];
            var subKey = key[1].substring(0, key[1].length - 1);

            if (!(resultObject[baseKey] instanceof Object)) {
              resultObject[baseKey] = {};
            }

            resultObject[baseKey][subKey] = value;
          } else {
            resultObject[key] = value;
          }
        });

        return resultObject;
      } else {
        return queryString.parse(str);
      }
    }
  };
  ClassMap.register('Utils', Utils);

  /**
   * @module Data
   */

  var Model =
  /*#__PURE__*/
  function (_Observable) {
    _inherits(Model, _Observable);

    /**
     * The Model class is an extension of Observable, and is used
     * to hold data that is received from an Api, and save that data, etc.
     * 
     * @class Data.Model
     *
     * @constructor
     * @param  {Object}  initValues           
     * @param  {Boolean} convertToObservables 
     */
    function Model() {
      var _this;

      var initValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var convertToObservables = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      _classCallCheck(this, Model);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Model).call(this, initValues, convertToObservables));
      /**
       * The original values as received from the Api
       * 
       * @property originalValues
       * @type {object}
       */

      _this.originalValues = {};

      underscore.each(initValues, function (value, key) {
        _this.originalValues[key] = _this.uncastValue(key, value);
      });
      /**
       * Values of relationships, keyed by the relationshipname
       * 
       * @property related
       * @type {Object}
       */


      _this.related = _this.related || {};
      /**
       * The watchable current state of this model. This
       * contains attributes for 'busy', 'saving', and 'dirty'.
       *
       * You can use this in a view to update the view according
       * to the model state, using the 'is' property e.g.:
       *
       * 	{{#if author.is.busy}}
       * 		Please wait a moment...
       * 	{{/if}}
       * 
       * @property state
       * @type {Observable}
       */

      _this.state = new Observable({
        busy: false,
        saving: false,
        dirty: false,
        deleting: false,
        deleted: false,
        new: !_this.get('id')
      });

      _this.state.study(function () {
        _this._scheduleAttributeChanged('is');
      });

      _this.metaAttributes = new Observable({});
      /**
       * list of studied relationships
       * @type {Object}
       */

      _this._relationshipStudies = {}; // Check computed!

      if (_this.constructor.definition) {
        // Apply to model
        _this.constructor.definition.initializeModel(_assertThisInitialized(_assertThisInitialized(_this)));
      } // A initialize method on the model?


      if (typeof _this.initialize === 'function') {
        _this.initialize();
      }

      return _this;
    } ///////////
    // State //
    ///////////

    /**
     * Get the model state. This method is used to make the state
     * available in views.
     * 
     * @method getIs
     * @return {Observable}
     */


    _createClass(Model, [{
      key: "getIs",
      value: function getIs() {
        return this.state;
      }
    }, {
      key: "getMeta",
      value: function getMeta() {
        return this.metaAttributes;
      }
      /**
       * @method isBusy
       * @return {Boolean} 
       */

    }, {
      key: "isBusy",
      value: function isBusy() {
        return this.state.get('busy');
      } /////////////////////////
      // Information methods //
      /////////////////////////

      /**
       * Checks whether this model is new or has already been saved. This
       * is determined by checking whether the 'id' is set.
       * 
       * @method isNew
       * @return {Boolean} 
       */

    }, {
      key: "isNew",
      value: function isNew() {
        return !this.get('id');
      } /////////////////
      // Get and set //
      /////////////////

    }, {
      key: "_get",
      value: function _get$$1(key) {
        // Is there a getter?
        var methodName = 'get' + inflection.camelize(key);

        if (this[methodName] && typeof this[methodName] === 'function') {
          return this[methodName].apply(this, [this.attributes[key]]);
        } // Is it a relationship that was not yet loaded


        var relationship = this.getRelationship(key);
        if (!this.related) this.related = {};

        if (relationship && !this.related[key]) {
          this.related[key] = relationship.getInitValue();
        } // Is it a relationship?


        if (this.related && this.related[key]) return this.related[key]; // Nothing special. Do basics

        return _get$$1(_getPrototypeOf(Model.prototype), "_get", this).call(this, key);
      }
    }, {
      key: "_set",
      value: function _set$$1(key, value) {
        var _this2 = this;

        // Is there a setter?
        var methodName = 'set' + inflection.camelize(key);

        if (methodName !== 'setRelatedModel' && this[methodName] && typeof this[methodName] === 'function' && !(value instanceof ComputedProperty)) {
          return this[methodName].apply(this, [value]);
        } // Is it a relationship that was not yet loaded


        if (!this.related) this.related = {};
        var relationship = this.getRelationship(key);

        if (relationship) {
          // Many?
          if (relationship.usesCollection()) {
            // Already initialized?
            if (this.related[key]) this.related[key].empty(); // Initialize relationship

            if (!(value instanceof Collection)) throw new TypeError("The '".concat(key, "' relationship expects a Collection as value"));
            value.each(function (model) {
              _this2.addRelatedModel(key, model);
            });
          } else {
            // Set the model
            this.setRelatedModel(key, value);
          }
        } else {
          // Cast if necessary
          value = this.castValue(key, value); // Continue with it

          _get(_getPrototypeOf(Model.prototype), "_set", this).call(this, key, value);
        } // Is dirty?


        if (this.state) {
          this._scheduleUpdateDirty();
        }

        return this;
      }
      /**
       * Override Observable.observe
       *
       * Check if model has HasMany, HasManyTrough or BelongToMany relations it can study
       */

    }, {
      key: "observe",
      value: function observe(keyOrKeys, callback) {
        var _this3 = this;

        //can have multiple keys, call function for each key
        if (Array.isArray(keyOrKeys)) {
          underscore.each(keyOrKeys, function (key) {
            _this3.observe(key, callback);
          });

          return this;
        }

        var key = keyOrKeys; //Study relation?

        var rel = this.getRelationship(key);

        if (rel && rel.usesCollection()) {
          if (this._relationshipStudies[key] === undefined) {
            this._relationshipStudies[key] = function () {
              _this3._scheduleAttributeChanged(key);
            };

            this.get(key).study(this._relationshipStudies[key]);
          }
        } //super


        return _get(_getPrototypeOf(Model.prototype), "observe", this).call(this, keyOrKeys, callback);
      }
      /**
       * Get a value for use in the API, meaning it is in
       * database format. For example, dates will be converted back
       * from Moment instances into strings.
       *
       * @method getForApi
       * @param  {string} key 
       * @return {mixed} 
       */

    }, {
      key: "getForApi",
      value: function getForApi(key) {
        // Get value
        var value = this.uncastValue(key, this.attributes[key]);
        return value;
      }
      /**
       * Cast given value according to the AttributeDefinition for given
       * key. For example, if you pass a string containing a date as value,
       * for a Date key, you will receive a Moment instance.
       * 
       * @method castValue
       * @param  {string} key   
       * @param  {Mixed} value 
       * @return {Mixed}       
       */

    }, {
      key: "castValue",
      value: function castValue(key, value) {
        // Do we need to cast it?
        var attributeDefinition = this.getAttributeDefinition(key);

        if (attributeDefinition) {
          value = attributeDefinition.cast(value);
        }

        return value;
      }
      /**
       * Uncast given value according to the AttributeDefinition for given key.
       *
       * @method uncastValue
       * @param  {string} key   
       * @param  {Mixed} value 
       * @return {Mixed}       
       */

    }, {
      key: "uncastValue",
      value: function uncastValue(key, value) {
        // Do we need to uncast it?
        var attributeDefinition = this.getAttributeDefinition(key);

        if (attributeDefinition) {
          value = attributeDefinition.uncast(value);
        }

        return value;
      }
      /**
       * Get the value of a translation
       *
       * @method translation
       * @param  {string} key  
       * @param  {string} language     (Default = null) When null, the application language will be used
       * @return {string|null}
       */

    }, {
      key: "translation",
      value: function translation(key) {
        var language = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        // Language given?
        if (!language) language = App().i18n.language; // Retrieve value

        var v = this.get(key);
        if (v instanceof Observable) v = v.toObject();
        if (!v || !(v instanceof Object) || !v[language]) return null;
        return v[language];
      } /////////////////////////
      // Api related methods //
      /////////////////////////

      /**
       * Set attribute values that were retrieved from the API, meaning
       * they will not be seen as dirty, and will overwrite the original values
       * of the model. 
       *
       * @method setAttributesFromApi
       * @param {Object} attributes
       * @chainable
       */

    }, {
      key: "setAttributesFromApi",
      value: function setAttributesFromApi(attributes) {
        var _this4 = this;

        // Loop through them and set values that are not dirty
        underscore.each(attributes, function (value, key) {
          // Dirty?
          if (_this4.isDirty(key)) return; // Set it, and see this as a non-dirty value

          _this4.setAttribute(key, value);

          _this4.originalValues[key] = _this4.uncastValue(key, _this4.attributes[key]);
        });

        return this;
      }
      /**
       * Get attribute values for use in the API.
       *
       * @method getAttributesForApi
       * @param  {Boolean} [onlyDirty=true]  When true, only attributes that have been changed will be retrieved
       * @param  {Boolean} [modelIsDynamic=false]	 When true, attributes that are not in the model definition are also passed along. This overrides the model definition's 'dynamic' value
       * @return {Object}      A hash containing attribute key/values
       */

    }, {
      key: "getAttributesForApi",
      value: function getAttributesForApi() {
        var _this5 = this;

        var onlyDirty = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        // Which attributes to use?
        var attr = onlyDirty ? this.getDirty() : underscore.defaults({}, this.attributes); // Check model definition

        var modelDefinition = this.getDefinition();

        if (modelDefinition) {
          // Use only attributes in the model definition
          var modelAttr = underscore.pick(attr, function (value, key) {
            // Dynamic?
            if (!modelDefinition.isDynamic) {
              // Has property?
              if (!(modelDefinition.hasAttribute(key) || modelDefinition.getRelationshipByLocalKey(key) !== undefined)) return false;
            } // Is the value computed?


            if (value instanceof ComputedProperty) return false; // OK.

            return true;
          }); // Now uncast the values


          attr = underscore.mapObject(modelAttr, function (value, key) {
            // Get the actual value
            value = Utils.getValue(value); // Uncast it for DB usage

            var definition = _this5.getAttributeDefinition(key);

            if (definition) value = definition.uncast(value);
            return value;
          }); // Not only dirty?

          if (!onlyDirty && !modelDefinition.isDynamic) {
            // Also add defined attributes that were not set in the model (by default value)
            var missingKeys = underscore.difference(modelDefinition.getApiAttributeNames(), underscore.keys(attr));

            underscore.each(missingKeys, function (key) {
              // Is it a local relationship?
              if (modelDefinition.getRelationshipByLocalKey(key) !== undefined) return; // Add default value

              var def = _this5.getAttributeDefinition(key);

              var defaultValue = def.getDefaultValue();
              if (defaultValue) attr[key] = def.uncast(def.getDefaultValue());
            });
          } // Remove hidden attributes


          attr = underscore.omit(attr, modelDefinition.getHiddenAttributeNames());
          return attr;
        } else {
          // Loop attributes
          var convertedAttr = {};

          underscore.each(attr, function (value, key) {
            // Is the value computed?
            if (value instanceof ComputedProperty) return; // Get the actual value

            value = Utils.getValue(value); // Is it a moment?

            if (moment.isMoment(value)) {
              // Make it ISO 8601
              value = value.format('YYYY-MM-DD HH:mm:ss');
            } // Is it an array or model?
            else if (value instanceof ObservableArray) {
                value = JSON.stringify(value.toArray());
              } else if (value instanceof Model) {
                value = JSON.stringify(value.getAttributesForApi(onlyDirty));
              } // Set it


            convertedAttr[key] = value;
          }); // Switch


          attr = convertedAttr;
        }

        delete attr.id;
        return attr;
      }
    }, {
      key: "setMetaAttributes",
      value: function setMetaAttributes(attributes) {
        this.metaAttributes.import(attributes);
        return this;
      }
      /**
       * Get the Api instance that is used by this model
       *
       * @method getApi
       * @return {Api.Api}
       */

    }, {
      key: "getApi",
      value: function getApi() {
        // Check model definition
        var apiName = this.getDefinition() ? this.getDefinition().api : null;
        return App().apis[apiName];
      }
      /**
       * Get the uri for this model, that can be used in an API call
       *
       * @method getApiUri
       * @return {string}
       */

    }, {
      key: "getApiUri",
      value: function getApiUri() {
        // Check definition
        var def = this.getDefinition();
        if (!def) throw new Error('Cannot guess the ApiUri for a model that has no ModelDefinition'); // Get api uri

        return def.getApiUri(this.get('id'));
      }
      /**
       * Save the model to the Api. 
       *
       * Possible options are:
       * 
       * **uri** (string)
       * A custom uri to use instead of the model's default uri
       * 
       * **includeRelated** (boolean)
       * _(Default: true)_ 
       * Whether to included modifications in the relationships 
       *
       * **includeRelatedData** (boolean)	
       * _(Default: false)_ 
       * Whether to embed relationship data into the request. Note: this is not following JSONAPI specifications.
       *
       * @method save
       * @param  {Object} [options={}]	Optional options hash
       * @return {Promise} The promise returned by the ApiCall.execute method
       */

    }, {
      key: "save",
      value: function save() {
        var _this6 = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        // Make settings
        var settings = jquery.extend({
          uri: null,
          includeRelated: true,
          includeRelatedData: false // False, true or an array of relationship-names to save

        }, options); // Busy?

        if (this.isBusy()) throw new Error('Model has not completed its last action');
        this.state.set('busy', true);
        this.state.set('saving', true); // Create the call

        if (!settings.uri) settings.uri = this.getApiUri();
        var apiCall = this.getApi().saveModel(this, settings); // Handle it.

        apiCall.getPromise('complete').then(function (result) {
          // Check result
          if (result instanceof Model) {
            // Use id for me.
            if (!_this6.get('id')) {
              _this6.set('id', result.get('id'));

              _this6.state.set('new', false);
            }
          } // No longer dirty!


          _this6.state.set('dirty', false);

          _this6.resetDirty(); // No longer busy


          _this6.state.set('busy', false);

          _this6.state.set('saving', false); // Trigger.


          _this6.trigger('save', apiCall);
        }, function () {
          // No longer busy
          _this6.state.set('busy', false);

          _this6.state.set('saving', false);

          _this6.trigger('error', apiCall);
        }); // Done.

        return apiCall.execute();
      }
      /**
       * Delete the model from the Api. 
       *
       * Possible options are:
       * 
       * **uri** (string)
       * A custom uri to use instead of the model's default uri
       *
       * @method delete
       * @param  {Object} [options={}]	Optional options hash
       * @return {Promise} The promise returned by the ApiCall.execute method
       */

    }, {
      key: "delete",
      value: function _delete() {
        var _this7 = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        // Make settings
        var settings = jquery.extend({
          uri: null,
          modelIsDynamic: false
        }, options); // Busy?

        if (this.isBusy()) throw new Error('Model has not completed its last action');
        this.state.set('busy', true);
        this.state.set('deleting', true); // Create the call

        if (!settings.uri) settings.uri = this.getApiUri();
        var apiCall = this.getApi().deleteModel(this, settings); // Handle it.

        apiCall.getPromise('complete').then(function () {
          // No longer busy
          _this7.state.set('busy', false);

          _this7.state.set('saving', false);

          _this7.state.set('deleted', true);

          _this7.trigger('delete'); //remove model from the store


          Model.deleteFromStore(_this7.getModelName(), _this7.get('id'));
        }, function () {
          // No longer busy
          _this7.state.set('busy', false);

          _this7.state.set('saving', false);

          _this7.trigger('error', apiCall);
        }); // Done.

        return apiCall.execute();
      } ///////////////////
      // Handy methods //
      ///////////////////

    }, {
      key: "toObject",
      value: function toObject() {
        var includedUids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        // Get basics
        var obj = _get(_getPrototypeOf(Model.prototype), "toObject", this).call(this, includedUids); // Add relationships


        underscore.each(this.related, function (item, key) {
          // Observable?
          if (Observable.isObservable(item)) {
            // Array?
            if (item instanceof Observable) {
              item = item.toObject(includedUids);
            } else {
              item = item.toArray(includedUids);
            }
          }

          obj[key] = item;
        });

        return obj;
      }
      /**
       * Restore all attributes to their original values
       * 
       * @method reset
       * @chainable
       */

    }, {
      key: "reset",
      value: function reset() {
        var _this8 = this;

        underscore.each(this.originalValues, function (value, key) {
          _this8.set(key, value);
        });

        return this;
      } //////////////////////////
      // Forms and validation //
      //////////////////////////

    }, {
      key: "getValidationRules",
      value: function getValidationRules() {
        var formKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
        // Check definition
        var def = this.getDefinition();

        if (def) {
          var rules = def.validationRules[formKey];
          return rules ? rules : null;
        } else {
          return null;
        }
      } ///////////////////////
      // Dirtying of model //
      ///////////////////////

      /**
       * @method getDirty
       * @return {Object} Key/value hash containing dirty attributes
       */

    }, {
      key: "getDirty",
      value: function getDirty() {
        var _this9 = this;

        // Get dirty values
        var dirty = {};

        underscore.each(this.attributes, function (value, key) {
          // Not in original or changed?
          if (_this9.isDirty(key)) {
            // Then it's dirty
            dirty[key] = value;
          }
        });

        return dirty;
      }
      /**
       * Determine whether the model, or a specific attribute is dirty
       * (meaning it has been changed since initialization or Api update)
       * 
       * @method isDirty
       * @param  {string}  [key]    Optional attribute name
       * @return {Boolean}     
       */

    }, {
      key: "isDirty",
      value: function isDirty() {
        var _this10 = this;

        var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        // Specific key?
        if (key) {
          // Get value
          var newValue = this.attributes[key];
          var oldValue = this.originalValues[key]; // None at all?

          if (newValue === undefined) return false; // Is the value computed?

          if (newValue instanceof ComputedProperty) return false; // Is it new?

          if (newValue !== undefined && oldValue === undefined) return true; // Cast original value for comparison with new value

          oldValue = this.castValue(key, oldValue); // Has it changed

          return !Utils.areEqual(oldValue, newValue);
        } else {
          // Loop to see if anything is dirty
          for (var _key in this.attributes) {
            if (this.isDirty(_key)) return true;
          } //check relationships with touchLocalOnUpdate


          var dirtyRelation = underscore.find(this.related, function (rel, key) {
            if (_this10.getRelationship(key) && _this10.getRelationship(key).touchLocalOnUpdate) {
              return rel.isDirty();
            }

            return false;
          });

          return !!dirtyRelation;
        }
      }
      /**
       * Reset dirtyness of model, for given key of for whole model
       *
       * @method resetDirty
       * @param  {string|array} [keys]  	Optional attribute name(s)
       * @chainable
       */

    }, {
      key: "resetDirty",
      value: function resetDirty() {
        var _this11 = this;

        var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        // Null?
        if (keys === null) keys = underscore.keys(this.attributes);
        if (typeof keys === 'string') keys = [keys]; // Specific key?

        underscore.each(keys, function (key) {
          _this11.originalValues[key] = _this11.uncastValue(key, _this11.attributes[key]);
        });

        return this;
      }
      /**
       * Check the current dirty state of the model and update
       * its status value.
       *
       * @method updateDirty
       * @chainable
       */

    }, {
      key: "updateDirty",
      value: function updateDirty() {
        var isDirty = this.isDirty();

        if (isDirty !== this.get('isDirty')) {
          this.state.set('dirty', this.isDirty());
        }

        return this;
      }
    }, {
      key: "_scheduleUpdateDirty",
      value: function _scheduleUpdateDirty() {
        var _this12 = this;

        // Already going?
        if (this._scheduleUpdateDirtyTimeout) return; // Wait a bit

        this._scheduleUpdateDirtyTimeout = setTimeout(function () {
          _this12.updateDirty();

          _this12._scheduleUpdateDirtyTimeout = null;
        }, Model.UpdateDirtyDelay);
      } ///////////////////
      // Relationships //
      ///////////////////

      /**
       * Set the given model as the value of a relationship
       * 
       * @method setRelatedModel
       * @param {string} relationshipName 
       * @param {Data.Model} relatedModel    
       * @chainable
       */

    }, {
      key: "setRelatedModel",
      value: function setRelatedModel(relationshipName, relatedModel) {
        // Get the relationship itself
        var relationship = this.getRelationship(relationshipName);
        if (!relationship) throw new Error('Error trying to set related model; there is no relationship defined on "' + this.getModelName() + '" by the name "' + relationshipName + '"'); // Is there a model?

        if (relatedModel) {
          // Check where the key is stored and set it
          if (relationship.isStoredOnLocalModel()) {
            // Get the remote key's value and set it on the local key
            this.set(relationship.localKey, relatedModel.get(relationship.remoteKey)); // Morph too?

            if (relationship.morphModelKey) {
              // Add model type
              this.set(relationship.morphModelKey, relationship.getMorphModelValue(relatedModel));
            }
          } else if (relationship.isStoredOnRemoteModel()) {
            // Get the local key's value and set it on the remote key
            relatedModel.set(relationship.remoteKey, this.get(relationship.localKey));
          }
        } else if (relatedModel === null) {
          // Unset it
          if (relationship.isStoredOnLocalModel()) {
            // Unset the local key
            this.set(relationship.localKey, null);
          }
        }

        this.related[relationshipName] = relatedModel; // Trigger

        this._scheduleAttributeChanged(relationshipName);

        return this;
      }
      /**
       * Add the given model to a relationship collection
       *
       * @method addRelatedModel
       * @param {string} relationshipName 
       * @param {Data.Model} relatedModel     
       * @param {boolean} fromApi		
       * @chainable
       */

    }, {
      key: "addRelatedModel",
      value: function addRelatedModel(relationshipName, relatedModel) {
        var _this13 = this;

        var fromApi = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var pivotAttributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        // Check if collection exists
        var relationship = this.getRelationship(relationshipName);

        if (this.related[relationshipName] === undefined) {
          // Make collection
          if (relationship) {
            this.related[relationshipName] = relationship.getInitValue();
          } else {
            this.related[relationshipName] = new Collection(relatedModel.constructor);
          }
        } // Is it a valid collection?
        else if (!(this.related[relationshipName] instanceof Collection)) {
            throw new TypeError('Tried to add a related model to an existing object that is not a Collection');
          } // Check relationship


        if (relationship && relationship.isPivot() && relatedModel.isPivot) {
          // Create pivot wrapper
          var Pivot = ClassMap.get('Pivot');
          relatedModel = Pivot.createFor(relatedModel, pivotAttributes);
        } // Add model


        var coll = this.related[relationshipName];

        if (fromApi) {
          coll.addFromApi(relatedModel);
        } else {
          coll.add(relatedModel);
        } // Set the inverse?


        if (relationship && relationship.inverseRelationshipName && relatedModel.hasRelationship(relationship.inverseRelationshipName)) {
          // Set it
          relatedModel.withoutNotifications(function () {
            relatedModel.setRelatedModel(relationship.inverseRelationshipName, _this13);
          });
        } // Trigger


        this._scheduleAttributeChanged(relationshipName);

        return this;
      }
    }, {
      key: "deleteRelatedModel",
      value: function deleteRelatedModel(relationshipName, model) {
        // Check if collection exists
        var relationship = this.getRelationship(relationshipName);

        if (!(this.related[relationshipName] instanceof Collection)) {
          throw new TypeError('Tried to delete a related model from a non-existing relationship');
        } // Remove it


        this.related[relationshipName].delete(model); // Trigger

        this._scheduleAttributeChanged(relationshipName); // Set the inverse?


        if (relationship && relationship.inverseRelationshipName && model.hasRelationship(relationship.inverseRelationshipName)) {
          // Set it
          model.withoutNotifications(function () {
            model.setRelatedModel(relationship.inverseRelationshipName, null);
          });
        }

        return this;
      } //////////////////////
      // Model definition //
      //////////////////////

      /**
       * Get the model class name for the current instance. When no definition was
       * made for this model, 'DefaultModel' will be returned.
       *
       * @method getModelName
       * @return {string} 
       */

    }, {
      key: "getModelName",
      value: function getModelName() {
        var definition = this.getDefinition();
        if (!definition) return 'DefaultModel';
        return definition.name;
      }
      /**
       * Get this model's ModelDefinition. 
       * Can be undefined for non-defined Models.
       *
       * @method getDefinition
       * @return {Data.ModelDefinition}
       */

    }, {
      key: "getDefinition",
      value: function getDefinition() {
        return this.constructor.definition;
      }
    }, {
      key: "getPrimaryKey",
      value: function getPrimaryKey() {
        return this.get(this.getDefinition().primaryKey);
      }
      /**
       * Get the definition for given attribute key. 
       * Can be undefined for non-defined Models, or if the
       * attribute is not defined in the ModelDefinition.
       *
       * @method getAttributeDefinition
       * @param  {string} key
       * @return {Data.ModelAttribute}  
       */

    }, {
      key: "getAttributeDefinition",
      value: function getAttributeDefinition(key) {
        // Check if the model has a definition at all
        var def = this.getDefinition();
        if (!def) return; // Get the attribute

        return def.attributes[key];
      }
    }, {
      key: "getRelationship",
      value: function getRelationship(key) {
        // Check if the model has a definition at all
        var def = this.getDefinition();
        if (!def) return null; // Get the relationship

        var relationship = def.relationships[key];
        return relationship;
      }
    }, {
      key: "hasRelationship",
      value: function hasRelationship(key) {
        return !!this.getRelationship(key);
      }
    }, {
      key: "getRelationshipByLocalKey",
      value: function getRelationshipByLocalKey(key) {
        // Check if the model has a definition at all
        var def = this.getDefinition();
        if (!def) return null; // Is it the local key?

        return def.getRelationshipByLocalKey(key);
      }
    }, {
      key: "isPivot",
      value: function isPivot() {
        return false;
      }
      /**
       * Check whether this instance is the same instance as given parameter.
       *
       * @method is
       * @param  {Chicken.Data.Model}  obj
       * @return {Boolean}     
       */

    }, {
      key: "is",
      value: function is(obj) {
        return Utils.uidFor(this) === Utils.uidFor(obj);
      }
    }, {
      key: "createCopy",
      value: function createCopy() {
        var _this14 = this;

        // Get all attributes
        var attr = {};

        underscore.each(this.attributes, function (value, key) {
          // Not computed?
          if (value instanceof ComputedProperty) return;
          attr[key] = _this14.get(key);
        });

        delete attr.id; // Create model

        var constr = this.constructor;
        var copy = new constr(attr);
        return copy;
      }
      /**
       * Create copy of model and its attributes and relations
       *
       * @method clone
       * @param  {cacheMap}  obj
       * @return {Copy}     
       */

    }, {
      key: "clone",
      value: function clone(cacheMap) {
        var _this15 = this;

        //create cacheMap?
        if (!cacheMap) cacheMap = new Map(); //known in cache map? return it

        if (cacheMap.has(this)) return cacheMap.get(this); //create copy

        var c = this.constructor;
        var copy = new c(); //store in cacheMap

        cacheMap.set(this, copy); // Get all attributes

        var attr = {};

        underscore.each(this.attributes, function (value, key) {
          // Not computed?
          if (value instanceof ComputedProperty) return;
          attr[key] = _this15.get(key);

          if (attr[key] instanceof Model) {
            attr[key] = attr[key].clone(cacheMap);
          } else if (attr[key] instanceof Object && typeof attr[key].clone === 'function') {
            attr[key] = attr[key].clone();
          }
        }); //store attributes


        copy.attributes = attr; //copy relationships

        underscore.each(this.related, function (value, key) {
          if (value) copy.related[key] = value.clone(cacheMap);
        });

        return copy;
      }
      /**
       * Create a shallow clone of the current model, meaning only 
       * the attributes will be copied and the relationships will not be cloned, 
       * but just linked.
       * 
       * @method shallowClone
       * @return {Model} 
       */

    }, {
      key: "shallowClone",
      value: function shallowClone() {
        var _this16 = this;

        // Get all attributes
        var attr = {};

        underscore.each(this.attributes, function (value, key) {
          // Not computed?
          if (value instanceof ComputedProperty) return;
          attr[key] = _this16.get(key);

          if (attr[key] instanceof Model) {
            attr[key] = attr[key].shallowClone();
          } else if (attr[key] instanceof Object && typeof attr[key].clone === 'function') {
            attr[key] = attr[key].clone();
          }
        }); //create copy


        var c = this.constructor;
        var copy = new c(attr); // Relationships

        copy.related = underscore.extend({}, this.related);
        return copy;
      }
    }]);

    return Model;
  }(Observable);
  /**
   * A map of registered model classes
   * 
   * @static
   * @property registry
   * @type {Map}
   */


  Model.registry = new Map();
  /**
   * A map of Model stores, containing loaded records
   *
   * @static
   * @property stores
   * @type {Map}
   */

  Model.stores = new Map();
  /**
   * @static
   * @method getStore
   * @param  {string} modelName 
   * @return {Map}           
   */

  Model.getStore = function (modelName) {
    if (!Model.stores.has(modelName)) {
      Model.stores.set(modelName, new ModelStore(modelName));
    }

    return Model.stores.get(modelName);
  };
  /**
   * @static 
   * @method getFromStaore
   * @param  {string} modelName 
   * @param  {number} id        
   * @return {Data.Model}           
   */


  Model.getFromStore = function (modelName, id) {
    // Is there a store?
    if (!Model.stores.has(modelName)) return null;
    var store = Model.getStore(modelName);
    return store.get(id);
  };

  Model.deleteFromStore = function (modelName, id) {
    //Is there a store
    if (!Model.stores.has(modelName)) return store; //throw new Error('Cannot delete `' + modelName + '` with id `' + id + '` from store. The store cannot be found.');

    var store = Model.getStore(modelName);
    return store.forget(id);
  };
  /**
   * Create a new model instance
   *
   * @static
   * @method create
   * @param  {string} modelName  
   * @param  {Object} [initValues={}]
   * @return {Data.Model}            
   */


  Model.create = function (modelName) {
    var initValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var ModelClass = Model.registry.get(modelName);
    if (!ModelClass) return new Model(initValues);
    return new ModelClass(initValues);
  };
  /**
   * The number of milliseconds to delay checking whether the 
   * model has dirty attributes, after it an attribute has been changed.
   * 
   * @property UpdateDirtyDelay
   * @static
   * @type {Number}
   */


  Model.UpdateDirtyDelay = 100;
  ClassMap.register('Model', Model);

  /**
   * An ApiCall is a once-executing call to the configured API
   * 
   * @param  {Api.Api} api 	The Api instance this call originates from
   * @param  {string} method      The HTTP method to use (get, post, put, etc.)
   * @param  {string} uri			The uri to call
   * @param  {Object} data        
   * @param  {Object} ajaxOptions 	 
   */

  var ApiCall =
  /*#__PURE__*/
  function (_Obj) {
    _inherits(ApiCall, _Obj);

    function ApiCall(api, method, uri) {
      var _this;

      var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var ajaxOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

      _classCallCheck(this, ApiCall);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ApiCall).call(this));
      /**
       * @property api
       * @type {Api.Api}
       */

      _this.api = api;
      /**
       * The HTTP method (get, post, put, patch, or delete)
       * 
       * @property method
       * @type {string}
       */

      _this.method = method;
      /**
       * Data to send along with the request
       * 
       * @property data
       * @type {Mixed}
       */

      _this.data = data;
      /**
       * Configuration options for the Ajax call
       *
       * @property ajaxOptions
       * @type {Object}
       */

      _this.ajaxOptions = ajaxOptions;
      /**
       * Query parameters to add onto the url
       *
       * @property queryParams
       * @type {Object}
       */

      _this.queryParams = queryString.parse(queryString.extract(uri));
      /**
       * @property uri
       * @type {string}
       */

      _this.uri = uri.split('?')[0];
      /**
       * The model class used when it cannot be deduced from the
       * Api result
       * 
       * @property modelClass
       * @type {Class}
       */

      _this.modelClass = null;
      /**
       * When true, the models will be linked to the global Model stores. When false,
       * a local store, specific to this ApiCall, will be used. (Default = true)
       * 
       * @property useGlobalStore
       * @type {Boolean}
       */

      _this.useGlobalStore = api.settings.useGlobalStore;
      /**
       * Local model store, used when useGlobalStore is false.
       * 
       * @property store
       * @type {Object}
       */

      _this.store = {};
      /**
       * @property expectModel
       * @type {Boolean}
       */

      _this.expectModel = false;
      /**
       * @property expectCollection
       * @type {Boolean}
       */

      _this.expectCollection = false;
      /**
       * @property deserializeResult
       * @type {Boolean}
       */

      _this.deserializeResult = true;
      /**
       * when true, the call will resolve with a null value on error. This can be set
       * by using the allowFailure method
       * 
       * @property allowFailure
       * @type {Boolean}
       */

      _this.resolvesOnError = false;
      /**
       * @property doNotExecuteInView
       * @type {Boolean}
       */

      _this.doNotExecuteInView = false;
      return _this;
    }

    _createClass(ApiCall, [{
      key: "serialize",
      value: function serialize() {
        return JSON.stringify(underscore.pick(this, ['uri', 'method', 'data', 'queryParams']));
      }
    }, {
      key: "reset",
      value: function reset() {
        this.resetPromise('complete');
      }
    }, {
      key: "executeHook",
      value: function executeHook(type) {
        var _this2 = this;

        var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        args.unshift(this);

        underscore.each(ApiCall.hooks[type], function (cb) {
          cb.apply(_this2, args);
        });
      }
      /**
       * Execute the Api Call
       *
       * @method execute
       * @return {Promise}
       */

    }, {
      key: "execute",
      value: function execute() {
        var _this3 = this;

        // Do hook
        this.executeHook('beforeExecute'); // Authorize it

        var auth = this.api.getAuth();
        if (auth) auth.authorizeApiCall(this); // Make a promise

        return this.promise('complete', function (resolve, reject) {
          // Combine options
          var queryString$$1 = queryString.stringify(_this3.queryParams);
          if (queryString$$1.length > 0) queryString$$1 = '?' + queryString$$1;
          var options = jquery.extend({
            url: _this3.api.makeUrl(_this3.uri) + queryString$$1,
            method: _this3.method,
            data: _this3.data
          }, _this3.ajaxOptions); // Before send

          var beforeSends = [];
          if (_this3.api.settings.beforeSend) beforeSends.push(_this3.api.settings.beforeSend);
          if (options.beforeSend) beforeSends.push(options.beforeSend);

          options.beforeSend = function (jqXhr, settings) {
            // Loop and exexcute
            underscore.each(beforeSends, function (cb) {
              cb(jqXhr, settings);
            });
          }; // Make the call


          _this3.api.ajax(options).then(function (result, statusText, jqXhr) {
            // 204 (No-Content)?
            if (jqXhr.status === 204 && result === undefined) {
              resolve(null);
              return;
            } //non Resource response type
            //@DEPRECATED! Use doNotDeserialize() instead


            if (result && result.responseType == 'nonResource') {
              resolve(result);
              return;
            } // Deserialize it


            var response;

            if (_this3.deserializeResult) {
              // Deserialize
              response = _this3.api.deserialize(result, _this3); // Do we expect a single model?

              if (_this3.expectModel && response instanceof Collection) {
                response = response.first(); // Or a collection
              } else if (_this3.expectCollection && response instanceof Model) {
                // Make a collection of it
                var coll = new Collection();
                coll.add(response);
                response = coll;
              }
            } else {
              // Use as is
              response = result;
            } // Do hook


            _this3.executeHook('beforeResolve', [response]); // Done!


            resolve(response);
          }).fail(function (error) {
            if (_this3.resolvesOnError) {
              //resolve with null
              resolve(null);
            } else {
              // Make error
              var errorObj = new ApiError(_this3, error);

              if (auth) {
                errorObj = auth.processApiError(errorObj);
              }

              reject(errorObj);
            }
          });
        });
      } ////////////
      // Stores //
      ////////////

    }, {
      key: "useLocalStore",
      value: function useLocalStore() {
        var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this.useGlobalStore = !value;
        return this;
      }
    }, {
      key: "allowFailure",
      value: function allowFailure() {
        var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this.resolvesOnError = value;
        return this;
      }
    }, {
      key: "getResponseModel",
      value: function getResponseModel(modelName, id) {
        // Global?
        if (this.useGlobalStore) {
          // Get from Model store
          return Model.getFromStore(modelName, id);
        } else {
          // Known?
          if (this.store[modelName] === undefined) return null;
          return this.store[modelName][id];
        }
      }
    }, {
      key: "storeReponseModel",
      value: function storeReponseModel(model) {
        // Global?
        if (this.useGlobalStore) {
          // Store it
          var store = Model.getStore(model.getModelName());
          store.set(model.get('id'), model);
        } else {
          // Set it locally
          var modelName = model.getModelName();
          if (this.store[modelName] === undefined) this.store[modelName] = {};
          this.store[modelName][model.get('id')] = model;
        }

        return this;
      }
      /**
       * Add given key/value(s) to the queryParams
       *
       * @method query
       * @param  {string|Object} keyOrHash  Either a key or a key/value hash
       * @param  {Mixed} value     When given a single key/value pair, enter the value as the second argument
       * @chainable
       */

    }, {
      key: "query",
      value: function query(keyOrHash) {
        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        // Is it a key / value?
        if (typeof keyOrHash === 'string') {
          this.queryParams[keyOrHash] = value;
        } else {
          jquery.extend(this.queryParams, keyOrHash);
        }

        return this;
      }
    }, {
      key: "select",
      value: function select(value) {
        return this.query('select', value);
      }
      /**
       * Add given pagination page to the queryParams
       *
       * @method query
       * @param  pageNumber
       * @chainable
       */

    }, {
      key: "page",
      value: function page(pageNumber) {
        var pageSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        // Reset?
        if (pageNumber === false) {
          // Clear
          delete this.queryParams['page[number]'];
          delete this.queryParams['page[size]'];
          return this;
        } // Set it


        if (pageSize !== null) this.pageSize(pageSize);
        return this.query('page[number]', pageNumber);
      }
      /**
       * Add given pagesize to the queryParams
       *
       * @method query
       * @param  pageSize
       * @chainable
       */

    }, {
      key: "pageSize",
      value: function pageSize(_pageSize) {
        return this.query('page[size]', _pageSize);
      }
      /**
       * Set the request data
       * 
       * @method setData
       * @param {mixed} data
       * @chainable
       */

    }, {
      key: "setData",
      value: function setData(data) {
        this.data = data;
        return this;
      }
      /**
       * Do not execute this ApiCall when resolving the View,
       * but instead pass on the ApiCall itself.
       * 
       * @param  {Boolean} doNotExecuteInView 
       * @chainable
       */

    }, {
      key: "doNotExecute",
      value: function doNotExecute() {
        var doNotExecuteInView = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this.doNotExecuteInView = doNotExecuteInView;
        return this;
      }
      /**
       * Do not deserialize the response but return the literal
       * response instead.
       * 	
       * @param  {Boolean} doNotDeserialize 
       * @chainable
       */

    }, {
      key: "doNotDeserialize",
      value: function doNotDeserialize() {
        var _doNotDeserialize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        this.deserializeResult = !_doNotDeserialize;
        return this;
      }
    }]);

    return ApiCall;
  }(Obj);

  ApiCall.hooks = {
    beforeExecute: [],
    beforeResolve: []
  };

  ApiCall.hook = function (type, callback) {
    if (underscore.contains(ApiCall.hooks, type)) throw new Error('Unknown ApiCall hook, use on of the following: ' + underscore.keys(ApiCall.hooks).join(', '));
    ApiCall.hooks[type].push(callback);
  };

  /**
   * @module Dom
   */

  var View =
  /*#__PURE__*/
  function (_Observable) {
    _inherits(View, _Observable);

    /**
     * ## Creating a View
     * 
     * A View is the part where your HTML and data come together. A View
     * can be created directly:
     *
     * 	var view = new Chicken.Dom.View(source);
     *
     * Or shortly:
     *
     * 	var view = Chicken.view(source);
     *
     * A View can be created with three different `source` types:
     * - HTML string
     * - Name of a view template
     * - And URL to a view template
     *
     * ## HTML
     *
     * The following example should be self-explanatory:
     *
     * 	Chicken.application($('#application'))
     * 		.routes(function() {
     *
     *			this.route('/', () => {
     *
     *				return Chicken.view('<h1>{{ title }}</h1>')
     *					.with('title', 'Page title');
     * 
     *			});
     * 
     * 		});
     *
     * Note: The `source` parameter is recognized as HTML when it starts with an HTML tag.
     *
     * ## By name
     *
     * If you want to put your templates in separate files, you can use 'names' to
     * link to them. Use `.` in the name in place of a path seperator. Some examples:
     *
     * 	Chicken.view('home');               // Will open /views/home.hbs
     * 	Chicken.view('product.index');      // Will open /views/product/index.hbs
     * 	Chicken.view('a.b.c.d');            // Will open /views/a/b/c/d.hbs
     *
     * You can configure the default path and extension in your Application configuration.
     *
     * Note: Only use lowercase, numbers, and dashes in your names (`/[a-z0-9\-]/`)
     *
     *
     * ## By URL
     *
     * This is pretty self-explanatory; the principle is the same as 'by name', only 
     * here you pass a relative or absolute url instead:
     *
     * 	Chicken.view('/weird-location/template.xxx');
     * 	Chicken.view('//my-domain.com/chicken-templates/welcome.hbs');
     * 
     * @class Dom.View
     * @extends Core.Observable
     *
     * @constructor
     * @param {string} source   			The source for the view
     * @param {Dom.Renderer} renderer 		The Renderer instance that will be used by HTMLBars
     */
    function View(source) {
      var _this;

      var initCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var renderer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      _classCallCheck(this, View);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(View).call(this));
      /**
       * Promises for data to load, keyed by the key
       * as provided in the `with` method
       * 
       * @property dataPromises
       * @type {Object}
       */

      _this.dataPromises = {};
      /**
       * @property dataExpectations
       * @type {Object}
       */

      _this.dataExpectations = {};
      /**
       * All promises that need to resolve for the 
       * page to load.
       *
       * @property loadPromises
       * @type {Array}
       */

      _this.loadPromises = [];
      /**
       * @property templateString
       * @type {string}
       */

      _this.templateString = null;
      /**
       * @property source
       * @type {string}
       */

      _this.source = source;
      /**
       * @property template
       * @type {HTMLBars template}
       */

      _this.template = null;
      /**
       * @property templateUrl
       * @type {string}
       */

      _this.templateUrl = null;
      /**
       * The prefix to add before translations when in the view
       * a translate key starts with a dot (e.g. {{t ".title"}} )
       * 
       * @property translationKeyPrefix
       * @type {string}
       */

      _this.translationKeyPrefix = null;
      _this.tkp = null;
      /**
       * @property actions
       * @type {Object}
       */

      _this.actions = {};
      /**
       * Local DOM helpers that only apply to this view
       * 
       * @property helpers
       * @type {Object}
       */

      _this.helpers = {};
      /**
       * @property components
       * @type {Object}
       */

      _this.components = {};
      /**
       * When active this view will render and update when
       * the data changes.
       * 
       * @property isActive
       * @type {Boolean}
       */

      _this.isActive = true;
      /**
       * @property bindings
       * @type {Set}
       */

      _this.bindings = new Set();
      /**
       * @property renderer
       * @type {Dom.Renderer}
       */

      _this.renderer = renderer ? renderer : App().config('renderer');
      /**
       * The RenderResult gotten back from the Template rendering.
       * 
       * @property renderResult
       * @type {HTMLBars.RenderResult}
       */

      _this.renderResult = null;
      /**
       * The DocumentFragment that is the rendered view.
       * 
       * @property documentFragment
       * @type {DocumentFragment}
       */

      _this.documentFragment = null;
      /**
       * The jQuery version of the DocumentFragment, that can be 
       * used to manipulate the view's contents.
       * 
       * @property $element
       * @type {jQuery}
       */

      _this.$element = null;
      /**
       * @property apiCalls
       * @type {Array}
       */

      _this.apiCalls = [];
      _this.hooks = {
        beforeRender: [],
        beforeLeave: []
      }; //////////////////////////
      // Check out the source //
      //////////////////////////
      // No template (just yield)?

      if (source === false) {
        _this.templateString = '{{yield}}';
      } // Is it HTML?		
      else if (/^\<[a-z\!]/.test(source) || /^{{/.test(source)) {
          // Use code now
          _this.templateString = source;
        } // Name?
        else if (/[a-z0-9\-]+\./.test(source) || /^[a-zA-Z]+$/.test(source)) {
            // Set translation prefix?
            if (_this.constructor === View && View.AutoTranslationPrefix) {
              _this.translationPrefix(source);
            } // Is it cached?


            if (View.TemplateCache.has(source)) {
              // Use it.
              _this.templateString = View.TemplateCache.get(source);
            } else {
              // Load template
              var url = App().uri(App().config('viewPath'), source.split(/\./).join('/'), '.' + App().config('viewExtension'));
              _this.templateUrl = url;
            }
          } // Url.
          else {
              // Load it
              _this.templateUrl = url;
            } // Definition callback?


      if (initCallback) {
        initCallback.apply(_assertThisInitialized(_assertThisInitialized(_this)));
      }

      return _this;
    }

    _createClass(View, [{
      key: "beforeRender",
      value: function beforeRender(callback) {
        this.hooks.beforeRender.push(callback);
        return this;
      }
    }, {
      key: "beforeLeave",
      value: function beforeLeave(callback) {
        this.hooks.beforeLeave.push(callback);
        return this;
      }
    }, {
      key: "loadTemplate",
      value: function loadTemplate() {
        var _this2 = this;

        // Already loading or loaded?
        if (this._promises.has('template')) {
          return this.getPromise('template');
        } // Promise.


        var promise = this.promise('template', function (resolve, reject) {
          // Do we have the template already?
          if (_this2.templateString) {
            resolve(_this2.templateString);
            return;
          } // Load it.


          jquery.ajax(_this2.templateUrl).then(function (result) {
            // Set template code
            _this2.templateString = result; // We're done.

            resolve(result);
          }).fail(function (error) {
            reject(error.responseText);
          });
        }); // Add and return

        this.loadPromises.push(promise);
        return promise;
      }
      /**
       * To add data to the view, you can use the **with** method. The simplest way is to
       * call it using a **key** and a **value**:
       *
       * 	Chicken.view('page').with('title', 'Page title')
       *
       * You can also add a promise-returning method, such as:
       *
       * 	Chicken.view('product.index')
       * 		.with('products', Chicken.api('/products'));
       *
       * The view will then wait for the Api call to finish, before showing, so that you
       * can use the `products` collection your view.
       *
       * The same goes for a single model:
       *
       * 	Chicken.view('product.show')
       * 		.with('product', Chicken.api('/product/' + this.parameters.get('id')));
       * 
       * When you have multiple data variables you want to pass to the view, you
       * can also use object notation:
       *
       * 	Chicken.view('product.index')
       * 		.with({
       * 			products: Chicken.api('/products'),
       * 			categories: Chicken.api('/categories')
       * 		});
       *
       * 
       * 
       * @method with
       * @param  {...mixed} args   This method can be called in two ways. See documentation
       * @chainable
       */

    }, {
      key: "with",
      value: function _with() {
        var _this3 = this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        // Is it a single object hash?
        if (args.length === 1 && _typeof(args[0]) === 'object') {
          // Do an each
          underscore.each(args[0], function (value, key) {
            _this3.with(key, value);
          });
        } else {
          // Use key/value
          var key = args[0],
              value = args[1]; // Is the key a string?

          if (typeof key !== 'string') throw new TypeError('[Dom.View] The "with" method accepts either a key, value or hash-object as arguments.'); // Is it an Api call?

          if (value instanceof ApiCall && !value.doNotExecuteInView) {
            // Get the promise and add to api calls list
            this.apiCalls.push(value);
            var promise = this.dataPromises[key] = value.getPromise('complete');
            this.loadPromises.push(promise);
            promise.then(function (result) {
              _this3.withoutNotifications(function () {
                _this3.set(key, result, true, true);
              });
            });
          } // Is the data a promise?
          else if (value instanceof Promise) {
              // Add to promises
              this.dataPromises[key] = value;
              this.loadPromises.push(value);
              value.then(function (result) {
                _this3.withoutNotifications(function () {
                  _this3.set(key, result, true, true);
                });
              });
            } else {
              // Is it a Binding?
              if (value instanceof Binding) {
                // Use value
                value = value.getReference();
              } // Set it now (convert to observables, and do not trigger updates)


              this.withoutNotifications(function () {
                _this3.set(key, value, true);
              });
            }
        }

        return this;
      }
      /**
       * Tell the View to expect given data to present in order to render properly. When this data
       * is not present, the View will throw an error.
       * 
       * @method expect
       * @param  {string}  key          The data key that is expected in order for the View to render properly
       * @param  {Number}  minimumCount (Default = 1) The minimum number of records we expect
       * @param  {Number}  maximumCount (Default = false) The maximum number of recorders we expected
       * @chainable
       */

    }, {
      key: "expect",
      value: function expect(key) {
        var minimumCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var maximumCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        // Set it
        this.dataExpectations[key] = {
          min: minimumCount,
          max: maximumCount
        };
        return this;
      }
    }, {
      key: "action",
      value: function action(key, callback) {
        this.actions[key] = callback;
        return this;
      }
    }, {
      key: "helper",
      value: function helper(key, callback) {
        this.helpers[key] = callback;
        return this;
      }
    }, {
      key: "getHelper",
      value: function getHelper(key) {
        return this.helpers[key] || false;
      }
    }, {
      key: "translationPrefix",
      value: function translationPrefix() {
        var _this4 = this;

        var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        // Store prefix
        if (key === false) key = this.source;
        this.translationKeyPrefix = key;
        this.tkp = key; // Shorthand
        // Register the 'l' helper

        if (this.helpers.l === undefined) {
          this.helper('l', function (params, attributeHash) {
            // Get key
            var key = Utils.getValue(params[0]);
            key = "".concat(_this4.translationKeyPrefix, ".").concat(key); // Translate

            return App().i18n.translate(key, attributeHash, Utils.getValue(params[1]));
          });
        }

        return this;
      }
    }, {
      key: "sendAction",
      value: function sendAction() {
        var _this5 = this;

        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        // Get the callback.
        var actionScope = this;
        var callback = actionScope.actions[name]; // Now call it.

        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        var params = underscore.flatten([underscore.map(args, function (value) {
          return _this5.renderer.hooks.getValue(value);
        }), this, actionScope]);

        callback.apply(actionScope, params);
      }
      /**
       * Render the view!
       *
       * @method render
       * @return {Promise}  The 'render' promise is returned. The 'added' promise will be called
       *                    when the view is added to the DOM.
       **/

    }, {
      key: "render",
      value: function render() {
        var _this6 = this;

        // Make sure the template is loaded
        this.loadTemplate(); // We make the 'render' promise.

        return this.promise('render', function (resolve, reject) {
          // Start api calls.
          underscore.invoke(_this6.apiCalls, 'execute'); /////////////////////////////////////////
          // Wait for all loadPromises to finish //
          /////////////////////////////////////////


          Promise.all(_this6.loadPromises).then(function () {
            // Check present of data
            underscore.each(_this6.dataExpectations, function (options, key) {
              // Get it
              var data = _this6.get(key);

              if (data === undefined) return reject('The View expected ' + key + ' to be present, but it was not.'); // Model or Collection?

              if (!(data instanceof Model || data instanceof Collection)) return reject('The View expected ' + key + ' to be a Model or Collection, but it was a ' + _typeof(data)); // Check count

              if (data instanceof Model && options.min && options.min > 1) return reject('The View expected ' + key + ' to have at least ' + options.min + ' records, only one was present');

              if (data instanceof Collection) {
                if (options.min && data.length < options.min) return reject('The View expected ' + key + ' to have at least ' + options.min + ' records, ' + data.length + ' were present');
                if (options.max && data.length > options.max) return reject('The View expected ' + key + ' to have no more than ' + options.max + ' records, ' + data.length + ' were present');
              }
            });

            _this6.renderSync();

            resolve();
          }, function (error) {
            reject(error);
          });
        });
      }
      /**
       * Render the view synchronously. Only use this when you know all
       * the data is already loaded!
       *
       * @method renderSync
       * @chainable
       */

    }, {
      key: "renderSync",
      value: function renderSync() {
        var _this7 = this;

        /////////////////////
        // Create template //
        /////////////////////
        // Before render hook
        var continueRendering = true;

        underscore.each(this.hooks.beforeRender, function (cb) {
          if (!continueRendering) return;
          var result = cb.apply(_this7);
          if (result === false) continueRendering = false;
        }); // Before render returned false?


        if (!continueRendering) return this; // Render it

        try {
          this.renderResult = this.getTemplate().render(this, this.renderer); // Localize and be done!

          this.documentFragment = this.renderResult.fragment;
          this.resolvePromise('render', this.documentFragment);
        } catch (error) {
          // Enrich error with element-path
          var path = [];

          if (this.renderer.currentMorph && this.renderer.currentMorph.element) {
            var $el = jquery(this.renderer.currentMorph.element);
            $el.parents().addBack().not('html').each(function () {
              var entry = this.tagName.toLowerCase();

              if (this.className) {
                entry += '.' + this.className.replace(/ /g, '.');
              }

              path.push(entry);
            });
            path = path.join(' > ');
          } else {
            path = 'unknown';
          } // Add error stack			

          /* eslint-disable no-console */


          try {
            console.warn(error.stack);
          } catch (e) {}
          /* Nothing */

          /* eslint-enable no-console */
          // Get template source


          var source = this.source;
          var msg = "Error in template \"".concat(source, "\" at \"").concat(path, "\":\n\t").concat(error, "\n");
          this.rejectPromise('ready', msg);
          return this;
        }

        return this;
      }
    }, {
      key: "getTemplate",
      value: function getTemplate() {
        // Create
        if (!this.template) {
          this.template = htmlbarsCompiler_1(this.templateString);
        }

        return this.template;
      }
      /**
       * Have the rendered view be revalidated when it's convenient.
       * 
       * @method scheduleRevalidate
       * @chainable
       */

    }, {
      key: "scheduleRevalidate",
      value: function scheduleRevalidate() {
        var _this8 = this;

        // Still active?
        if (!this.isActive) {
          return this;
        } // Not already pending?


        if (!this.revalidateTimeout) {
          // Wait a bit.
          this.revalidateTimeout = setTimeout(function () {
            // Revalidate!
            _this8.revalidate(); // Check if components are still there


            underscore.each(_this8.components, function (component, key) {
              // Element rendered?
              if (component.$element && component.$element.length > 0) {
                // No longer in DOM
                if (!jquery.contains(document.documentElement, component.$element[0])) {
                  component.destroy();
                  delete _this8.components[key];
                }
              }
            });
          }, View.RevalidationDelay);
        }

        return this;
      }
      /**
       * Revalidate the rendered view. Revalidation means the updating of 
       * 'dirty' elements (morphs). The dirtying is done by the Bindings, set up
       * by the Renderer.
       *
       * If your binding is valid, and components work as the should, you shouldn't 
       * need to call this method. If you do though, it is better to call
       * `scheduleRevalidate` instead, to prevent undue calls.
       * 
       * @method revalidate
       * @chainable
       */

    }, {
      key: "revalidate",
      value: function revalidate() {
        this.trigger('beforeRevalidate');
        if (this.renderResult) this.renderResult.revalidate();
        this.trigger('revalidate');
        View.any.trigger('revalidate', this);
        this.revalidateTimeout = false;
        return this;
      }
      /**
       * Add the view to the ViewContainer, replacing previous contents
       * and making sure the ViewContainer knows it's gotten the view.
       * 
       * @method addToContainer
       * @param {Dom.ViewContainer} viewContainer 
       */

    }, {
      key: "addToContainer",
      value: function addToContainer(viewContainer) {
        // Set view
        viewContainer.setView(this); // Create wrapper

        var $view = jquery('<view/>');
        $view.html(this.documentFragment); // Add to DOM

        viewContainer.setContent($view); // Set element

        this.$element = $view; // Done.

        View.any.trigger('render', $view);
        this.resolvePromise('ready', [this]);
      }
      /**
       * Handle the leaving of the page this View is on, e.g. destroying
       * components.
       *
       * @method leave
       * @return {Promise}
       */

    }, {
      key: "leave",
      value: function leave() {
        var _this9 = this;

        return new Promise(function (resolve, reject) {
          // Before ,leave hook
          var allowLeave = true;

          underscore.each(_this9.hooks.beforeLeave, function (cb) {
            if (allowLeave) {
              var result = cb.apply(_this9);
              if (result === false) allowLeave = false;
            }
          }); // Can't leave?


          if (!allowLeave) return reject(); // I am destroyed

          _this9.isActive = false; // Destroy components

          underscore.each(_this9.components, function (component) {
            component.destroy();
            component.isActive = false;
          }); // Kill bindings


          _this9.bindings.forEach(function (binding) {
            binding.destroy();
          }); // Done.


          resolve();
        });
      }
    }, {
      key: "addBinding",
      value: function addBinding(binding) {
        this.bindings.add(binding);
        return this;
      }
    }]);

    return View;
  }(Observable);
  /**
   * The TemplateCache is used to cache templates by their name. When you are
   * building your application for production, you can also use this to bundle
   * the templates.
   * 
   * @property TemplateCache
   * @static
   * @type {Map}
   */


  View.TemplateCache = new Map();
  /**
   * The number of milliseconds to wait before revalidating your views after
   * a change in the data has occured.
   *
   * This value can be very low, as it is mostly used to bundle changes together
   * that occur semi-simultaneously.
   * 
   * @property RevalidationDelay
   * @static
   * @type {Number}
   */

  View.RevalidationDelay = 3;
  /**
   * When this is true, a translation-prefix will automatically be set
   * upon creation of this View, with the same value as the given source.
   * 
   * @property AutoTranslationPrefix
   * @static
   * @type {Boolean}
   */

  View.AutoTranslationPrefix = false;
  View.any = new Obj();

  /**
   * @module Dom
   */

  var Component =
  /*#__PURE__*/
  function (_View) {
    _inherits(Component, _View);

    /**
     * @class Dom.Component
     * @extends Dom.View
     */
    function Component(name, source, morph, scope, parameters, attributeHash, visitor, subTemplates) {
      var _this;

      var initCallback = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;
      var methods = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : {};
      var renderer = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : null;

      _classCallCheck(this, Component);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Component).call(this, source, null, renderer));
      /**
       * The tag-name that was used to initialize this component
       * 
       * @property name
       * @type {string}
       */

      _this.name = name;
      /**
       * The HTMLBars morph that contains this component
       * 
       * @property morph
       * @type {HTMLBarsMorph}
       */

      _this.morph = morph;
      /**
       * The HTMLBars scope for this component
       * 
       * @property scope
       * @type {Object}
       */

      _this.scope = scope;
      /**
       * The list of non-keyed parameters used in this component
       * 
       * @property parameters
       * @type {array}
       */

      _this.parameters = parameters;
      /**
       * The attribute hash
       *
       * @property attributes
       * @type {object}
       */

      _this.attributes = {};

      underscore.each(attributeHash, function (value, key) {
        // Autocast
        if (value === 'true') {
          value = true;
        } else if (value === 'false') {
          value = false;
        } // Set it.


        _this.attributes[inflection.camelize(key.split('-').join('_'), true)] = value;
      });
      /**
       * The HTMLBars visitor that was used to initialize this component
       *
       * @property visitor
       * @type {object}
       */


      _this.visitor = visitor;
      /**
       * Sub-templates used to yield within the component
       *
       * @property subTemplates
       * @type {object}
       */

      _this.subTemplates = subTemplates;
      /**
       * The tagName that will be used when creating this component. The default
       * value is 'div', but this can be overruled in your handlebar template, or
       * in the initCallback of the component.
       * 
       * @property tagName
       * @type {String}
       */

      _this.tagName = 'div';
      /**
       * The CSS class(es) that will be added to the component upon creation. You can set
       * this value in the initCallback of the component.
       *
       * @property cssClass
       * @type {string}
       */

      _this.cssClass = false;
      /**
       * @property element
       * @type {DOMElement}
       */

      _this.element = null;
      /**
       * The component instance that wrap this component, if any.
       * 
       * @property parentComponent
       * @type {Dom.Component}
       */

      _this.parentComponent = _this.scope.component;

      _this.setSilently('parent', _this.parentComponent); // Do I have a parent?


      if (_this.parentComponent) {
        _this.parentComponent.components[_this.getId()] = _assertThisInitialized(_assertThisInitialized(_this));
        _this.attributes._ = _this.parentComponent;
      }
      /**
       * @property view
       * @type {Dom.View}
       */


      _this.view = _this.scope.view;

      if (_this.view) {
        _this.view.components[_this.getId()] = _assertThisInitialized(_assertThisInitialized(_this));
        if (!_this.parentComponent) _this.set('_', _this.view);
        _this.attributes.$ = _this.view;
      }
      /**
       * The dom-object can be used to listen to dom events on the event
       * 
       * @property dom
       * @type {Core.Obj}
       */


      _this.dom = new Obj();
      /**
       * @property isDestroyed
       * @type {Boolean}
       */

      _this.isDestroyed = false; // Make attributes available

      _this.with(_this.attributes); // Add methods


      jquery.extend(_assertThisInitialized(_assertThisInitialized(_this)), methods); // Before destroy

      _this.hooks.beforeDestroy = []; // Definition callback?

      if (initCallback) {
        initCallback.apply(_assertThisInitialized(_assertThisInitialized(_this)));
      }

      return _this;
    }

    _createClass(Component, [{
      key: "getHelper",
      value: function getHelper(key) {
        // Me?
        if (this.helpers[key]) return this.helpers[key]; // Parent component?

        if (this.parentComponent) return this.parentComponent.getHelper(key); // View

        if (this.view) return this.view.getHelper(key);
        return false;
      }
    }, {
      key: "findParentComponent",
      value: function findParentComponent(key) {
        // My parent?
        if (this.parentComponent) {
          // Am I the one you're looking for?
          if (this.parentComponent.name === key) return this.parentComponent; // Look higher up

          return this.parentComponent.findParentComponent(key);
        } else {
          // No dice.
          return false;
        }
      }
    }, {
      key: "getId",
      value: function getId() {
        // Already set?
        if (!this._id) {
          // Set as attribute
          var id = this.attributes.id;

          if (id) {
            this._id = id;
          } else {
            // Do it by name
            var name = inflection.camelize(this.name.split('-').join('_'), true);
            if (Component.instanceCounts[name] === undefined) Component.instanceCounts[name] = 0;
            Component.instanceCounts[name]++;
            this._id = name + Component.instanceCounts[name];
          }
        }

        return this._id;
      }
    }, {
      key: "sendAction",
      value: function sendAction() {
        var _this2 = this;

        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        // No name given?
        if (name === null) {
          name = this.attributes.action;
        } // Get the callback.


        var actionScope = this.renderer.hooks.getActionScope(this.scope, name);
        if (!actionScope) throw new Error('[Component ' + this.name + '] Could not find action "' + name + '" within the scope');
        var callback = actionScope.actions[name]; // Now call it.

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var params = underscore.flatten([underscore.map(args, function (value) {
          return _this2.renderer.hooks.getValue(value);
        }), this, actionScope]);

        return callback.apply(actionScope instanceof View ? actionScope : this, params);
      }
    }, {
      key: "renderSync",
      value: function renderSync() {
        var _this3 = this;

        // Before render hook
        underscore.each(this.hooks.beforeRender, function (cb) {
          cb.apply(_this3);
        }); // Create the template


        try {
          // Render it
          this.renderResult = this.getTemplate().render(this, this.renderer, {
            scope: this.scope,
            template: this.subTemplates.default
          });
          this.documentFragment = this.renderResult.fragment;
        } catch (error) {
          // Enrich error with element-path
          var path = [];
          var $el = jquery(this.renderer.currentMorph.element);
          $el.parents().addBack().not('html').each(function () {
            var entry = this.tagName.toLowerCase();

            if (this.className) {
              entry += '.' + this.className.replace(/ /g, '.');
            }

            path.push(entry);
          });
          path = path.join(' > '); // Get template source

          var source = this.source;
          if (this.view) source = "".concat(this.name, " in ").concat(this.view.source);
          var msg = "Error in template \"".concat(source, "\" at \"").concat(path, "\":\n\t").concat(error, "\n"); // Add error stack			

          /* eslint-disable no-console */

          try {
            console.warn(error.stack);
          } catch (e) {}
          /* Nothing */

          /* eslint-enable no-console */


          this.rejectPromise('ready', msg);
          return;
        } // Study the object


        this.study(function () {
          _this3.scheduleRevalidate();
        }); // Create the element

        this.element = document.createElement(this.tagName);

        underscore.each(this.attributes, function (value, key) {
          // Check value type
          if (value === 'true') value = true;
          if (value === 'false') value = false;
          if (!(value instanceof Object) && jquery.isNumeric(value) && !/^0/.test(value)) value = parseFloat(value);

          if (value !== _this3.attributes[key]) {
            _this3.attributes[key] = value;
          } // Is it a useful value?


          if (key !== 'title' && (typeof value === 'string' || typeof value === 'number') && value.length < 64) {
            var attrKey = inflection.underscore(key).split('_').join('-');

            _this3.element.setAttribute(attrKey, value);
          }
        });

        this.$element = jquery(this.element);
        this.$element.append(this.documentFragment); // CSS class

        if (this.cssClass) this.$element.addClass(this.cssClass); // Trigger beforeAdded

        this.trigger('beforeAdd', this.$element); // Put element in result

        this.morph.setNode(this.$element[0]); // Done.

        this.trigger('added', this.$element); // Enable DOM events

        this.enableDomEvents(); // Find child components

        if (underscore.size(this.components) > 0) {
          // Wait for the children to complete first
          var promises = underscore.map(this.components, function (child) {
            return child.getPromise('ready');
          });

          Promise.all(promises).then(function () {
            _this3.resolvePromise('ready');

            View.any.trigger('render', _this3.$element);
          });
        } else {
          // We are ready now.
          this.resolvePromise('ready');
          View.any.trigger('render', this.$element);
        }
      }
    }, {
      key: "enableDomEvents",
      value: function enableDomEvents() {
        var _this4 = this;

        // Loop through callbacks
        this.dom._listeners.forEach(function (callbacks, name) {
          // Proper event?
          if (!underscore.contains(Component.DomEventNames, name)) {
            throw new Error('The "' + name + '" event is not a valid DOM event.');
          } // Listen and connect.


          _this4.$element.on(name, function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            args.unshift(name);

            _this4.dom.trigger.apply(_this4.dom, args);
          });
        });
      }
    }, {
      key: "getSubTemplate",
      value: function getSubTemplate(key) {
        var block = templateUtils_2(render, this.subTemplates[key], {
          scope: this.scope
        });
        return block;
      }
    }, {
      key: "getAttribute",
      value: function getAttribute(key) {
        var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var value = this.attributes[key];
        if (value === undefined) value = defaultValue;
        return value;
      }
    }, {
      key: "getAttributes",
      value: function getAttributes() {
        var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        // Get all keys with uiX
        var result = {};
        var regex = prefix ? new RegExp('^' + prefix + '[A-Z]') : false;

        underscore.each(this.attributes, function (value, key) {
          // Prefixed?
          if (regex) {
            // Match?
            if (!regex.test(key)) return; // Remove it

            key = underscore.decapitalize(key.substr(prefix.length));
          } // Value


          if (value !== null && _typeof(value) === 'object' && typeof value.getValue === 'function') {
            value = value.getValue();
          } // Set it


          result[key] = value;
        });

        return result;
      }
    }, {
      key: "get",
      value: function get$$1(key) {
        // Do basics first
        var value = _get(_getPrototypeOf(Component.prototype), "get", this).call(this, key); // Nothing?


        if (value === undefined) {
          // Bubble up.
          if (this.parentComponent) {
            return this.parentComponent.get(key);
          } else if (this.view) {
            return this.view.get(key);
          }
        }

        return value;
      }
      /**
       * Set default values for component attributes. Use this in the initCallback.
       *
       * @method defaults
       * @param  {Object} hash   Key/value pairs
       * @chainable
       */

    }, {
      key: "defaults",
      value: function defaults(hash) {
        var _this5 = this;

        this.withoutNotifications(function () {
          underscore.each(hash, function (value, key) {
            // Set?
            if (_this5.attributes[key] === undefined) {
              _this5.set(key, value);
            }
          });
        });
      }
    }, {
      key: "beforeDestroy",
      value: function beforeDestroy(callback) {
        this.hooks.beforeDestroy.push(callback);
        return this;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        var _this6 = this;

        // I am destroyed
        if (this.isDestroyed) return this;
        this.isDestroyed = true; // Call the hooks

        underscore.each(this.hooks.beforeDestroy, function (cb) {
          cb.apply(_this6);
        });

        return this;
      }
    }]);

    return Component;
  }(View);

  Component.DomEventNames = [// Touch events
  'touchStart', 'touchMove', 'touchEnd', 'touchCancel', // Keyboard
  'keyDown', 'keyUp', 'keyPress', // Mouse
  'mouseDown', 'mouseUp', 'contextMenu', 'click', 'doubleClick', 'mouseMove', 'focusIn', 'focusOut', 'mouseEnter', 'mouseLeave', // Form
  'submit', 'change', 'focusIn', 'focusOut', 'input', // HTML5
  'dragStart', 'drag', 'dragEnter', 'dragLeave', 'dragOver', 'dragEnd', 'drop'];
  Component.registry = new Map();
  Component.instanceCounts = {};

  /**
   * @module Dom
   */

  var ComponentDefinition = function ComponentDefinition(name, source, initCallback) {
    var methods = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var renderer = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

    _classCallCheck(this, ComponentDefinition);

    /**
     * The name of the component. This is also the name you use
     * in your templates, to insert the component.
     * 
     * @property name
     * @type {string}
     */
    this.name = name;
    /**
     * The template source
     *
     * @property source
     * @type {string}
     */

    this.source = source;
    /**
     * The method that is called when the Dom.Component instance is created.
     * 
     * @property initCallback
     * @type {[type]}
     */

    this.initCallback = initCallback;
    /**
     * The Dom.Renderer instance that is used to render the component. This is also the
     * renderer in which this component will be automatically registered as a helper.
     *
     * @property renderer
     * @type {Dom.Renderer}
     */

    this.renderer = renderer ? renderer : App() ? App().config('renderer') : null;
    /**
     * Methods to add to the component prototype.
     * 
     * @property methods
     * @type {object}
     */

    this.methods = methods;
  };

  var filesize_min = createCommonjsModule(function (module) {
  !function(i,e){module.exports?module.exports=e():i.filesize=e();}("undefined"!=typeof window?window:commonjsGlobal,function(){var i={iec:"_Ki_Mi_Gi_Ti_Pi_Ei_Zi_Yi",si:"_K_M_G_T_P_E_Z_Y"};return function(e,_,o){e=Math.abs(e),_||0===_||(_=1);var t="si"==o?1e3:1024,n=0;for(i[o]||(o="si");e>=t;)e/=t,++n;return e.toFixed(_)+" "+i[o].split("_")[n]+"b"}});
  });

  /**
   * @module Dom
   */

  var Helpers =
  /*#__PURE__*/
  function () {
    /**
     * @class Dom.Helpers
     *
     * @constructor 
     * @param  {Dom.Renderer} renderer
     */
    function Helpers(renderer) {
      _classCallCheck(this, Helpers);

      this.renderer = renderer;
    } /////////////
    // Actions //
    /////////////


    _createClass(Helpers, [{
      key: "action",
      value: function action(params, attributeHash, blocks
      /*, morph, renderer, scope, visitor*/
      ) {
        // There should be an ActionBinding for this element
        var element = blocks.element;

        if (element && element.getAttribute('data-chicken-action')) {
          // Get the action
          var binding = ActionBinding.get(element.getAttribute('data-chicken-action'));
          binding.apply();
        } else {
          throw new Error('The "action" keyword was not correctly configured in your Renderer... Or you are trying to add an action to a Component.');
        }
      } /////////////
      // Routing //
      /////////////

    }, {
      key: "link",
      value: function link(params, attributeHash, blocks
      /*, morph, renderer, scope, visitor*/
      ) {
        var _this = this;

        // Check the event
        var eventName = attributeHash.event ? this._getValue(attributeHash.event) : 'click'; // Add listener

        if (blocks.element) {
          // Get element(s)
          var $el = jquery(blocks.element); // Add href and event

          $el.each(function (index, el) {
            // Set href for easy debuggin' and statusbar info
            jquery(el).attr('href', _this._getValue(params[0]));
          }).on(eventName, function (e) {
            e.preventDefault(); // Get uri value

            var uri = _this._getValue(params[0]); // Transition


            var transition = attributeHash.transition ? _this._getValue(attributeHash.transition) : null; // Go there.

            App().goto(uri, null, {}, false, transition);
          });
        }
      }
    }, {
      key: "linkTo",
      value: function linkTo(params, attributeHash, block) {
        var _this2 = this;

        // Find named route
        var name = this._getValue(params[0]); // Relative route?


        if (/^\./.test(name)) {
          // Current name?
          var curName = App().currentRoute.route.name;
          if (!curName) throw new Error('The current route does not have a name, so relative links are not possible from here'); // ..? (Level up)

          while (/^\.\./.test(name)) {
            // Remove last part
            var parts = curName.split(/\./);
            parts.pop();
            curName = parts.join('.');
            name = name.replace(/^\./, '');
          } // Add it.


          name = curName + name; // Remove any trailing dots

          name = name.replace(/\.+$/, '');
        } // Find route


        var route = App().router.namedRoutes.get(name);
        if (!route) throw new Error('There is no route with the name "' + name + '"'); // Make uri

        var attributes = underscore.mapObject(attributeHash, function (value) {
          return _this2._getValue(value);
        });

        var uri = route.makeUrl(attributes); // Query?

        if (attributeHash.query) {
          // Try to decode as JSON
          var query = attributeHash.query;

          if (typeof query === 'string') {
            try {
              // Parse JSON
              query = JSON.parse(query);
            } catch (e) {// Ok, then we use it as it is
            }
          } // Convert to querystring


          if (_typeof(query) === 'object') {
            query = queryString.stringify(query);
          } // Add to URL


          uri = "".concat(uri, "?").concat(query);
        } // Make the link


        return this.link([uri], attributeHash, block);
      }
    }, {
      key: "touchLink",
      value: function touchLink(params, attributeHash, block, morph, renderer, scope, visitor) {
        // Add hammertime
        attributeHash.hammerTime = true;
        if (!attributeHash.event) attributeHash.event = 'tap';
        return this.link(params, attributeHash, block, morph, renderer, scope, visitor);
      }
    }, {
      key: "touchLinkTo",
      value: function touchLinkTo(params, attributeHash, block, morph, renderer, scope, visitor) {
        // Add hammertime
        attributeHash.hammerTime = true;
        if (!attributeHash.event) attributeHash.event = 'tap';
        return this.linkTo(params, attributeHash, block, morph, renderer, scope, visitor);
      } ////////////////////////
      // Control statements //
      ////////////////////////

      /**
       * @method each
       */

    }, {
      key: "each",
      value: function each(params, attributeHash, blocks, morph
      /*, renderer, scope, visitor*/
      ) {
        // Check uid for this each-block
        var eachUid = Utils.uidFor(morph); // Get the value

        var list = this._getValue(params[0]);

        Utils.each(list, function (item, i) {
          // Get a unique id for the item.
          var uid = Utils.uidFor(item);
          var itemKey = 'each:' + eachUid + ':' + i + ':' + uid; // Render item

          blocks.template.yieldItem(itemKey, [item, i]);
        });
      }
      /**
       * @method reverseEach
       */

    }, {
      key: "reverseEach",
      value: function reverseEach(params, attributeHash, blocks, morph
      /*, renderer, scope, visitor*/
      ) {
        // Check uid for this each-block
        var eachUid = Utils.uidFor(morph); // Get the value

        var list = this._getValue(params[0]);

        Utils.reverseEach(list, function (item, i) {
          // Get a unique id for the item.
          var uid = Utils.uidFor(item);
          var itemKey = 'each:' + eachUid + ':' + i + ':' + uid; // Render item

          blocks.template.yieldItem(itemKey, [item, i]);
        });
      }
    }, {
      key: "repeat",
      value: function repeat(params, attributeHash, blocks, morph) {
        var repeatUid = Utils.uidFor(morph);

        var times = this._getValue(params[0]);

        for (var q = 0; q < times; q++) {
          var itemKey = 'repeat:' + repeatUid + ':' + q;
          blocks.template.yieldItem(itemKey, [q, q]);
        }
      }
      /**
       * @method if	 
       */

    }, {
      key: "if",
      value: function _if(params, attributeHash, blocks
      /*, morph, renderer, scope, visitor*/
      ) {
        // Get the value
        var value = this._getValue(params[0]);

        return this._ifUnless(params, blocks, Utils.isTruthlike(value));
      }
    }, {
      key: "ifOne",
      value: function ifOne(params, attributeHash, blocks
      /*, morph, renderer, scope, visitor*/
      ) {
        var _this3 = this;

        var trueConditions = underscore.filter(this._getValue(params), function (value) {
          return !!_this3._getValue(value);
        });

        return this._ifUnless(params, blocks, Utils.isTruthlike(trueConditions.length > 0));
      }
    }, {
      key: "ifAll",
      value: function ifAll(params, attributeHash, blocks
      /*, morph, renderer, scope, visitor*/
      ) {
        var _this4 = this;

        var trueConditions = underscore.filter(this._getValue(params), function (value) {
          return !!_this4._getValue(value);
        });

        return this._ifUnless(params, blocks, Utils.isTruthlike(trueConditions.length === params.length));
      }
      /**
       * @method unless
       */

    }, {
      key: "unless",
      value: function unless(params, attributeHash, blocks
      /*, morph, renderer, scope, visitor*/
      ) {
        // Get the value
        var value = this._getValue(params[0]);

        return this._ifUnless(params, blocks, !Utils.isTruthlike(value));
      }
    }, {
      key: "_ifUnless",
      value: function _ifUnless(params, blocks, show) {
        // Is the param truth-like?
        if (show) {
          // Is it a yielding-if?
          if (blocks.template && blocks.template.yield) {
            blocks.template.yield(); // Or parameter-if?
          } else {
            return this._getValue(params[1]);
          }
        } else {
          // Render the inverse yield
          if (blocks.inverse && blocks.inverse.yield) {
            blocks.inverse.yield(); // Or the inverse param
          } else {
            return this._getValue(params[2]);
          }
        }
      } //////////////////////
      // Boolean switches //
      //////////////////////

    }, {
      key: "either",
      value: function either(params) {
        // Look for a truthlike param
        var values = this._getValues(params);

        for (var q = 0; q < values.length; q++) {
          if (Utils.isTruthlike(values[q])) return true;
        }

        return false;
      }
    }, {
      key: "neither",
      value: function neither(params) {
        return !this.either(params);
      }
    }, {
      key: "both",
      value: function both(params) {
        // Look for a non-truthlike param
        var values = this._getValues(params);

        for (var q = 0; q < values.length; q++) {
          if (!Utils.isTruthlike(values[q])) return false;
        }

        return true;
      } ////////////
      // Values //
      ////////////

    }, {
      key: "concat",
      value: function concat(params, attributeHash
      /*, blocks, morph, renderer, scope, visitor*/
      ) {
        attributeHash = underscore.defaults(attributeHash, {
          separator: ''
        });
        return this._getValues(params).join(attributeHash.separator);
      }
    }, {
      key: "object",
      value: function object(params, attributeHash) {
        var _this5 = this;

        // Convert attributes to object
        var obj = {};

        underscore.each(attributeHash, function (value, key) {
          obj[key] = _this5._getValue(value);
        });

        return obj;
      }
    }, {
      key: "get",
      value: function get(params) {
        // Get params
        var obj = this._getValue(params[0]);

        var key = this._getValue(params[1]); // Is it an observable?


        if (obj instanceof Observable || obj instanceof ObservableArray) {
          return obj.get(key);
        } else {
          return obj[key];
        }
      }
    }, {
      key: "firstIn",
      value: function firstIn(params) {
        var arr = this._getValue(params[0]);

        if (arr instanceof ObservableArray) {
          return arr.first();
        } else {
          return underscore.first(arr);
        }
      }
    }, {
      key: "equal",
      value: function equal(params) {
        // Get params
        var value1 = this._getValue(params[0]);

        var value2 = this._getValue(params[1]);

        return value1 == value2;
      }
    }, {
      key: "notEqual",
      value: function notEqual(params) {
        return !this.equal(params);
      }
    }, {
      key: "not",
      value: function not(params) {
        var v = this._getValue(params[0]);

        if (v instanceof ObservableArray) v = v.length;
        return !v;
      }
    }, {
      key: "isNull",
      value: function isNull(params) {
        return this._getValue(params[0]) === null;
      }
    }, {
      key: "isSet",
      value: function isSet(params) {
        var value = this._getValue(params[0]);

        return value !== null && value !== undefined;
      }
    }, {
      key: "gt",
      value: function gt(params) {
        // Get params
        var value1 = this._getValue(params[0]);

        var value2 = this._getValue(params[1]);

        return value1 > value2;
      }
    }, {
      key: "gte",
      value: function gte(params) {
        // Get params
        var value1 = this._getValue(params[0]);

        var value2 = this._getValue(params[1]);

        return value1 >= value2;
      }
    }, {
      key: "lt",
      value: function lt(params) {
        // Get params
        var value1 = this._getValue(params[0]);

        var value2 = this._getValue(params[1]);

        return value1 < value2;
      }
    }, {
      key: "lte",
      value: function lte(params) {
        // Get params
        var value1 = this._getValue(params[0]);

        var value2 = this._getValue(params[1]);

        return value1 <= value2;
      }
    }, {
      key: "isObject",
      value: function isObject(params) {
        // Get param
        var value = this._getValue(params[0]);

        return value instanceof Object;
      }
    }, {
      key: "valueOr",
      value: function valueOr(params) {
        var value = this._getValue(params[0]);

        var defaultValue = this._getValue(params[1]);

        return value ? value : defaultValue;
      }
    }, {
      key: "fallback",
      value: function fallback(params) {
        // Loop to find first non-null value
        for (var i in params) {
          var v = this._getValue(params[i]);

          if (v) return v;
        }
      } /////////////
      // Methods //
      /////////////

    }, {
      key: "method",
      value: function method(params) {
        // Get params
        params = this._getValues(params);
        var obj = params.shift(params);
        var key = params.shift(params); // No method

        if (!obj[key]) throw new Error("Problem in 'method'-helper: there is no method '".concat(key, "' on the object")); // Do it.

        return obj[key].apply(obj, params);
      } ////////////
      // Models //
      ////////////

    }, {
      key: "isDirty",
      value: function isDirty(params) {
        // Get params
        var model = this._getValue(params[0]);

        var attributes = [];

        for (var q = 1; q < params.length; q++) {
          attributes.push(this._getValue(params[q]));
        } // Any of those dirty?


        return !!underscore.find(attributes, function (attr) {
          return model.isDirty(attr);
        });
      } //////////////////
      // HTML Helpers //
      //////////////////

    }, {
      key: "attributesFrom",
      value: function attributesFrom(params, attributeHash, blocks, morph) {
        console.log(params, attributeHash, blocks, morph);
      } /////////////
      // Strings //
      /////////////

    }, {
      key: "isNumeric",
      value: function isNumeric(params) {
        var string = this._getValue(params[0]);

        return /^-?\d*(\.\d+)?$/.test(string);
      }
    }, {
      key: "camelize",
      value: function camelize(params) {
        var string = this._getValue(params[0]);

        var capitalFirstLetter = !!this._getValue(params[1]);
        return inflection.camelize(string, !capitalFirstLetter);
      }
    }, {
      key: "string",
      value: function string(params) {
        // First is method, second is str
        var args = this._getValues(params);

        var method = args.shift();
        var str = args.shift();
        if (!str) return null;
        return str[method].apply(str, args);
      }
    }, {
      key: "underscore",
      value: function underscore$$1(params) {
        // First is method, second is str
        var args = this._getValues(params);

        var method = args.shift();
        return underscore[method].apply(this, args);
      } ////////////
      // Arrays //
      ////////////

    }, {
      key: "count",
      value: function count(params) {
        var value = this._getValue(params[0]);

        if (value instanceof Observable) {
          return underscore.size(value.attributes);
        }

        return value.length;
      }
    }, {
      key: "contains",
      value: function contains(params) {
        var list = this._getValue(params[0]);

        var value = this._getValue(params[1]);

        return underscore.contains(list, value);
      } /////////////////////
      // Dates and times //
      /////////////////////

    }, {
      key: "moment",
      value: function moment$$1(params) {
        var value = this._getValue(params[0]);

        if (!moment.isMoment(value)) {
          value = moment(value);
        }

        return value;
      }
    }, {
      key: "momentFormat",
      value: function momentFormat(params) {
        var value = this._getValue(params[0]);

        var format = this._getValue(params[1]);

        if (moment.isMoment(value)) {
          return value.format(format);
        } else {
          return value;
        }
      }
    }, {
      key: "momentIsAfter",
      value: function momentIsAfter(params) {
        var moment1 = this._getValue(params[0]);

        var moment2 = this._getValue(params[1]);

        if (moment.isMoment(moment1) && moment.isMoment(moment2)) {
          return moment1.isAfter(moment2);
        }

        return false;
      }
    }, {
      key: "fileSize",
      value: function fileSize(params) {
        var value = this._getValue(params[0]);

        return filesize_min(value);
      } /////////////
      // Numbers //
      /////////////

    }, {
      key: "add",
      value: function add(params) {
        var values = this._getValues(params);

        return values.reduce(function (total, item) {
          return item + total;
        }, 0);
      }
    }, {
      key: "subtract",
      value: function subtract(params) {
        var values = this._getValues(params);

        var startValue = values.shift();
        return values.reduce(function (total, item) {
          return total - item;
        }, startValue);
      }
    }, {
      key: "numberFormat",
      value: function numberFormat(params) {
        var value = this._getValue(params[0]);

        if (value === undefined) return '';
        return value.toLocaleString(window.Chicken.app.i18n.language);
      }
    }, {
      key: "round",
      value: function round(params) {
        var value = this._getValue(params[0]);

        var digits = params.length > 1 ? this._getValue(params[1]) : 0;

        if (digits > 0) {
          var pow = Math.pow(10, digits);
          return Math.round(value * pow) / pow;
        } else {
          return Math.round(value);
        }
      }
    }, {
      key: "max",
      value: function max(params) {
        var values = this._getValues(params);

        return underscore.max(values);
      }
    }, {
      key: "min",
      value: function min(params) {
        var values = this._getValues(params);

        return underscore.min(values);
      }
    }, {
      key: "multiply",
      value: function multiply(params) {
        var values = this._getValues(params);

        var result = 1;

        underscore.each(values, function (v) {
          result *= parseFloat(v);
        });

        return result;
      } ///////////
      // Debug //
      ///////////

    }, {
      key: "log",
      value: function log(params
      /*, attributeHash, blocks, morph, renderer, scope, visitor*/
      ) {
        console.log.apply(console, this._getValues(params));
      }
    }, {
      key: 'query-params',
      value: function queryParams(params, attributeHash
      /*, blocks, morph, renderer, scope, visitor*/
      ) {
        return queryString.stringify(this._getHashValues(attributeHash));
      } //////////////////
      // Localization //
      //////////////////

    }, {
      key: "t",
      value: function t(params, attributeHash) {
        // Get the key
        var key = this._getValue(params[0]); // Get from app


        return App().i18n.translate(key, attributeHash, this._getValue(params[1]));
      }
    }, {
      key: "tText",
      value: function tText(params, attributeHash) {
        // Get value
        var v = this.t(params, attributeHash); // Plainify

        return jquery('<span>' + v + '</span>').text();
      } //////////////
      // Internal //
      //////////////

    }, {
      key: "_getValue",
      value: function _getValue(param) {
        return this.renderer.hooks.getValue(param);
      }
    }, {
      key: "_getValues",
      value: function _getValues(params) {
        var _this6 = this;

        return params.map(function (value) {
          return _this6._getValue(value);
        });
      }
    }, {
      key: "_getHashValues",
      value: function _getHashValues(attributeHash) {
        var _this7 = this;

        var result = {};

        underscore.each(attributeHash, function (value, key) {
          result[key] = _this7._getValue(value);
        });

        return result;
      }
    }]);

    return Helpers;
  }();

  Helpers.User = {};

  /**
   * @module Dom
   */

  var Renderer =
  /**
   * @class Dom.Renderer
   * 
   * @constructor
   */
  function Renderer() {
    var _this = this;

    _classCallCheck(this, Renderer);

    /**
     * @property dom
     * @type {HTMLBars.DOMHelper}
     */
    this.dom = new DOMHelper();
    /**
     * Hooks are the way to configure the way HTMLBars renders your
     * templates. Renderer comes pre-configured with hooks that allow you
     * to bind to Observables (models) and ObservableArrays (collections).
     * 
     * @property hooks
     * @type {object}
     */

    this.hooks = underscore.defaults({
      /**
       * The `get` hook is responsible for retrieving Bindings from the data store.
       * 
       * @method hooks.get
       * @param  {Renderer} 	renderer   	The Renderer instance (this)
       * @param  {Scope} 		scope 		The Scope in which the `get` was called, 
       *                           		containing the data that is available in this Scope
       * @param  {string} 	path 		The path (key) of the variable to retrieve 		
       * @return {mixed}     	The retrieved value
       */
      get: function get(renderer, scope, path) {
        // Get first part
        var keys = path.split(/\./); // Look into local data

        var appliedScope = scope.self;

        if (scope.localPresent[keys[0]]) {
          appliedScope = scope.locals[keys[0]];
          keys.shift();
          path = keys.join('.');
        } // Is data an observable?


        if (appliedScope instanceof Observable && path.length > 0 || appliedScope instanceof ObservableArray) {
          // Already a binding?
          if (appliedScope._bindings === undefined) appliedScope._bindings = {};

          if (appliedScope._bindings[path]) {
            // Return existing binding
            return appliedScope._bindings[path];
          } // Create a binding


          var binding = new Binding(_this, appliedScope, path); // Store it

          appliedScope._bindings[path] = binding; // Get the value

          return binding;
        } else if (path === '') {
          // Return the scope itself
          return appliedScope;
        } else {
          // Do native thing (deep-get)
          var value = appliedScope;

          for (var q = 0; q < keys.length; q++) {
            if (value === undefined || value === null) return value;
            value = value[keys[q]];
          }
        }

        return value;
      },

      /**
       * Get value from reference (Binding)
       *
       * @method hooks.getValue
       * @param  {Binding} reference 
       * @return {mixed}           
       */
      getValue: function getValue(reference) {
        // Is it a binding?
        if (reference instanceof Binding) return reference.getValue(); // A helper?

        if (reference instanceof HelperProxy) return reference.invoke(); // Just a value

        return reference;
      },

      /**
       * Link a morph to one or more values (in our case Bindings)
       *
       * @method hooks.linksRenderNode
       * @param  {HTMLBarsMorph} morph    
       * @param  {Dom.Renderer} renderer 
       * @param  {Scope} scope    
       * @param  {string} type   				Values can be `@range`, `@attribute`, or helper names
       * @param  {array} values     			Array of values that have been linked to the morph. The should be Binding instances
       * @return 
       */
      linkRenderNode: function linkRenderNode(morph, renderer, scope, type, values) {
        // Add this morph to all involved bindings
        underscore.each(values, function (binding) {
          // Is it a binding?
          if (binding instanceof Binding) {
            binding.addMorph(morph, scope);
          }
        });
      },
      willRenderNode: function willRenderNode(morph
      /*, renderer, scope*/
      ) {
        // Store morph so we can bind it when we get subexpressions, etc
        _this.currentMorph = morph;
      },
      subexpr: function subexpr(renderer, scope, helperName, params, hash) {
        // Loop through parameters to find Bindings
        underscore.each(params, function (param) {
          if (param instanceof Binding) {
            // Add morph
            if (renderer.currentMorph) param.addMorph(renderer.currentMorph, scope);
          }
        }); // Original behavior


        return Hooks.subexpr(renderer, scope, helperName, params, hash);
      },
      createFreshScope: function createFreshScope() {
        return {
          self: null,
          blocks: {},
          locals: {},
          localPresent: {},
          actions: {},
          view: null
        };
      },
      createChildScope: function createChildScope(parentScope) {
        // Create a new scope extending the parent
        var scope = Object.create(parentScope);
        scope.locals = Object.create(parentScope.locals);
        scope.localPresent = Object.create(parentScope.localPresent);
        scope.blocks = Object.create(parentScope.blocks);
        scope.actions = Object.create(parentScope.actions); // Check is parent is a view

        if (parentScope.self instanceof View) {
          // Bubble the actions
          scope.actions = underscore.extend(scope.actions, parentScope.self.actions); // No a component?

          if (!(parentScope.self instanceof Component)) {
            scope.view = parentScope.self;
          } else {
            scope.component = parentScope.self;
            scope.view = scope.component.view;
          }
        }

        return scope;
      },
      findHelper: function findHelper(renderer, scope, helperName) {
        // Scope helper?
        if (scope.self && typeof scope.self.getHelper === 'function') {
          var helper = scope.self.getHelper(helperName);
          if (helper) return helper;
        } // Use helper?


        if (Helpers.User[helperName]) {
          return Helpers.User[helperName];
        } // Chicken helper?


        if (renderer.helpers[helperName]) {
          return renderer.helpers[helperName];
        }
      },
      lookupHelper: function lookupHelper(renderer, scope, helperName) {
        // Find a helper
        var helper = _this.hooks.findHelper(renderer, scope, helperName);

        if (!helper) throw new Error('There is no helper registered with the name "' + helperName + '"'); // Create the wrapper

        var proxy = new HelperProxy(helperName, helper, _this.helpers);
        return proxy;
      },
      invokeHelper: function invokeHelper(morph, renderer, scope, visitor, params, attributeHash, helper, options) {
        // Is it a component?
        if (helper instanceof ComponentDefinition) {
          // Call component hook
          return {
            value: _this.hooks.component(morph, renderer, scope, helper, params, attributeHash, options, visitor)
          };
        } // Do we have a morph?


        if (morph) {
          // Loop through params to hook up bindings
          underscore.each(params, function (value) {
            if (value instanceof Binding) {
              value.addMorph(morph, scope);
            }
          }); // And the attribute


          underscore.each(attributeHash, function (value) {
            if (value instanceof Binding) {
              value.addMorph(morph, scope);
            }
          });
        } // Set arguments 


        helper.setArguments(params, attributeHash, options, morph, renderer, scope, visitor); // Invoke it once to see if the helper returns a value, or is a block-type helper

        var helperResult = helper.invoke();
        var helperValue;

        if (helperResult === undefined) {
          // No result, then we don't want to return a value
          helperValue = undefined;
        } else {
          // A value was returned, meaning this helper is used as a value getter, and might need
          // to be invoked again when bound values change: thus, return the proxy
          helperValue = helper;
        } // Invoke the helper and give back the value


        return {
          value: helperValue,
          link: !!helperValue
        };
      },
      component: function component(morph, renderer, scope, tagName, params, attributeHash, options, visitor) {
        ////////////////////////////////////////////////////////////////
        // Is the component already created, and is this a re-render? //
        ////////////////////////////////////////////////////////////////
        var state = morph.getState();

        if (state.component) {
          state.component.scheduleRevalidate();
          return;
        } ///////////////////////////////////
        // Create the component instance //
        ///////////////////////////////////
        // Get definition


        var definition = Component.registry.get(tagName); // No known component?

        if (!definition) {
          // Do the component fallback.
          var element = renderer.dom.createElement(tagName);

          underscore.each(attributeHash, function (value, key) {
            element.setAttribute(key, renderer.hooks.getValue(value));
          });

          var fragment = render(options.default, renderer, scope, {}).fragment;
          element.appendChild(fragment);
          morph.setNode(element);
          return;
        } // Create a new scope and use the component as self


        var newScope = renderer.hooks.createScope(renderer, scope); // Are there attributes defined as an attribute?

        if (attributeHash && attributeHash.attributes) {
          // A binding?
          var attrs = attributeHash.attributes;
          if (attrs instanceof Binding) attrs = attrs.getValue(); // A hash?

          if (attrs instanceof Object) {
            // Replace
            delete attributeHash.attributes;
            Utils.each(attrs, function (value, key) {
              attributeHash[key] = value;
            });
          }
        } // Create it


        var component = new Component(definition.name, definition.source, morph, newScope, params, attributeHash, visitor, options, definition.initCallback, definition.methods, _this);
        newScope.self = component; // Now render it.

        component.render(); // Store it.

        state.component = component;
      },

      /**
       * Check if the given path is a known class (component, or block, inline)
       *
       * @method hooks.classify
       * @param  {Dom.Renderer} renderer 
       * @param  {Object} scope    
       * @param  {string} path     
       * @return {string}          
       */
      classify: function classify(renderer, scope, path) {
        // Is this a known component?
        if (Component.registry.has(path)) return 'component'; // Nothing known.

        return false;
      },
      getBlock: function getBlock(scope, key) {
        // Is the block known?
        var block = scope.blocks[key];
        if (block) return block; // Are we inside a component?

        if (scope.self instanceof Component) {
          return scope.self.getSubTemplate(key);
        } // Nothing there


        return null;
      },
      getActionScope: function getActionScope(scope, key) {
        // Check the scope
        if (scope.actions && scope.actions[key]) {
          return scope;
        } else if (scope.locals.actions && scope.locals.actions[key]) {
          // Use local action
          return scope.locals;
        } else if (scope.self.actions && scope.self.actions[key]) {
          // Use that
          return scope.self;
        } else if (scope.view && scope.view.actions && scope.view.actions[key]) {
          // Use the veiw
          return scope.view;
        } else {
          return false;
        }
      },
      getAction: function getAction(scope, key) {
        var appliedScope = _this.hooks.getActionScope(scope, key);

        if (appliedScope) {
          // Get the action
          return appliedScope.actions[key];
        }

        return false;
      },
      keywords: underscore.defaults({
        /**
         * The action keyword creates an ActionBinding instance and 
         * stores it on the element. The `action` helper can then use 
         * this ActionBinding to apply it on the DOM.
         *
         * @method keywords.action
         */
        action: function action(morph, renderer, scope, params, attributeHash) {
          // Check binding
          if (morph.actionBindings) return; // Get action scope

          var actionCallback = renderer.hooks.getAction(scope, params[0]);

          if (!actionCallback) {
            // Lazy action?
            if (attributeHash.lazy === true) {
              // Use current scope so send action lazily
              actionCallback = function actionCallback() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                scope.self.sendAction(params[0], args);
              };
            } else {
              // Undefined action.
              throw new Error("Could not find action \"".concat(params[0], "\" within the scope"));
            }
          } // Get action


          var parameters = params.slice(1); // Create action binding

          var binding = new ActionBinding(renderer, morph, params[0], actionCallback, parameters, attributeHash, scope.self);
          morph.actionBindings = binding;
        }
      }, Hooks.keywords)
    }, Hooks);
    /**
     * @property helpers
     * @type {Dom.Helpers}
     */

    this.helpers = new Helpers(this);
    /**
     * @property partials
     * @type {Object}
     */

    this.partials = {};
    /**
     * @property useFragmentCache
     * @default true
     * @type {Boolean}
     */

    this.useFragmentCache = true;
  };

  var Redirect =
  /*#__PURE__*/
  function () {
    function Redirect(uri) {
      _classCallCheck(this, Redirect);

      this.uri = uri;
      this.flash = {};
    }

    _createClass(Redirect, [{
      key: "with",
      value: function _with(dataOrKey) {
        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        // Value?
        var data = dataOrKey;

        if (value) {
          data = {};
          data[dataOrKey] = value;
        }

        jquery.extend(this.flash, data);
        return this;
      }
    }, {
      key: "withError",
      value: function withError(message) {
        return this.with('error', message);
      }
    }]);

    return Redirect;
  }();

  /**
   * @module Routing
   */
  var Controller =
  /*#__PURE__*/
  function () {
    /**
     * @class Routing.Controller
     * 
     * @constructor
     * @param {Routing.Action} action  The routing action that leads to the creation of this controller
     */
    function Controller(action, application) {
      _classCallCheck(this, Controller);

      /**
       * @property action
       * @type {Routing.Action}
       */
      this.action = action;
      /**
       * @property application
       * @type {Application}
       */

      this.application = application;
    } ////////////////
    // Properties //
    ////////////////

    /**
     * Request parameters
     * 
     * @property parameters
     * @type {Map}
     */


    _createClass(Controller, [{
      key: "parameters",
      get: function get() {
        return this.action.parameters;
      }
      /**
       * The ViewContainer into which this controller action will render
       * 
       * @property viewContainer
       * @type {Dom.ViewContainer}
       */

    }, {
      key: "viewContainer",
      get: function get() {
        return this.action.viewContainer;
      }
      /**
       * @property request
       * @type {Routing.Request}
       */

    }, {
      key: "request",
      get: function get() {
        return this.action.request;
      }
      /**
       * @property route
       * @type {Routing.Route} 
       */

    }, {
      key: "route",
      get: function get() {
        return this.action.route;
      }
    }]);

    return Controller;
  }();

  Controller.registry = new Map();

  /**
   * @module Routing
   */
  var RoutingError = function RoutingError(code) {
    var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var request = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _classCallCheck(this, RoutingError);

    this.code = code;
    this.message = message;
    this.request = request;
  };

  /**
   * @module Routing
   */

  var Action =
  /*#__PURE__*/
  function (_Obj) {
    _inherits(Action, _Obj);

    /**
     * @class Routing.Action
     * @extends Core.Obj
     */
    function Action(targetViewContainer, controllerActionOrCallback, request) {
      var _this;

      _classCallCheck(this, Action);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Action).call(this)); ////////////////
      // Attributes //
      ////////////////

      /**
       * The name of the ViewContainer that this action is targeting.
       * 
       * @property targetViewContainer
       * @type {string}
       */

      _this.targetViewContainer = targetViewContainer;
      /**
       * The Request instance that was used to create this action
       * 
       * @property request
       * @type {Routing.Request}
       */

      _this.request = request;
      /**
       * The Route that defined this action
       *
       * @property route
       * @type {Routing.Route}
       */

      _this.route = null;
      /**
       * The Route that matched the Request
       *
       * @property matchedRoute
       * @type {Routing.Route}
       */

      _this.matchedRoute = null;
      /**
       * The RouteMatch that this Action is a part
       *
       * @property routeMatch
       * @type {Routing.RouteMatch}
       */

      _this.routeMatch = null;
      /**
       * The instance of the Controller that has been created by 
       * this action.
       * 
       * @property controller
       * @type {Routing.Controller}
       */

      _this.controller = null;
      /**
       * The name of the Controller class used by this action
       * 
       * @property controllerClass
       * @type {string}
       */

      _this.controllerClass = null;
      /**
       * The name of the Controller method used by this action
       * 
       * @property controllerMethod
       * @type {string}
       */

      _this.controllerMethod = null;
      /**
       * A callback function, when the route did not configure
       * a Controller to be used, but an inline callback instead.
       * 
       * @property callback
       * @type {function}
       */

      _this.callback = false;
      /**
       * The name of the transition animation to use to get from 
       * previous View to new View
       * 
       * @property transition
       * @type {string}
       */

      _this.transition = null;
      /**
       * A map of request parameters that are supplied to this action.
       * 
       * @property parameters
       * @type {Map}
       */

      _this.parameters = new Map();
      /**
       * An array of request parameters, in the order of the route's
       * pattern definition
       *
       * @property parameterArray
       * @type {Array}
       */

      _this.parameterArray = [];
      /**
       * An array of other Actions that this Action depends on, 
       * meaning it will wait for them to finish, before executing.
       *
       * This is useful when you have a route where the second action
       * renders into a ViewContainer that is created by the first action.
       * Child routes will automatically wait for the parent route to finish
       * before running it's own actions.
       * 
       * @property dependsOn
       * @type {Array}
       */

      _this.dependsOn = [];
      /**
       * The result of the Action once it has been executed
       *
       * @property result
       * @type {mixed}
       */

      _this.result = false; ///////////////////////////
      // Check passed argument //
      ///////////////////////////

      if (typeof controllerActionOrCallback === 'string') {
        // A view uri?
        if (controllerActionOrCallback.match(/^[a-z\-\d\.]+$/)) {
          // Create a simple view callback
          _this.callback = function () {
            return new View(controllerActionOrCallback);
          };
        } else {
          // Parse controller name
          var match = xregexpAll.exec(controllerActionOrCallback, Action.getControllerActionRegExp());
          if (!match) throw new TypeError('Invalid action string: ' + controllerActionOrCallback + '. Use controller@method format.'); // Store this

          _this.controllerClass = match.class;
          _this.controllerAction = match.action;
        }
      } else if (typeof controllerActionOrCallback === 'function') {
        // Store it
        _this.callback = controllerActionOrCallback;
      } else {
        throw new TypeError('[Routing.Action] Did not understand action: ' + controllerActionOrCallback);
      }

      return _this;
    }

    _createClass(Action, [{
      key: "execute",
      value: function execute(application) {
        var _this2 = this;

        // Make the promise
        return this.promise('complete', function (resolve, reject) {
          // Get the view container
          _this2.viewContainer = application.getViewContainer(_this2.targetViewContainer);

          if (_this2.viewContainer === undefined) {
            reject('There is no ViewContainer available with the name "' + _this2.targetViewContainer + '"');
            return;
          } // Is there currently an action in this vc?


          if (_this2.viewContainer.currentAction) {
            // Was it triggered by the same route?
            if (Utils.uidFor(_this2.viewContainer.currentAction.route) === Utils.uidFor(_this2.route)) {
              // Are the arguments the same as well?
              var currentParams = JSON.stringify(_this2.viewContainer.currentAction.parameterArray);
              var newParams = JSON.stringify(_this2.parameterArray);

              if (currentParams === newParams) {
                // Does the route depend on queryString, and did that change?
                if (_this2.viewContainer.currentAction.route.acceptsQuery) ; else if (underscore.size(_this2.request.flash) > 0 && _this2.viewContainer.currentAction.route.acceptsFlash) ; else {
                  // That means, we've just navigated within nested routes of that page, and this action can be skipped.
                  resolve();
                  return;
                }
              }
            }
          } // The VC is busy now.


          _this2.viewContainer.setLoading(true); ////////////////
          // Controller //
          ////////////////


          if (_this2.controllerClass) {
            // Make controller
            var ChickenController = Controller.registry.get(_this2.controllerClass);

            if (ChickenController === undefined) {
              _this2._handleError('No controller defined with name "' + _this2.controllerClass + '"');

              return;
            }

            _this2.controller = new ChickenController(_this2); // Call action

            var controllerAction = _this2.controller[_this2.controllerAction];

            if (controllerAction === 'undefined' || typeof controllerAction !== 'function') {
              _this2._handleError('There is no action on the "' + _this2.controllerClass + '" controller with the name "' + _this2.controllerAction + '"');

              return;
            } // Make the call


            var actionResult;

            try {
              actionResult = controllerAction.apply(_this2.controller, _this2.parameterArray);
            } catch (error) {
              _this2._handleError(error, resolve, reject);

              return;
            }

            _this2._processResult(actionResult, resolve, reject);
          } //////////////
          // Callback //
          //////////////
          else if (_this2.callback) {
              // Do the callback
              _this2._processResult(_this2.callback.apply(_this2.controller, _this2.parameterArray), resolve, reject);
            } else {
              reject('There is no controller or callback defined... This shouldn\'t happen.');
              return;
            }
        }).then(function (result) {
          // Store result
          _this2.result = result;
        }, function ()
        /* error */
        {
          // No longer loading
          if (_this2.viewContainer) _this2.viewContainer.setLoading(false);
        });
      }
    }, {
      key: "leave",
      value: function leave() {
        // View?
        if (this.result instanceof View) {
          return this.result.leave();
        } // Leaving is fine.


        return new Promise(function (resolve) {
          resolve();
        });
      }
    }, {
      key: "_processResult",
      value: function _processResult(result, resolve, reject) {
        var _this3 = this;

        /////////////////////////////////////
        // A 404 in the controller action? //
        /////////////////////////////////////
        if (result === false) {
          result = new RoutingError(404, 'Not found');
        } /////////////////
        // A redirect? //
        /////////////////


        if (result instanceof Redirect) {
          //@TODO Cancel the running request?
          App().goto(result.uri, null, result.flash);
        } //////////////////////
        // A routing error? //
        //////////////////////
        else if (result instanceof RoutingError) {
            // Handle it
            this._handleError(result, resolve, reject);
          } ///////////////////////////
          // Is the result a view? //
          ///////////////////////////
          else if (result instanceof View) {
              // Render the view
              var view = result;
              view.render().then(function () {
                // Add it
                _this3.viewContainer.setAction(_this3);

                view.addToContainer(_this3.viewContainer);
                resolve(view);
              }, function (error) {
                _this3._handleError(error, resolve, reject);
              });
            } //////////////////////////////
            // Is the result a promise? //
            //////////////////////////////
            else if (result instanceof Promise) {
                // Wait for it to finish
                result.then(function (promiseResult) {
                  // Process result again!
                  _this3._processResult(promiseResult, resolve, reject);
                }, function (error) {
                  _this3._handleError(error, resolve, reject);
                });
              } /////////////////////////////////
              // Is it rendarable by itself? //
              /////////////////////////////////
              else {
                  // A string
                  if (typeof result === 'string' || result instanceof DocumentFragment) {
                    // Set content
                    this.viewContainer.setAction(this);
                    this.viewContainer.setContent(result);
                    resolve(result);
                  } else {
                    // Don't know how to render this...
                    reject('I don\'t know how to render the result for "' + this.targetViewContainer + '"');
                    return;
                  }
                }
      }
    }, {
      key: "_handleError",
      value: function _handleError(error, resolve, reject) {
        // Error object?
        if (typeof error === 'string') {
          error = new Error(error);
        } // Check router error handling, given priority to action, then route


        var route = this.routeMatch.route;
        var errorHandlers = route.router.getErrorHandlers(error, route); // Try to get one

        var handlerResult = false;

        while (errorHandlers.length > 0) {
          // Get next
          var callback = errorHandlers.shift(); // Is the callback actually a string (controller action)?

          if (typeof callback === 'string') {
            // Get the controller action callback
            var _callback$split = callback.split(/@/),
                _callback$split2 = _slicedToArray(_callback$split, 2),
                controllerName = _callback$split2[0],
                action = _callback$split2[1];

            if (controllerName && action) {
              // Same as me?
              var ctrl = void 0;

              if (this.controllerClass === controllerName) {
                ctrl = this.controller;
              } else {
                var ChickenController = Controller.registry.get(controllerName);
                if (!ChickenController) throw new Error('No controller defined with name "' + controllerName + '"');
                ctrl = new ChickenController(this);
              } // Get action


              callback = ctrl[action];

              if (callback === 'undefined' || typeof callback !== 'function') {
                throw new Error('There is no action on the "' + controllerName + '" controller with the name "' + action + '"');
              }
            } // Is it a route then


            if (typeof callback === 'string') {
              (function () {
                var viewUri = callback;

                callback = function callback() {
                  return new View(viewUri);
                };
              })();
            }
          } // Call it.


          handlerResult = callback.apply(this, [this, error]); // Something?

          if (handlerResult) break;
        } // No result?


        if (!handlerResult) {
          throw error;
        } // Treat the result as my action-result!


        this._processResult(handlerResult, resolve, reject);
      }
    }]);

    return Action;
  }(Obj);

  var _controllerActionRegExp;

  Action.getControllerActionRegExp = function () {
    if (_controllerActionRegExp === undefined) {
      _controllerActionRegExp = xregexpAll('^(?<class>[A-Z][a-zA-Z0-9\-\.]+)@(?<action>[a-z][a-zA-Z0-9\_]+)$');
    }

    return _controllerActionRegExp;
  };

  /**
   * @module Routing
   */

  var RouteMatch =
  /*#__PURE__*/
  function () {
    /**
     * When a Request is matched by a Route, a RouteMatch is created,
     * containing all the information necessary to process the request. 
     * The Router will use the RouteMatch to execute all the actions defined
     * in the route(s).
     * 
     * @class Routing.RouteMatch
     *
     * @constructor
     * @param {Routing.Route} 		route 			The route that matched
     * @param {array}  				regExpMatch 	The result from the XRegExp.exec call
     * @param {Routing.Request}		request 		The request that made this RouteMatch possible
     */
    function RouteMatch(route, regExpMatch, request) {
      var _this = this;

      _classCallCheck(this, RouteMatch);

      /**
       * The Route that matched
       *
       * @property route
       * @type {Routing.Route}
       */
      this.route = route;
      /**
       * The result from the XRegExp.exec call when the Route was matched
       * 
       * @property regExpMatch
       * @type {array}
       */

      this.regExpMatch = regExpMatch;
      /**
       * The request that made this RouteMatch possible
       *
       * @property request
       * @type {Routing.Request}
       */

      this.request = request;
      /**
       * The actions that are part of this match,
       * keyed by the target ViewContainer
       * 
       * @property actions
       * @type {Map}	
       */

      this.actions = new Map();
      /**
       * The parameters from the Request and matched route
       *
       * @property parameters
       * @type {Map}
       */

      this.parameters = new Map();
      /**
       * Parameters given in the URL (?a=b)
       * 
       * @property query
       * @type {Object}
       */

      this.query = queryString.parse(window.location.search); ////////////////////
      // Create actions //
      ////////////////////
      // Read parameters from match

      underscore.each(route.parameters, function (paramName) {
        _this.parameters.set(paramName, regExpMatch[paramName]);
      }); // Start with the matched route


      this._readActionsFromRoute(route);
    }
    /**
     * Handle leaving this RouteMatch
     *
     * @method leave
     * @param  {Routing.RouteMatch} toRoute The RouteMatch we're going to after leaving this
     * @return {Promise}
     */


    _createClass(RouteMatch, [{
      key: "leave",
      value: function leave(toRoute) {
        var _this2 = this;

        return new Promise(function (resolve, reject) {
          // Loop through action results
          var leavePromises = [];

          _this2.actions.forEach(function (action, name) {
            // Get replacing action
            var replacingAction = toRoute.actions.get(name);

            if (replacingAction) {
              // Was it triggered by the same route?
              if (action.viewContainer && action.viewContainer.currentAction && Utils.uidFor(action.viewContainer.currentAction.route) === Utils.uidFor(replacingAction.route)) {
                // Are the arguments the same as well?
                var currentParams = JSON.stringify(action.parameterArray);
                var replacingParams = JSON.stringify(replacingAction.parameterArray);

                if (currentParams === replacingParams) {
                  // That means, we've just navigated within nested routes of that page, and this action will stay the same
                  return;
                }
              }
            } // Leave this action				


            leavePromises.push(action.leave());
          }); // Anything?


          if (leavePromises.length === 0) {
            resolve();
            return;
          } // When all is done


          Promise.all(leavePromises).then(function () {
            resolve();
          }, function (error) {
            reject(error);
          });
        });
      }
    }, {
      key: "_readActionsFromRoute",
      value: function _readActionsFromRoute(route) {
        var _this3 = this;

        // Collect parameters from route
        var params = new Map();
        var paramArray = [];

        underscore.each(route.parameters, function (paramName) {
          paramArray.push(_this3.parameters.get(paramName));
          params.set(paramName, _this3.parameters.get(paramName));
        }); // Get actions


        var myActions = {};

        underscore.each(route.getActions(), function (routeAction, targetViewContainer) {
          // Is there already an action defined for this target
          if (_this3.actions.has(targetViewContainer)) return; // Make it.

          var action = new Action(targetViewContainer, routeAction, _this3.request); // Set routes

          action.route = route;
          action.matchedRoute = _this3.route;
          action.routeMatch = _this3; // Set parameters

          action.parameters = params;
          action.parameterArray = paramArray; // Add it.

          myActions[targetViewContainer] = action;
        }); // Make any actions that are already there dependent on the new ones, 
        // because these actions are the parent(s) of the existing actions.


        this.actions.forEach(function (previousAction) {
          underscore.each(myActions, function (myAction) {
            previousAction.dependsOn.push(myAction);
          });
        }); // Add these actions

        var actionsToMakeDependentOn = [];

        underscore.each(myActions, function (myAction, targetViewContainer) {
          // My this action dependent on previous actions defined in this route
          underscore.each(actionsToMakeDependentOn, function (depAction) {
            myAction.dependsOn.push(depAction);
          }); // Add the action to my actions


          _this3.actions.set(targetViewContainer, myAction);

          actionsToMakeDependentOn.push(myAction);
        }); // Now look into the parent


        if (route.parentRoute) {
          this._readActionsFromRoute(route.parentRoute);
        } // We're done!


        return this.actions;
      }
    }]);

    return RouteMatch;
  }();

  /**
   * @module Routing
   */

  var Route =
  /*#__PURE__*/
  function (_Obj) {
    _inherits(Route, _Obj);

    /**
     * A Route configures a uri and its actions, parameters,
     * and models.
     * 
     * @class Routing.Route
     * @extends Core.Object
     * 
     * @constructor
     * @param {Routing.Router} 	router 				The application's Router instance
     * @param {Routing.Route} 	parent 				The route that the route you are creating is to be child of. Use `null` when there is no parent.
     * @param {string} 			pattern 			The route's pattern, not including the parent's pattern
     * @param {object|string}	[actions=null]		An action string or object containing one or more actions, keyed by the target ViewContainer. 
     *                                        		If you don't define actions this route will be made abstract.
     * @param {object}			[options={}]		An object containing one or more configuration options
     */
    function Route(router, parent, pattern) {
      var _this;

      var actions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

      _classCallCheck(this, Route);

      // Basics
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Route).call(this)); // Private vars

      _this._parameterConstraints = new Map();
      _this._actions = actions; ////////////////
      // Properties //
      ////////////////

      /**
       * The Route that this Route is nested in
       * 
       * @property parentRoute
       * @type {Routing.Route}
       */

      _this.parentRoute = parent;
      /**
       * The Router that this Route is a part of
       * 
       * @property router
       * @type {Routing.Router}
       */

      _this.router = router;
      /**
       * The defined pattern, not including any parent patterns
       * 
       * @property pattern
       * @type {string}
       */

      _this.pattern = pattern.replace(/(.)\/$/, '$1'); // Remove trailing slash

      /**
       * Route-specific error handlers
       *
       * @property errorHandlers
       * @type {Object}
       */

      _this.errorHandlers = {};
      /**
       * The parameter names used in this route
       * 
       * @property parameters
       * @type {array}
       */

      _this.parameters = [];
      /**
       * @property nested
       * @type {Array}
       */

      _this.nested = {};
      /**
       * The options used when defining this Route
       * 
       * @property options
       * @type {object}
       */

      _this.options = underscore.defaults(options, {
        abstract: actions === null,
        as: null,
        viewContainer: 'main',
        middleware: [],
        services: []
      });
      /**
       * The name of the route you can use to link to. This is only 
       * set if you used the 'as' option.
       * 
       * @property name
       * @type {string}
       */

      _this.name = null;
      /**
       * When true, the route's action(s) will refresh when the query string changes
       * 
       * @property acceptsQuery
       * @type {Boolean}
       */

      _this.acceptsQuery = false;
      /**
       * When true, the route's action(s) will refresh when the Request flash-data changes
       * @type {Boolean}
       */

      _this.acceptsFlash = false; // Add me to parent route

      if (parent) {
        parent.nested[_this.pattern] = _assertThisInitialized(_assertThisInitialized(_this));
      }

      return _this;
    } ////////////////////
    // Public methods //
    ////////////////////

    /**
     * Call this when you want to define routes nested under the current one. The provided callback
     * will be called with the Router as context, allowing you to use this.route to define the nested
     * routes.
     *
     * @example
     * 	Chicken.createApplication($('#application'), {
     * 		baseUrl: '/'
     * 	}).routes(function() {
     *  
     *  	this.route('/animals', 'Animal@index')                            // /animals
     *  		.nest(function() {
     *  			this.route('/dog', 'Animal@dog')                          // /animals/dog
     *  				.nest({ viewContainer: 'dogs' }, function() {
     *      				this.route('/:dogName', 'Animal@dogDetails');     // /animals/dog/:dogName
     *      				this.route('/about-dogs', 'Animal@aboutDogs');    // /animals/dog/about-dogs
     *  				});  				
     *      		this.route('/cat', 'Animal@cat');                         // /animals/cat
     *  		 });
     *  	
     *   
     * 	});
     * 	
     *
     * @method nest
     * @param {object} 		[options]   An optional options hash, to apply to all nested routes
     * @param {function} 	callback 	Your callback
     * @chainable
     */


    _createClass(Route, [{
      key: "nest",
      value: function nest() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        // Check if options were given
        var callback = args.pop();
        var options = args.length > 0 ? args.pop() : {}; // Make me the parent route

        this.router.group(underscore.defaults({
          parentRoute: this
        }, options), callback);
        return this;
      }
    }, {
      key: "abstract",
      value: function abstract() {
        this.options.abstract = true;
        return this;
      }
      /**
       * Check whether this Route matches the given Request. If so, the method
       * will return a complete RouteMatch. If not, the method will return `false`.
       * 
       * @method match
       * @param  {Routing.Request} request     
       * @return {Routing.RouteMatch|boolean}  
       */

    }, {
      key: "match",
      value: function match(request) {
        // Am I an abstract route?
        if (this.isAbstract()) return; // Does it match?

        var match = xregexpAll.exec(request.uri, this.getRegExp()); // No match?

        if (!match) return false; // Do I have a nested / route?

        if (this.nested['/']) {
          // Use that route instead of me...
          request.uri = request.uri + '/';
          return this.nested['/'].match(request);
        } // We matched! Let's create a match object.


        return new RouteMatch(this, match, request);
      }
    }, {
      key: "error",
      value: function error(key, callback) {
        if (this.errorHandlers[key] === undefined) this.errorHandlers[key] = [];
        this.errorHandlers[key].push(callback);
        return this;
      }
      /**
       * Get the action definitions for the Route. An action definition can either
       * be a Controller action (e.g.: `Product@index`), or a callback. The result
       * is keyed by the target ViewContainer name.
       *
       * @method getActions
       * @return {object} 
       */

    }, {
      key: "getActions",
      value: function getActions() {
        // Is it still a string (Controller@action) or callback?
        if (typeof this._actions === 'string' || typeof this._actions === 'function') {
          // Wrap in object using default view container
          var actions = {};
          actions[this.options.viewContainer] = this._actions;
          this._actions = actions;
        }

        return this._actions;
      }
      /**
       * Get the action definitions for this Route, and any parent routes that it may have.
       *
       * @method getFullActions
       * @return {object} 
       */

    }, {
      key: "getFullActions",
      value: function getFullActions() {
        // Start with mine
        var actions = this.getActions(); // Add parent

        if (this.parentRoute) {
          return underscore.defaults(actions, this.parentRoute.actions);
        }

        return actions;
      }
      /**
       * Get the full Route pattern within the application for this route,
       * including any parent Routes.
       *
       * @method getFullPattern
       * @return {string}
       */

    }, {
      key: "getFullPattern",
      value: function getFullPattern() {
        // My pattern as base
        var p = this.pattern; // Get parent's full pattern

        if (this.parentRoute) {
          var parentPart = this.parentRoute.getFullPattern();

          if (parentPart !== '/') {
            p = parentPart + p;
          }
        }

        return p;
      }
    }, {
      key: "makeUrl",
      value: function makeUrl() {
        var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        // Get full pattern
        var pattern = this.getFullPattern();

        underscore.each(attributes, function (value, key) {
          // Is the value a model?
          if (value instanceof Model) value = value.get('id');
          pattern = pattern.split(':' + key).join(value);
        });

        return pattern;
      }
      /**
       * Get all parameter constraints for this Route, combining constraints
       * defined by parent routes.
       *
       * @method getAllParameterConstraints
       * @return {Map} Map with a regular expression constraint for each constrained parameter
       */

    }, {
      key: "getAllParameterConstraints",
      value: function getAllParameterConstraints() {
        // My constraints (don't overwrite)
        var c = new Map(this._parameterConstraints); // Get parent's constraints

        if (this.parentRoute) {
          // Prefix the pattern
          this.parentRoute.getAllParameterConstraints().forEach(function (regex, key) {
            if (!c.has(key)) c.set(key, regex);
          });
        }

        return c;
      }
    }, {
      key: "getMiddlewareNames",
      value: function getMiddlewareNames() {
        return this.options.middleware;
      }
      /**
       * Get the Route's complete Regular Expression, including
       * parameters
       * 
       * @method getRegExp
       * @return {XRegExp}
       */

    }, {
      key: "getRegExp",
      value: function getRegExp() {
        var _this2 = this;

        // Not yet set?
        if (this._regExp === undefined) {
          // Collect buildingBlocks (a regular expression pattern for each parameter)
          var buildingBlocks = {}; // Convert :params into regex with building blocks 
          // (see XRegExp.build documentation)

          var constraints = this.getAllParameterConstraints();
          var exp = xregexpAll.replace(this.getFullPattern(), /(([\:\*])([a-zA-Z\-\_]+))/, function (match, complete, paramType, paramName) {
            // Wildcard?
            var paramRegex;

            if (paramType === '*') {
              // Use wildcard
              paramRegex = Route.ParameterType.Wildcard;
            } else {
              // Check if there is a constraint
              paramRegex = constraints.has(paramName) ? constraints.get(paramName) : Route.ParameterType.Standard;
            } // Store as building block for regex


            buildingBlocks[paramName] = paramRegex; // Store parameter

            _this2.parameters.push(paramName); // Replace with a building block using named parameter


            return '({{' + paramName + '}})';
          }, 'all'); // Create it

          this._regExp = xregexpAll.build('^' + exp + '$', buildingBlocks);
        } // Return it


        return this._regExp;
      }
      /**
       * Add a constraint to a parameter, by supplying a regular expression.
       * 
       * @method constrain
       * @param  {string} parameterName The name of the parameter to add constrains to
       * @param  {RegExp} regExp        A regular expression to use when matching the parameter
       * @chainable
       */

    }, {
      key: "constrain",
      value: function constrain(parameterName, regExp) {
        // Store it
        this._parameterConstraints.set(parameterName, regExp);

        return this;
      }
    }, {
      key: "acceptQuery",
      value: function acceptQuery() {
        var accept = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this.acceptsQuery = accept;
        return this;
      }
    }, {
      key: "acceptFlash",
      value: function acceptFlash() {
        var accept = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this.acceptsFlash = accept;
        return this;
      }
      /**
       * Set the name of this Route
       *
       * @method as
       * @param  {string} name 
       * @chainable
       */

    }, {
      key: "as",
      value: function as(name) {
        // Does the name start with a .?
        if (/^\./.test(name) && this.parentRoute && this.parentRoute.name) {
          // Strip off a part for each ..
          var parts = this.parentRoute.name.split(/\./);

          while (/^\.\./.test(name)) {
            parts.pop();
            name = name.substr(1);
          } // Relative name. Add parent name as prefix


          name = "".concat(parts.join('.')).concat(name);
        } // Store name


        this.name = name; // Store in router

        this.router.namedRoutes.set(name, this);
        return this;
      }
    }, {
      key: "middleware",
      value: function middleware() {
        for (var _len2 = arguments.length, keys = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          keys[_key2] = arguments[_key2];
        }

        this.options.middleware = underscore.unique(underscore.flatten([this.options.middleware, keys]));
        return this;
      }
    }, {
      key: "services",
      value: function services() {
        for (var _len3 = arguments.length, keys = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          keys[_key3] = arguments[_key3];
        }

        this.options.services = underscore.unique(underscore.flatten([this.options.services, keys]));
        return this;
      }
      /**
       * An abstract Route can never be matched. This is useful when you have a Route
       * that only has subroutes, but no actions itself. If you define a Route without
       * actions, this will automatically be set to true.
       * 
       * @method isAbstract
       * @return {Boolean}
       */

    }, {
      key: "isAbstract",
      value: function isAbstract() {
        return !!this.options.abstract;
      }
    }]);

    return Route;
  }(Obj);

  Route.ParameterType = {
    /**
     * Regular expression for a standard parameter 
     *
     * Default: `/[^\/]+/`
     * 
     * @property ParameterType.Standard
     * @static
     * @type {RegExp}
     */
    Standard: /[^\/]+/,

    /**
     * Regular expression for a wildcard parameter
     *
     * Default: `/.+/`
     * 
     * @property ParameterType.Wildcard
     * @static
     * @type {RegExp}
     */
    Wildcard: /.+/
  };

  /**
   * @module Routing
   */

  var Request =
  /*#__PURE__*/
  function () {
    /**
     * @class Routing.Request
     *
     * @constructor
     * @param {object} 			location 		The location received from the History library
     * @param {Application} 	[application] 	The Application instance that this Request is a part of
     */
    function Request(location) {
      var application = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, Request);

      // Guess application if not given
      if (!application) application = ClassMap.get('Application').getInstance(); // Parse the uri 

      var uri = Request.cleanUri(location.pathname); // Strip of base part

      var baseUrl = Request.cleanUri(application.settings.get('baseUrl'));

      if (uri.length >= baseUrl.length && uri.substr(0, baseUrl.length)) {
        uri = uri.substr(baseUrl.length);
      } // Add the / back again


      uri = '/' + uri;
      /**
       * @property uri
       * @type {string}
       */

      this.uri = uri;
      /**
       * @property query
       * @type {object}
       */

      this.query = queryString.parse(location.search);
      /**
       * @property flash
       * @type {object|false}
       */

      this.flash = location.state ? location.state.flash : {};
      /**
       * @property transition
       * @type {string|null}
       */

      this.transition = location.state ? location.state.transition : null;
    }

    _createClass(Request, [{
      key: "getFlash",
      value: function getFlash(key) {
        if (this.flash && this.flash[key]) return this.flash[key];
        return null;
      }
    }]);

    return Request;
  }();

  Request.cleanUri = function (uri) {
    if (/^\//.test(uri)) uri = uri.substr(1);
    if (/\/$/.test(uri)) uri = uri.substr(0, uri.length - 1);
    return uri;
  };

  var Middleware = function Middleware(name, callback) {
    _classCallCheck(this, Middleware);

    this.name = name;
    this.callback = callback;
  };

  Middleware.registry = new Map();

  Middleware.register = function (middleware) {
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    // Check arguments
    if (!(middleware instanceof Middleware)) {
      middleware = new Middleware(name, middleware);
    } else if (name === null) {
      name = middleware.name;
    } // Store it.


    Middleware.registry.set(name, middleware);
  };

  var Service =
  /*#__PURE__*/
  function (_Observable) {
    _inherits(Service, _Observable);

    function Service(name) {
      var _this;

      _classCallCheck(this, Service);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Service).call(this));
      _this.name = name;

      _this.initialize.apply(_assertThisInitialized(_assertThisInitialized(_this)));

      return _this;
    }

    _createClass(Service, [{
      key: "initialize",
      value: function initialize() {
        throw new Error('The ' + this.name + ' service has not implemented the "initialize" method');
      }
    }, {
      key: "load",
      value: function load() {
        throw new Error('The ' + this.name + ' service has not implemented the "load" method');
      }
    }]);

    return Service;
  }(Observable);

  Service.registry = new Map();
  Service.services = new Map();

  Service.get = function (name) {
    // Created?
    if (!Service.services.has(name)) {
      // Do we know it?
      if (!Service.registry.has(name)) {
        throw new Error('There is no service registed with the name "' + name + '"');
      } // Instantiate


      var ServiceClass = Service.registry.get(name);
      var service = new ServiceClass(name); // Store

      Service.services.set(name, service);
    }

    return Service.services.get(name);
  };

  /**
   * @module Routing
   */

  var Router =
  /*#__PURE__*/
  function (_Obj) {
    _inherits(Router, _Obj);

    /**
     * 
     * 
     * @class Routing.Router
     * @extends Core.Object
     */
    function Router(application
    /*, parentRouter = null*/
    ) {
      var _this;

      _classCallCheck(this, Router);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Router).call(this)); ////////////////
      // Properties //
      ////////////////

      /**
       * @property routes
       * @type {Array}
       */

      _this.routes = [];
      /**
       * @property application
       * @type {Application}
       */

      _this.application = application;
      /**
       * @property namedRoutes
       * @type {Map}
       */

      _this.namedRoutes = new Map();
      _this.errorHandlers = {
        'all': [],
        'js': [],
        'api': [],
        'api.400': [],
        'api.404': [],
        'api.500': [],
        'router': [],
        'router.403': [],
        'router.404': []
      }; ///////////////////////////////////////////
      // Grouped configuration state variables //
      ///////////////////////////////////////////

      _this._currentConfig = SettingsObject$1.create({
        parentRoute: null,
        viewContainer: 'main',
        services: [],
        middleware: []
      }, ['parentRoute', 'viewContainer', 'middleware', 'services']);
      return _this;
    } ////////////////////////
    // Definition methods //
    ////////////////////////

    /**
     * Create a Route and add it to the Router.
     *
     * @method route
     * @param  {string} 			pattern 	The uri pattern
     * @param  {Object|String} 		actions     
     * @param  {Object} 			[options] 
     * @return {Routing.Route}        
     */


    _createClass(Router, [{
      key: "route",
      value: function route(pattern, actions) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        // Merge options
        options = underscore.defaults({}, options, underscore.omit(this._currentConfig.toObject(), 'parentRoute')); // Create the route

        var route = new Route(this, this._currentConfig.get('parentRoute'), pattern, actions, options); // Add route

        this.routes.push(route); // Return route

        return route;
      }
    }, {
      key: "errorRoute",
      value: function errorRoute(errorKey, actions) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        // Get route
        options.isErrorRoute = true;
        var route = this.route('/__errors/' + errorKey, actions, options);
        this.handleErrors(errorKey, route);
        return this;
      }
    }, {
      key: "catchAll",
      value: function catchAll(actions) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return this.route('/:url', actions, options).constrain('url', /.*/);
      }
      /**
       * Configure the Router to add the given options to
       * the Routes you define within the callback.
       *
       * @method group
       * @param  {object}   options  
       * @param  {Function} callback 
       * @chainable
       */

    }, {
      key: "group",
      value: function group(options, callback) {
        // Store options
        var oldConfig = this._currentConfig.clone();

        this._currentConfig.apply(options); // Do the callback


        callback.apply(this); // Restore options

        this._currentConfig = oldConfig;
        return this;
      } //////////////////////
      // Router in action //
      //////////////////////

      /**
       * Handle given Request, by finding a matching Route
       * and executing it.
       * 
       * @method handle
       * @param  {Routing.Request} request 
       * @return {Routing.RouteMatch}
       */

    }, {
      key: "handle",
      value: function handle(request) {
        var _this2 = this;

        /////////////////
        // Match route //
        /////////////////
        // Is it just a URL passed along?
        if (!(request instanceof Request)) {
          request = new Request(request);
        } // Loop through routes until we found something.


        var routeMatch = false;

        underscore.find(this.routes, function (route) {
          routeMatch = route.match(request);
          return routeMatch;
        }); // Found something?


        if (routeMatch === false) {
          // Create error
          var error = new RoutingError(404, 'Page not found', request);
          return this.getErrorRouteMatch(error);
        } // First leave current route


        if (this.application.currentRoute) {
          // Leave
          this.application.currentRoute.leave(routeMatch).then(function () {
            _this2.application.currentRoute = false;

            _this2.handle(request);
          });
          return;
        } // Going.


        this.trigger('navigate', request); // Store it on app

        this.application.currentRoute = routeMatch; // Make the execution callback

        var executeActions = function executeActions() {
          /////////////////////////////
          // Start executing actions //
          /////////////////////////////
          var numberOfActionsStarted = 0;
          var actionPromises = [];
          routeMatch.actions.forEach(function (action, vcName) {
            // Get the ViewContainer
            var vc = _this2.application.getViewContainer(vcName); // Disabled navigation for this request?


            if (_this2.application.navigationDisabledOnce) {
              // Just set the action on the viewcontainer, but don't actually do anything
              if (vc) {
                vc.setAction(action);
              } // Done.


              numberOfActionsStarted++;
              return new Promise(function (resolve) {
                resolve();
              });
            } // Add transition


            if (request.transition && !vc.transitionsDisabled) {
              action.transition = request.transition;
            } // Get depends on promises


            var dependsOnPromises = underscore.map(action.dependsOn, function (dependsOnAction) {
              return dependsOnAction.getPromise('complete');
            }); // And any services that should be loaded


            underscore.each(routeMatch.route.options.services, function (service) {
              // Find service
              var serviceInstance = Service.get(service);
              if (!serviceInstance) throw new Error('[Routing.Router] There is no service "' + service + '" registered'); // Load it

              var promise = serviceInstance.load();
              if (!promise || !(promise instanceof Promise)) throw new Error('[Routing.Router] The "' + service + '" service\'s load() method should return a Promise');
              dependsOnPromises.push(promise);
            }); // Wait?


            if (dependsOnPromises.length > 0) {
              // Wait for it
              Promise.all(dependsOnPromises).then(function () {
                // Now we're ready!
                action.execute(_this2.application);
              }, function (error) {
                throw new Error('[Routing.Router] Action for "' + vcName + '" was not started, due to error in dependancy route: ' + error);
              });
            } else {
              // Start now
              numberOfActionsStarted++;
              action.execute(_this2.application);
            } // Add complete promise


            actionPromises.push(action.getPromise('complete'));
          }); ////////////////////////////
          // Keep track of progress //
          ////////////////////////////
          // Any action started?

          if (numberOfActionsStarted === 0 && routeMatch.route.options.services.length === 0) {
            throw new Error('[Routing.Router] No actions for started for route ' + routeMatch.route.getFullPattern() + '. Check your configuration.');
          } // Listen to the result


          Promise.all(actionPromises).then(function ()
          /*...results*/
          {
            //@TODO What to do?
            _this2.trigger('complete', [routeMatch]);
          }); // Reset navigation disabled

          _this2.application.navigationDisabledOnce = false;
        }; //////////////////////
        // Setup middleware //
        //////////////////////
        // Loop and add middleware


        var callbacksToExecute = [];

        underscore.each(routeMatch.route.getMiddlewareNames(), function (mwName) {
          // Get the middleware
          var middleware = Middleware.registry.get(mwName);
          if (!middleware) throw new Error('There is no middleware registered with the name "' + mwName + '"'); // Add the callback

          callbacksToExecute.push(middleware.callback);
        }); // Lastly we will execute the actions


        callbacksToExecute.push(executeActions); ////////////////////////////////////////////////////////////////
        // Now call the first callback, to start the middleware chain //
        ////////////////////////////////////////////////////////////////

        var nextCallback = function nextCallback() {
          // Get the callback to call
          var cb = callbacksToExecute.shift(); // Get the next in line

          try {
            cb.apply(_this2, [nextCallback, request, routeMatch]);
          } catch (error) {
            // Get error route match
            routeMatch = _this2.getErrorRouteMatch(error); // Break out

            executeActions();
          }
        };

        nextCallback();
        return routeMatch;
      }
    }, {
      key: "handleErrors",
      value: function handleErrors(errorType, callback) {
        // Known code?
        if (this.errorHandlers[errorType] === undefined) {
          throw new Error('It is not possible to catch "' + errorType + '" errors; available error statuses are: ' + underscore.keys(this.errorHandlers).join(', '));
        } // Add it


        this.errorHandlers[errorType].push(callback);
      }
    }, {
      key: "getErrorHandlers",
      value: function getErrorHandlers(error) {
        var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        // Error object?
        if (typeof error === 'string') {
          error = new Error(error);
        } // No obj? Use me.


        if (!obj) obj = this; // Routing error?

        var handlers = [];

        if (error instanceof RoutingError) {
          // Add handlers for the status code
          if (obj.errorHandlers['router.' + error.code]) {
            handlers = underscore.union(handlers, obj.errorHandlers['router.' + error.code]);
          } // Add router-handlers


          if (obj.errorHandlers.router) handlers = underscore.union(handlers, obj.errorHandlers.router); // Api error?
        } else if (error instanceof ApiError) {
          // Add handlers for the status code
          var statusCode = error.getStatusCode();

          if (obj.errorHandlers['api.' + statusCode]) {
            handlers = underscore.union(handlers, obj.errorHandlers['api.' + statusCode]);
          } // Add api-handlers


          if (obj.errorHandlers.api) handlers = underscore.union(handlers, obj.errorHandlers.api);
        } else {
          // Javascript error
          if (obj.errorHandlers.js) handlers = underscore.union(handlers, obj.errorHandlers.js);
        } // Always add the 'all' handlers


        if (obj.errorHandlers.all) handlers = underscore.union(handlers, obj.errorHandlers.all); // Were we called for a specific object?

        if (obj !== this) {
          // Then append default router callbacks
          handlers = underscore.union(handlers, this.getErrorHandlers(error));
        }

        return handlers;
      }
    }, {
      key: "getErrorRouteMatch",
      value: function getErrorRouteMatch(error) {
        // Get the handlers
        var handlers = this.getErrorHandlers(error);
        var handlerResult = false;

        while (handlers.length > 0) {
          // Get handler and call it
          var handler = handlers.shift(); // Is it a callback?

          var result = void 0;

          if (typeof handler === 'function') {
            // Call handler
            result = handler(error, error.request, this);
          } else {
            // Just use the value itself (probably a Route defined through 'errorRoute(...')
            result = handler;
          } // Anything?


          if (result) {
            handlerResult = result;
            break;
          }
        } // No result?


        if (!handlerResult) throw error; // A generic redirect?

        if (handlerResult instanceof Redirect) {
          return this.application.goto(handlerResult.uri);
        } // Is it a Route?


        if (handlerResult instanceof Route) {
          // Fake a match
          var match = new RouteMatch(handlerResult, {}, error && error.request ? error.request : null);
          return match;
        }
      }
      /**
       * Output a table to the console containing an overview
       * of all defined routes.
       *
       * Note: This is not supported in all browsers!
       * https://developer.mozilla.org/en-US/docs/Web/API/Console/table
       *  
       * @method outputToConsole
       * @chainable
       */

    }, {
      key: "outputToConsole",
      value: function outputToConsole() {
        // Loop and log
        console.table(underscore.map(this.routes, function (route) {
          return {
            'Pattern': route.getFullPattern(),
            'Actions': route.isAbstract() ? '(abstract)' : underscore.map(route.getFullActions(), function (action, targetViewContainer) {
              return targetViewContainer + ': ' + (typeof action === 'function' ? '(Callback)' : action);
            }).join(', '),
            'Regular expression': route.getRegExp()
          };
        }));
        return this;
      }
    }]);

    return Router;
  }(Obj);

  /**
   * @module Localization
   */

  var I18n =
  /*#__PURE__*/
  function (_Obj) {
    _inherits(I18n, _Obj);

    function I18n(language) {
      var _this;

      _classCallCheck(this, I18n);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(I18n).call(this));
      /**
       * @property data
       * @type {Object}
       */

      _this.data = {};
      /**
       * @property bundlesToLoad
       * @type {Array}
       */

      _this.bundlesToLoad = [];
      /**
       * @property language
       * @type {string}
       */

      _this.language = null;

      _this.setLanguage(language);

      return _this;
    }
    /**
     * Add a bundle that will be loaded when the application starts
     *
     * @method addBundle
     * @param  {string} url 
     * @param  {string} [key=null]  Optional key to add loaded data under.
     * @chainable
     */


    _createClass(I18n, [{
      key: "addBundle",
      value: function addBundle(url) {
        var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        this.bundlesToLoad.push({
          url: url,
          key: key
        });
        return this;
      }
    }, {
      key: "setBundle",
      value: function setBundle(data) {
        var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var language = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        // Default language
        if (!language) language = this.language; // Is there a key?

        if (key) {
          var r = {};
          r[key] = data;
          data = r;
        } // Extend


        jquery.extend(this.data[language], data);
      }
      /**
       * Manually load a bundle into I18n
       *
       * @method loadBundle
       * @param  {string} url 
       * @param  {string} [key=null]  Optional key to add loaded data under.
       * @return {Promise}     
       */

    }, {
      key: "loadBundle",
      value: function loadBundle(url) {
        var _this2 = this;

        var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var language = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        // Convert language placeholders
        if (!language) language = this.language;
        url = url.replace(/:language/, this.language);
        return new Promise(function (resolve, reject) {
          // Do we have it in cache?
          if (I18n.Cache[url]) {
            resolve(I18n.Cache[url]);
            return;
          } // Load it.


          jquery.ajax(url, {}).then(function (result) {
            resolve(result);
          }).fail(function (error) {
            reject(error);
          });
        }).then(function (result) {
          // Parse result
          result = _this2.parseResult(result, url); // Is there a key?

          if (key) {
            var r = {};
            r[key] = result;
            result = r;
          } // Extend


          jquery.extend(_this2.data[language], result);
        });
      }
    }, {
      key: "setLanguage",
      value: function setLanguage(language) {
        this.language = language;

        if (!this.data[language]) {
          this.data[language] = {};
        }

        return this;
      }
    }, {
      key: "parseResult",
      value: function parseResult(result, url) {
        // Check extension
        var extension = underscore.last(url.split(/\./));

        if (extension === 'yaml') {
          // Parse yaml
          if (window.YAML === undefined) throw new Error('The YAML library was not loaded, so the language file cannot be read. Add the bower component yamljs to your application.');
          result = window.YAML.parse(result);
        } else if (extension === 'json') {
          // Parse json
          if (typeof result === 'string') result = JSON.parse(result);
        }

        return result;
      }
    }, {
      key: "getData",
      value: function getData() {
        var language = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        if (!language) language = this.language;
        return this.data[language];
      }
      /**
       * Load all added bundles
       *
       * @method load
       * @return {Promise}
       */

    }, {
      key: "load",
      value: function load() {
        var _this3 = this;

        // Main prmomise for loading
        return this.promise('loaded', function (resolve) {
          // Nothing to load?
          if (_this3.bundlesToLoad.length === 0) {
            resolve();
            return;
          } // Collect promises


          var promises = [];

          underscore.each(_this3.bundlesToLoad, function (bundle) {
            promises.push(_this3.loadBundle(bundle.url, bundle.key));
          }); // When all is done.


          Promise.all(promises).then(function () {
            resolve();
          });
        });
      }
      /**
       * Get the translation for given key
       * 
       * @method translate
       * @param  {string} key        			Dot-notation key to get value of
       * @param  {Object} [attributes={}] 	Optional object containing attributes to pass to the template in the translated value
       * @param  {mixed} [fallback=null]		Optional fallback value when the key is nout found
       * @return {mixed}
       */

    }, {
      key: "translate",
      value: function translate(key) {
        var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var language = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        // Dot notation
        var obj = this.getData(language);
        var parts = key.split(/\./);

        while (parts.length > 0) {
          // Get firs tpart
          var part = parts.shift(); // Not existing?

          if (!obj[part]) return fallback !== null ? fallback : '[' + key + ']'; // Dive in.

          obj = obj[part];
        }

        return this.processValue(obj, attributes);
      }
    }, {
      key: "processValue",
      value: function processValue(obj, attributes) {
        var _this4 = this;

        // What type?
        if (typeof obj === 'string') {
          // Process string
          obj = this.processString(obj, attributes);
        } else if (jquery.isArray(obj)) {
          // Mapped processing
          obj = underscore.map(obj, function (v) {
            return _this4.processValue(v, attributes);
          });
        } else if (_typeof(obj) === 'object') {
          var result = {};

          underscore.each(obj, function (value, key) {
            result[key] = _this4.processValue(value, attributes);
          });

          obj = result;
        }

        return obj;
      }
    }, {
      key: "processString",
      value: function processString(obj, attributes) {
        // Double escaping
        obj = obj.split(/\\n/).join('\n').split(/\\t/).join('\t'); /////////////////
        // Templating? //
        /////////////////

        if (obj.match(/<%/)) {
          // Convert attributes into real values
          var attr = underscore.mapObject(attributes, function (value) {
            // Get value?
            if (value !== null && value !== undefined && _typeof(value) === 'object' && typeof value.getValue === 'function') {
              value = value.getValue();
            }

            return value;
          }); // Make a template and run it


          var template = underscore.template(obj);

          try {
            obj = template(attr);
          } catch (error) {//
            //console.warn(error);
          }
        }

        return obj;
      }
      /**
       * Alias of translate
       * 
       * @method get
       * @param  {string} key        
       * @param  {Object} [attributes={}] 
       * @param  {mixed} [fallback=null]
       * @return {mixed}
       */

    }, {
      key: "get",
      value: function get(key) {
        var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var language = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        return this.translate(key, attributes, fallback, language);
      }
    }]);

    return I18n;
  }(Obj);

  I18n.Cache = {};

  // Class definitino //
  //////////////////////

  var _instance = undefined;
  /**
   * The main Application class, used to create a Chicken application.
   *
   * @param {JQuery} $app - The target jQuery element to create application in
   * @param {Object} settings - Application settings object
   * @param {string} [settings.baseUrl=/] - The root uri of the application
   * @param {History} [history] Optional browser history instance. Will be created for you if you leave it null.
   * 
   */

  var Application =
  /*#__PURE__*/
  function (_Observable) {
    _inherits(Application, _Observable);

    function Application($app, settings) {
      var _this;

      var history = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      _classCallCheck(this, Application);

      // Basics
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Application).call(this));
      _instance = _assertThisInitialized(_assertThisInitialized(_this)); ////////////////
      // Properties //
      ////////////////

      /**
       * The jQuery element that is the Application
       * 
       * @property $app
       * @type {jQuery}
       */

      _this.$app = $app ? $app : jquery('#application');
      /**
       * All ViewContainers in the application. This is automatically
       * kept up to date to contain all and only still existing containers.
       *
       * @property viewContainers
       * @type {Object}
       */

      _this.viewContainers = {};
      /**
       * @property router
       * @type {Routing.Router}
       */

      _this.router = new Router(_assertThisInitialized(_assertThisInitialized(_this)));
      /**
       * One or more Api.Api instances
       * 
       * @property apis
       * @type {Object}
       */

      _this.apis = {};
      /**
       * One or more Auth.Auth instances
       *
       * @property auths
       * @type {Object}
       */

      _this.auths = {};
      /**
       * Array of promises to fulfill before the application
       * can start.
       * 
       * @property loadPromises
       * @type {Array}
       */

      _this.loadPromises = [];
      /**
       * @property settings
       * @type {Core.SettingsObject}
       */

      _this.settings = SettingsObject$1.create({
        baseUrl: '/',
        language: jquery('html').attr('lang'),
        viewPath: 'views',
        viewExtension: 'hbs',
        elementLinkAttribute: 'link-to',
        renderer: settings.renderer === undefined ? new Renderer() : null,
        isCordovaApp: false // For use with Cordova

      }, ['baseUrl', 'viewPath', 'viewExtension', 'renderer', 'elementLinkAttribute', 'isCordovaApp']).apply(settings);
      /**
       * @property i18n
       * @type {Localization.I18n}
       */

      _this.i18n = new I18n(_this.settings.get('language'));
      /**
       * @property history
       * @type {History}
       */

      _this.history = history;

      if (!_this.history) {
        // Cordova app?
        if (_this.settings.get('isCordovaApp')) {
          // Running actual app or previewing in browser?
          if (document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1) {
            // Create a history in memory
            _this.history = createMemoryHistory();
          } else {
            // Create a history using #
            _this.history = createHashHistory();
          }
        } else {
          // Create a browser history
          _this.history = createBrowserHistory();
        }
      }
      /**
       * Used to tweak history without navigating away from the page
       * 
       * @property navigationDisabledOnce
       * @type {Boolean}
       */


      _this.navigationDisabledOnce = false;
      return _this;
    }

    _createClass(Application, [{
      key: "findViewContainers",
      value: function findViewContainers() {
        var _this2 = this;

        var $element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        // No element to look in?
        if (!$element) $element = this.$app; // Find view containers

        $element.find(ViewContainer.ElementSelector).each(function (index, el) {
          // Create view container
          var vc = new ViewContainer(jquery(el), _this2); // Already known?

          if (_this2.viewContainers[vc.name]) {
            throw new Error('There is already a view named "' + vc.name + '". It is not possible to have two views with the same name at the same time.');
          } // Store it.


          _this2.viewContainers[vc.name] = vc; // Initialize

          vc.initialize();
        });
        return this;
      }
    }, {
      key: "updateViewContainers",
      value: function updateViewContainers() {
        var _this3 = this;

        var $lookForNewOnesIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        // Check if all old ones are still there
        underscore.each(this.viewContainers, function (vc, key) {
          // Removed?
          if (!vc.isInDom()) {
            delete _this3.viewContainers[key];
          }
        }); // Look for new ones


        if ($lookForNewOnesIn) this.findViewContainers($lookForNewOnesIn);
        return this;
      }
    }, {
      key: "getViewContainer",
      value: function getViewContainer(key) {
        return this.viewContainers[key];
      }
    }, {
      key: "routes",
      value: function routes(callback) {
        // Run callback with router
        callback.apply(this.router, []);
        return this;
      }
    }, {
      key: "api",
      value: function api() {
        var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var apiInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        // Get?
        if (apiInstance === null) {
          if (key === null) key = underscore.first(underscore.keys(this.apis));
          return this.apis[key];
        } // Set


        this.apis[key] = apiInstance;
        return this;
      }
    }, {
      key: "auth",
      value: function auth() {
        var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var authInstance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        // Get?
        if (authInstance === null) {
          if (key === null) key = underscore.first(underscore.keys(this.auths));
          return this.auths[key];
        } // Set


        this.auths[key] = authInstance;
        return this;
      }
    }, {
      key: "translations",
      value: function translations(callback) {
        callback.apply(this.i18n, [this.i18n]);
        return this;
      }
    }, {
      key: "start",
      value: function start() {
        var _this4 = this;

        // Enable momentJS
        moment.locale(this.settings.get('language')); // Add i18n to promises

        this.loadPromises.unshift(this.i18n.load()); // Do auth initialization

        underscore.each(this.auths, function (auth) {
          _this4.loadPromises.unshift(auth.initialize());
        }); // When all is done.


        Promise.all(this.loadPromises).then(function () {
          // Find initial view containers
          _this4.findViewContainers(); // Update view containers whenever element contents are set.


          Element.registerHook(function ($element) {
            // Update view containers
            _this4.updateViewContainers($element); // Find links


            $element.find('[' + _this4.settings.get('elementLinkAttribute') + ']').on('click', function (e) {
              // Open the uri!
              e.preventDefault();
              var uri = jquery(e.target).attr('href');

              _this4.goto(uri);
            }).each(function (index, el) {
              // Get uri
              var $el = jquery(el);
              var uri = $el.attr(_this4.settings.get('elementLinkAttribute'));

              if (uri) {
                // Store in href for easy visilbility, and remove link-to, so it won't be found again by this script
                $el.removeAttr(_this4.settings.get('elementLinkAttribute'));
                $el.attr('href', uri);
              }
            });
          }); // Done!

          _this4.resolvePromise('ready'); // Listen to browser's address bar


          _this4.history.listen(function (location) {
            _this4.router.handle(location);
          }); // Start with current location


          _this4.router.handle(_this4.history.location);
        }, function (error) {
          throw error;
        });
        return this;
      }
    }, {
      key: "gotoNamed",
      value: function gotoNamed(name) {
        var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var query = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var flash = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var transition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
        // Find route
        var route = this.router.namedRoutes.get(name);
        if (!route) throw new Error('There is no route defined with the name "' + name + '"'); // Make uri

        var uri = route.makeUrl(attributes);
        return this.goto(uri, query, flash, false, transition);
      }
    }, {
      key: "transitionToNamed",
      value: function transitionToNamed(name) {
        var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var transition = arguments.length > 2 ? arguments[2] : undefined;
        return this.gotoNamed(name, attributes, null, {}, transition);
      }
    }, {
      key: "transitionTo",
      value: function transitionTo(uri, transition) {
        return this.goto(uri, null, {}, false, transition);
      }
    }, {
      key: "goto",
      value: function goto(uri) {
        var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var flash = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var doNotNavigate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var transition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
        // Query in the uri?
        var search = queryString.extract(uri);
        var params = {};

        if (search.length > 0) {
          // Parse objects
          params = queryString.parse(search); // Remove from uri

          uri = uri.substr(0, uri.length - search.length - 1);
        } // Check the query


        if (query) {
          // Combine into params
          if (typeof query === 'string') {
            params = jquery.extend(params, queryString.parse(query));
          } else {
            params = jquery.extend(params, query);
          }
        } // Stringify query


        query = queryString.stringify(params);
        if (query) query = '?' + query; // External?		

        if (uri.match(/^(http(s)?\:)?\/\//)) {
          window.location = uri + (query || '');
          return this;
        } // No navigating? Just add the state to history?


        if (doNotNavigate) {
          // Disable navigation
          this.navigationDisabledOnce = true;
        } // Change the history state


        this.history.push({
          pathname: uri,
          search: query,
          state: {
            flash: flash,
            transition: transition
          }
        });
        return this;
      }
    }, {
      key: "refresh",
      value: function refresh() {
        var _this5 = this;

        var viewContainerKeys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        viewContainerKeys = viewContainerKeys || underscore.keys(this.viewContainers); //clear the currentAction of all viewContainer

        underscore.each(viewContainerKeys, function (viewContainerKey) {
          _this5.viewContainers[viewContainerKey].currentAction = null;
        }); // Start with current location


        this.router.handle(this.history.location);
      }
    }, {
      key: "getCurrentUri",
      value: function getCurrentUri() {
        return this.history.location.pathname;
      }
    }, {
      key: "config",
      value: function config() {
        // Get all?
        if (arguments.length === 0) {
          return this.settings;
        } // Get one?
        else if (arguments.length === 1) {
            return this.settings.get(arguments.length <= 0 ? undefined : arguments[0]);
          } // Set?
          else {
              return this.settings.set(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1]);
            }
      }
    }, {
      key: "uri",
      value: function uri() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        // Add baseUrl (except for cordova app)
        if (!this.settings.get('isCordovaApp')) {
          args.unshift(this.settings.get('baseUrl') === '/' ? '' : this.settings.get('baseUrl'));
        }

        var url = args.join('/'); // Was the last one an extension?

        if (/^\.[a-z]+$/.test(underscore.last(args))) {
          // Replace last slash
          url = url.replace(/\/\.[a-z]+$/, underscore.last(args));
        }

        return url;
      }
    }]);

    return Application;
  }(Observable);

  Application.getInstance = function () {
    return _instance;
  };

  ClassMap.register('Application', Application);

  /**
   * An Api instance can be used to make contact with one specific
   * API. 
   *
   * @param {Object} options - Configuration for the Api
   * @param {string} [options.baseUrl=/api] Base url to prepend to all API calls
   * @param {boolean} [options.queueAjaxCalls=false] Whether to execute the API calls one by one (true), or simultaneously (false)
   * 
   */

  var Api =
  /*#__PURE__*/
  function () {
    /**
     * @class Api.Api
     *
     * @constructor
     * @param  {Object} options 	 
     */
    function Api(options) {
      _classCallCheck(this, Api);

      this.settings = jquery.extend({
        baseUrl: '/api',
        queueAjaxCalls: false,
        auth: false,
        beforeSend: false,
        useGlobalStore: true
      }, options);
    }
    /**
     * @method deserialize
     * @return {Data.Model|Data.Collection}
     */


    _createClass(Api, [{
      key: "deserialize",
      value: function deserialize()
      /* data, apiCall = null */
      {
        throw new Error('The Api implementation should have a deserialize method.');
      }
      /**
       * @method getAuth
       * @return {Auth.Auth} 
       */

    }, {
      key: "getAuth",
      value: function getAuth() {
        // Set already?
        if (this.auth) return this.auth;
        if (this.settings.auth === false) return false; // Look it up.

        this.auth = App().auth(this.settings.auth);
        return this.auth;
      } //////////////////
      // HTTP methods //
      //////////////////

      /**
       * @method call
       * @param  {string} method      
       * @param  {string} uri         
       * @param  {Object} [data={}]
       * @param  {Object} [ajaxOptions={}]
       * @return {Api.ApiCall}
       */

    }, {
      key: "call",
      value: function call(method, uri) {
        var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var ajaxOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        // Create api call
        return new ApiCall(this, method, uri, data, ajaxOptions);
      }
      /**
       * @method get
       * @param  {string} uri         
       * @param  {Object} [data={}]
       * @param  {Object} [ajaxOptions={}]
       * @return {Api.ApiCall}
       */

    }, {
      key: "get",
      value: function get(uri) {
        var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var ajaxOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return this.call('get', uri, data, ajaxOptions);
      }
      /**
       * @method post
       * @param  {string} uri         
       * @param  {Object} [data={}]
       * @param  {Object} [ajaxOptions={}]
       * @return {Api.ApiCall}
       */

    }, {
      key: "post",
      value: function post(uri) {
        var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var ajaxOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return this.call('post', uri, data, ajaxOptions);
      }
      /**
       * @method put
       * @param  {string} uri         
       * @param  {Object} [data={}]
       * @param  {Object} [ajaxOptions={}]
       * @return {Api.ApiCall}
       */

    }, {
      key: "put",
      value: function put(uri) {
        var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var ajaxOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return this.call('put', uri, data, ajaxOptions);
      }
      /**
       * @method path
       * @param  {string} uri         
       * @param  {Object} [data={}]
       * @param  {Object} [ajaxOptions={}]
       * @return {Api.ApiCall}
       */

    }, {
      key: "patch",
      value: function patch(uri) {
        var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var ajaxOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return this.call('patch', uri, data, ajaxOptions);
      }
      /**
       * @method delete
       * @param  {string} uri         
       * @param  {Object} [data={}]
       * @param  {Object} [ajaxOptions={}]
       * @return {Api.ApiCall}
       */

    }, {
      key: "delete",
      value: function _delete(uri) {
        var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var ajaxOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return this.call('delete', uri, data, ajaxOptions);
      } ////////////////////
      // Helper methods //
      ////////////////////

      /**
       * @method makeUrl
       * @param  {string} uri 	Relative url within the API
       * @return {string} Fully formed url
       */

    }, {
      key: "makeUrl",
      value: function makeUrl(uri) {
        return this.settings.baseUrl + uri;
      }
      /**
       * Make an ajax call using jQuery
       * 
       * @method ajax
       * @param  {Object} options 
       * @return {jQuery Ajax call}         
       */

    }, {
      key: "ajax",
      value: function ajax(options) {
        var method = this.settings.queueAjaxCalls ? jquery.ajaxq : jquery.ajax;
        if (method === undefined) throw new Error('Could not find Ajax or AjaxQ library. Did you include jquery.ajaxq into your project?');
        return method.apply(null, [this.getAjaxOptions(options)]);
      }
      /**
       * Get jQuery ajax call options for this api
       *
       * @method getAjaxOptions
       * @param {Object = {}} options   Optional options to merge
       * @return {Function}
       */

    }, {
      key: "getAjaxOptions",
      value: function getAjaxOptions() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        // Start with given options
        var beforeSends = [];

        if (options.beforeSend) {
          beforeSends.push(options.beforeSend);
          delete options.beforeSend;
        }

        var ajaxOptions = jquery.extend({
          dataType: 'json'
        }, options); // Get auth options

        var auth = this.getAuth();

        if (auth) {
          var authOptions = auth.getAjaxOptions();

          if (authOptions.beforeSend) {
            beforeSends.push(authOptions.beforeSend);
            delete authOptions.beforeSend;
          }

          jquery.extend(ajaxOptions, authOptions);
        } // Make callback


        ajaxOptions.beforeSend = function (jqXhr, jqOptions) {
          // Loop through before sends
          underscore.each(beforeSends, function (cb) {
            cb(jqXhr, jqOptions);
          });
        };

        return ajaxOptions;
      } ///////////////////
      // Model methods //
      ///////////////////

      /**
       * Get a single Model record from the Api
       * 
       * @method one
       * @param  {string} modelName 
       * @param  {string} idOrUri 
       * @return {Api.ApiCall}
       */

    }, {
      key: "one",
      value: function one(modelName) {
        var idOrUri = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        // Get uri from model
        var ModelClass = Model.registry.get(modelName);
        if (!ModelClass) throw new Error('There is no model registered with the name "' + modelName + '"');
        var uri = /^\//.test(idOrUri) ? idOrUri : ModelClass.definition.getApiUri(idOrUri); // Make the call

        var call = this.get(uri);
        call.modelClass = ModelClass;
        call.expectModel = true;
        return call;
      }
      /**
       * Get all Model records from the Api
       * 
       * @method all
       * @param  {string} modelName
       * @return {Api.ApiCall}
       */

    }, {
      key: "all",
      value: function all(modelName) {
        var uri = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        // Get uri from model
        var ModelClass = Model.registry.get(modelName);
        if (!ModelClass) throw new Error('There is no model registered with the name "' + modelName + '"');
        if (!uri) uri = ModelClass.definition.getApiUri(); // Make the call

        var call = this.get(uri);
        call.modelClass = ModelClass;
        call.expectCollection = true;
        return call;
      }
    }, {
      key: "store",
      value: function store(modelName) {
        // Get uri from model
        var ModelClass = Model.registry.get(modelName);
        if (!ModelClass) throw new Error('There is no model registered with the name "' + modelName + '"');
        var uri = ModelClass.definition.getApiUri(); // Make the call

        var call = this.post(uri);
        call.modelClass = ModelClass;
        call.expectModel = true;
        return call;
      }
      /**
       * Save given model to the Api
       *
       * @method saveModel
       * @param 	{string}	uri
       * @param 	{Data.Model} model
       * @return {Api.ApiCall}
       */

    }, {
      key: "saveModel",
      value: function saveModel()
      /* uri, model */
      {
        throw new Error('The Api implementation should have a saveModel method.');
      }
    }]);

    return Api;
  }();

  /**
   * @module Api
   */

  var JsonApiCall =
  /*#__PURE__*/
  function (_ApiCall) {
    _inherits(JsonApiCall, _ApiCall);

    function JsonApiCall() {
      _classCallCheck(this, JsonApiCall);

      return _possibleConstructorReturn(this, _getPrototypeOf(JsonApiCall).apply(this, arguments));
    }

    _createClass(JsonApiCall, [{
      key: "include",

      /**
       * @class Api.JsonApiCall
       * @extends Api.ApiCall
       * 
       * @constructor
       * @param  {Api.JsonApi} api 	The Api instance this call originates from
       * @param  {string} method      The HTTP method to use (get, post, put, etc.)
       * @param  {string} uri			The uri to call
       * @param  {Object} data        
       * @param  {Object} ajaxOptions 	 
       */

      /**
        * Include the given relationships in the request
        * 
        * @method include
        * @chainable
        * 
        * @param  {string} relations  JSONAPI include options for request
        */
      value: function include(relations) {
        if (relations instanceof Array) {
          relations = relations.join(',');
        }

        relations = inflection.underscore(relations);
        return this.query('include', relations);
      }
    }, {
      key: "filter",
      value: function filter(key, value) {
        // Value a moment?
        if (moment.isMoment(value)) value = value.format('YYYY-MM-DD');
        return this.query('filter[' + inflection.underscore(key) + ']', value);
      }
    }, {
      key: "enrich",
      value: function enrich(keys) {
        return this.query('enrich', keys);
      }
    }, {
      key: "sort",
      value: function sort(key) {
        var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'ascending';
        // Format key
        key = inflection.underscore(key); // Check direction

        if (/^desc/.test(direction)) key = '-' + key; // Apply

        return this.query('sort', key);
      }
    }]);

    return JsonApiCall;
  }(ApiCall);

  /**
   * @module Api
   */

  var JsonApi =
  /*#__PURE__*/
  function (_Api) {
    _inherits(JsonApi, _Api);

    /**
     * @class Api.JsonApi
     * @extends Api.Api
     *
     * @constructor
     * @param  {Object} options
     */
    function JsonApi(options) {
      _classCallCheck(this, JsonApi);

      return _possibleConstructorReturn(this, _getPrototypeOf(JsonApi).call(this, options));
    }

    _createClass(JsonApi, [{
      key: "call",
      value: function call(method, uri) {
        var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var ajaxOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        // Create api call
        return new JsonApiCall(this, method, uri, data, ajaxOptions);
      }
    }, {
      key: "saveModel",
      value: function saveModel(model, options) {
        // Make settings
        var settings = jquery.extend({
          includeRelated: true,
          includeRelatedData: false // False, true, or array of relationship names

        }, options);
        if (!settings.uri) settings.uri = model.getApiUri(); // Make the data

        var data = {
          data: this.serialize(model, settings.includeRelated, settings.includeRelatedData)
        }; // Check method

        var method = model.isNew() ? 'post' : 'patch'; // Do the call

        var cache = [];
        var apiCall = this.call(method, settings.uri, JSON.stringify(data, function (key, value) {
          if (_typeof(value) === 'object' && value !== null) {
            if (cache.indexOf(value) !== -1) {
              // Circular reference found, discard key
              return;
            } // Store value in our collection


            cache.push(value);
          }

          return value;
        }), settings.ajax);
        cache = null; // Enable garbage collection
        // Return it

        return apiCall;
      }
    }, {
      key: "deleteModel",
      value: function deleteModel(model, options) {
        // Make settings
        var settings = jquery.extend({}, options);
        if (!settings.uri) settings.uri = model.getApiUri(); // Make the data

        var data = {
          data: this.serialize(model)
        }; // Do the call

        var cache = [];
        var apiCall = this.call('delete', settings.uri, JSON.stringify(data, function (key, value) {
          if (_typeof(value) === 'object' && value !== null) {
            if (cache.indexOf(value) !== -1) {
              // Circular reference found, discard key
              return;
            } // Store value in our collection


            cache.push(value);
          }

          return value;
        }), settings.ajax);
        cache = null; // Enable garbage collection
        // Return it

        return apiCall;
      }
    }, {
      key: "serialize",
      value: function serialize(model) {
        var _this = this;

        var includeRelated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var includeRelatedData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var includedModelGuids = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
        // Check related data
        if (typeof includeRelatedData === 'string') includeRelatedData = [includeRelatedData]; // Basics: type and id

        var data = {
          type: inflection.pluralize(inflection.underscore(model.getDefinition().name))
        };
        var id = model.get('id');
        if (id) data.id = id; // Add pivot data?		

        if (model.isPivot()) {
          // Get attributes (non-dirty as well.)
          var pivotAttributes = model.getPivot().getAttributesForApi(false);

          if (underscore.size(pivotAttributes) > 0) {
            // Convert for API
            var meta = {};

            underscore.each(pivotAttributes, function (value, key) {
              meta[inflection.underscore(key)] = value;
            }); // Set as meta data


            data.meta = meta;
          }
        } // Was this model already added before? Then we skip attributes and relationships


        if (!underscore.contains(includedModelGuids, Utils.uidFor(model))) {
          // Attributes?
          var attr = model.getAttributesForApi(!model.isNew());

          if (underscore.size(attr) > 0) {
            data.attributes = {};

            underscore.each(attr, function (value, key) {
              data.attributes[inflection.underscore(key)] = value;
            });
          } // Add model guid now, if it hasn't been added before


          includedModelGuids.push(Utils.uidFor(model)); // @TODO Check wheter the reverse of a relationship was already included
          // e.g. In case of author > books > author, the last 'author' should be skipped, even
          // when the 'book' model has it defined.
          // Include related?

          if (includeRelated) {
            // Loop through relationships
            var relationships = {};

            underscore.each(model.related, function (relatedData, key) {
              // Is it a collection?
              if (relatedData instanceof Collection) {
                // Is dirty? or had dirty children
                if (relatedData.isDirty() || relatedData.hasDirtyChildren()) {
                  // Add them all
                  relationships[key] = {
                    data: underscore.map(relatedData.items, function (item) {
                      // Store original model to prevent recursive loop (only when the attributes have not been added yet, but should be)
                      if (includeRelatedData === false || !underscore.contains(includeRelatedData, key)) {
                        includedModelGuids.push(Utils.uidFor(item));
                      } // Add that model, but only add relationships when this model has not been added to the resource before, to prevent nesting recursive loop


                      return _this.serialize(item, true, includeRelatedData, includedModelGuids);
                    })
                  };
                }
              } else if (relatedData instanceof Model) {
                // Store original model to prevent recursive loop (only when the attributes have not been added yet, but should be)
                if (includeRelatedData === false || underscore.indexOf(includeRelatedData, key) === -1) {
                  includedModelGuids.push(Utils.uidFor(relatedData));
                } // Is it dirty?


                if (relatedData.isDirty()) {
                  // We always add the related model data
                  relationships[key] = {
                    data: _this.serialize(relatedData, true, includeRelatedData, includedModelGuids)
                  };
                }
              } else if (relatedData) {
                // What is this
                throw new TypeError('Unrecognized data found in model\'s relationship ' + key);
              }
            });

            if (underscore.size(relationships) > 0) {
              data.relationships = relationships;
            }
          }
        }

        return data;
      }
    }, {
      key: "deserialize",
      value: function deserialize(result) {
        var _this2 = this;

        var apiCall = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        // Call given?
        if (!apiCall) {
          apiCall = new JsonApiCall(this, 'get', '/foo/bar');
        } // Check included data


        if (result.included) {
          // Loop and store them in the model stores
          underscore.each(result.included, function (recordData) {
            _this2.deserializeModel(recordData, apiCall, false);
          });

          underscore.each(result.included, function (recordData) {
            _this2._deserializeRelationships(recordData, apiCall);
          });
        } // Is the result an object or an array


        var data = result.data;
        if (data === undefined || data === null) throw new Error('No data received from Api');

        if (data instanceof Array) {
          return this.deserializeCollection(data, apiCall, result.meta);
        } else if (data instanceof Object) {
          return this.deserializeModel(data, apiCall);
        } // Don't know...


        throw new TypeError('Unrecognized data received from Api');
      }
    }, {
      key: "deserializeModel",
      value: function deserializeModel(data, apiCall) {
        var _this3 = this;

        var deserializeRelationships = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        // Look for the type of model
        var resourceType = data.type;
        var modelClass = Model;

        if (!resourceType) {
          throw new TypeError('Api result did not specity the record type');
        }

        var modelName = this._getModelName(resourceType);

        if (Model.registry.has(modelName)) {
          modelClass = Model.registry.get(modelName);
        } // Collect attributes


        var attributes = {};

        underscore.each(data.attributes, function (value, key) {
          attributes[inflection.camelize(key, true)] = value;
        }); // Check if the model is already in the store


        var model = apiCall.getResponseModel(modelName, data.id);

        if (!model) {
          // Create a new model.
          attributes.id = /^\d+$/.test(data.id) ? parseInt(data.id) : data.id;
          model = new modelClass(attributes);
          apiCall.storeReponseModel(model);
        } else {
          // Set the attributes (not overwriting dirty ones)
          model.setAttributesFromApi(attributes);
        } // Meta?


        if (data.meta) {
          var metaAttributes = {};

          underscore.each(data.meta, function (value, key) {
            metaAttributes[inflection.camelize(key, true)] = value;
          });

          model.setMetaAttributes(metaAttributes);
        } // Also deserialize relationships?


        if (deserializeRelationships) {
          model.withoutNotifications(function () {
            _this3._deserializeRelationships(data, apiCall, model);
          });
        }

        return model;
      }
    }, {
      key: "deserializeCollection",
      value: function deserializeCollection(data, apiCall) {
        var _this4 = this;

        var meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        // Make a collection
        var collection = new Collection(apiCall.modelClass); // Add records

        underscore.each(data, function (recordData) {
          collection.addFromApi(_this4.deserializeModel(recordData, apiCall), true);
        }); // Store meta data


        if (meta) {
          // Store it
          collection.setMetaData(meta); // Check pagination

          if (meta.pagination) {
            collection.setPageInfo(meta.pagination.current_page, meta.pagination.total_pages, meta.pagination.per_page, meta.pagination.total);
          }
        }

        return collection;
      }
    }, {
      key: "_deserializeRelationships",
      value: function _deserializeRelationships(data, apiCall) {
        var _this5 = this;

        var model = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        // Model given?
        if (model === null) {
          // Look it up in the store			
          model = apiCall.getResponseModel(this._getModelName(data.type), data.id); // Not known?

          if (!model) throw new Error('Could not deserialize relationships for unknown model: ' + this._getModelName(data.type) + ' with id ' + data.id);
        } // Check relationships records.


        if (data.relationships) {
          underscore.each(data.relationships, function (rel, relationshipName) {
            // Is there data?
            if (rel.data) {
              // Camelize
              var modelRelName = inflection.camelize(relationshipName, true); // Is it one record?

              if (rel.data instanceof Array) {
                // Find relationship
                var relationship = model.getRelationship(modelRelName); // Loop and add

                underscore.each(rel.data, function (relData) {
                  // Get the model
                  var relatedModel = _this5._getRelatedModel(relData, apiCall);

                  if (relatedModel) {
                    // Pivot data defined?
                    var pivotAttributes = null;

                    if (relData.meta && relationship.isPivot() && relationship.pivotModel) {
                      // Collect pivot attributes
                      pivotAttributes = {};

                      underscore.each(relData.meta, function (value, key) {
                        pivotAttributes[inflection.camelize(key, true)] = value;
                      });
                    } // Add to collection


                    model.addRelatedModel(modelRelName, relatedModel, true, pivotAttributes);
                  }
                }); // Is the relationship sorted?						


                if (relationship && relationship.sortCallback && model.related[modelRelName]) {
                  // Apply sorting
                  model.related[modelRelName].sortBy(relationship.sortCallback);
                }
              } else if (rel.data instanceof Object) {
                // Get the one
                var relatedModel = _this5._getRelatedModel(rel.data, apiCall);

                if (relatedModel) {
                  // Set it
                  model.setRelatedModel(modelRelName, relatedModel);
                }
              } else {
                throw new TypeError('Unrecognized relationship data received from Api');
              }
            }
          });
        } // Trigger the event


        model.trigger('deserialized', [this]);
      }
    }, {
      key: "_getRelatedModel",
      value: function _getRelatedModel(relationshipData, apiCall) {
        // Check data integrity
        var relType = relationshipData.type;
        var relId = relationshipData.id;
        if (!relType) throw new TypeError('Api result did not specify the relationship type');
        if (!relId) throw new TypeError('Api result did not specify the relationship record id'); // Find model in store

        relType = this._getModelName(relType);
        var relModel = apiCall.getResponseModel(relType, relId);
        return relModel;
      }
    }, {
      key: "_getModelName",
      value: function _getModelName(resourceType) {
        // directions.locations => Directions.Location
        // times => Time
        var parts = resourceType.split('.');

        var modelType = underscore.map(parts, function (part, index) {
          part = inflection.camelize(part);
          return index === parts.length - 1 ? inflection.singularize(part) : part;
        }).join('.');

        return modelType;
      }
    }]);

    return JsonApi;
  }(Api);

  /**
   * @module Api
   */

  var PrimitiveJsonApiCall =
  /*#__PURE__*/
  function (_ApiCall) {
    _inherits(PrimitiveJsonApiCall, _ApiCall);

    function PrimitiveJsonApiCall() {
      _classCallCheck(this, PrimitiveJsonApiCall);

      return _possibleConstructorReturn(this, _getPrototypeOf(PrimitiveJsonApiCall).apply(this, arguments));
    }

    _createClass(PrimitiveJsonApiCall, [{
      key: "include",

      /**
       * @class Api.PrimitiveJsonApiCall
       * @extends Api.ApiCall
       * 
       * @constructor
       * @param  {Api.JsonApi} api 	The Api instance this call originates from
       * @param  {string} method      The HTTP method to use (get, post, put, etc.)
       * @param  {string} uri			The uri to call
       * @param  {Object} data        
       * @param  {Object} ajaxOptions 	 
       */

      /**
        * Include the given relationships in the request
        * 
        * @method include
        * @chainable
        * 
        * @param  {string} relations  JSONAPI include options for request
        */
      value: function include(relations) {
        if (relations instanceof Array) {
          relations = relations.join(',');
        }

        return this.query('include', relations);
      }
    }, {
      key: "filter",
      value: function filter(key, value) {
        return this.query('filter[' + inflection.underscore(key) + ']', value);
      }
    }]);

    return PrimitiveJsonApiCall;
  }(ApiCall);

  /**
   * @module Api
   */

  var PrimitiveJsonApi =
  /*#__PURE__*/
  function (_Api) {
    _inherits(PrimitiveJsonApi, _Api);

    /**
     * @class Api.PrimitiveJsonApi
     * @extends Api.Api
     *
     * @constructor
     * @param  {Object} options
     */
    function PrimitiveJsonApi(options) {
      _classCallCheck(this, PrimitiveJsonApi);

      return _possibleConstructorReturn(this, _getPrototypeOf(PrimitiveJsonApi).call(this, options));
    }

    _createClass(PrimitiveJsonApi, [{
      key: "call",
      value: function call(method, uri) {
        var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var ajaxOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        // Create api call
        return new PrimitiveJsonApiCall(this, method, uri, data, ajaxOptions);
      }
    }, {
      key: "saveModel",
      value: function saveModel()
      /*model, options*/
      {
        throw new Error('saveModel is not implemented');
      }
    }, {
      key: "deleteModel",
      value: function deleteModel()
      /*model, options*/
      {
        throw new Error('deleteModel is not implemented');
      }
    }, {
      key: "serialize",
      value: function serialize()
      /*model, includeRelated = true, includeRelatedData = false, includedModelGuids = []*/
      {
        throw new Error('serialize is not implemented');
      }
    }, {
      key: "deserialize",
      value: function deserialize(result) {
        var _this = this;

        var apiCall = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        // Call given?
        if (!apiCall) {
          apiCall = new PrimitiveJsonApiCall(this, 'get', '/foo/bar');
        } // Check relationship map


        if (result.links) {
          var map = {};

          underscore.each(result.links, function (info, key) {
            // Check key (e.g. journeys.line)
            var parts = key.split(/\./);
            var localModel = parts[0];
            var attribute = parts[1]; // Store in map

            map[localModel] = map[localModel] || {};
            map[localModel][attribute] = info.type;
          });

          apiCall.relationshipMap = map;
        } // Deduce root element


        var rootElement = underscore.camelize(inflection.pluralize(apiCall.modelClass.modelName), true); // Check included data	


        if (result.linked) {
          // Loop and store them in the model stores
          underscore.each(result.linked, function (records, key) {
            // Guess model
            var modelClass = Model.registry.get(inflection.camelize(inflection.singularize(key)));
            if (!modelClass) throw new Error('Api result contains resource for which there is no Model defined: ' + inflection.camelize(inflection.singularize(key)));

            underscore.each(records, function (recordData) {
              _this.deserializeModel(recordData, apiCall, false, modelClass);
            });
          }); // Now loop again, and connect related models to each other


          underscore.each(result.linked, function (records, key) {
            // Guess model
            var modelClass = Model.registry.get(inflection.camelize(inflection.singularize(key)));

            underscore.each(records, function (recordData) {
              _this._deserializeRelationships(recordData, apiCall, key, null, modelClass);
            });
          });
        } // Is the result an object or an array


        var data = result[rootElement];
        if (data === undefined || data === null) throw new Error('No data received from Api');

        if (data instanceof Array) {
          return this.deserializeCollection(data, apiCall);
        } else if (data instanceof Object) {
          return this.deserializeModel(data, apiCall);
        } // Don't know...


        throw new TypeError('Unrecognized data received from Api');
      }
    }, {
      key: "deserializeModel",
      value: function deserializeModel(data, apiCall) {
        var _this2 = this;

        var deserializeRelationships = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var modelClass = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        // Look for the type of model
        modelClass = modelClass || apiCall.modelClass;
        var modelName = modelClass.modelName; // Collect attributes

        var attributes = {};

        underscore.each(data, function (value, key) {
          attributes[inflection.camelize(key, true)] = value;
        }); // Check if the model is already in the store


        var model = apiCall.getResponseModel(modelName, data.id);

        if (!model) {
          // Create a new model.
          attributes.id = /^\d+$/.test(data.id) ? parseInt(data.id) : data.id;
          model = new modelClass(attributes);
          apiCall.storeReponseModel(model);
        } else {
          // Set the attributes (not overwriting dirty ones)
          model.setAttributesFromApi(attributes);
        } // Also deserialize relationships?


        if (deserializeRelationships) {
          var localKey = underscore.underscored(inflection.pluralize(modelName));

          model.withoutNotifications(function () {
            _this2._deserializeRelationships(data, apiCall, localKey, model);
          });
        }

        return model;
      }
    }, {
      key: "deserializeCollection",
      value: function deserializeCollection(data, apiCall) {
        var _this3 = this;

        // Make a collection
        var collection = new Collection(apiCall.modelClass); // Add records

        underscore.each(data, function (recordData) {
          collection.addFromApi(_this3.deserializeModel(recordData, apiCall), true);
        });

        return collection;
      }
    }, {
      key: "_deserializeRelationships",
      value: function _deserializeRelationships(data, apiCall, localModelKey) {
        var _this4 = this;

        var model = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var modelClass = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

        // Model given?
        if (model === null) {
          // Look it up in the store			
          model = apiCall.getResponseModel(this._getModelName(modelClass.modelName), data.id); // Not known?

          if (!model) throw new Error('Could not deserialize relationships for unknown model: ' + this._getModelName(data.type) + ' with id ' + data.id);
        } // Check relationships records.


        if (data.links) {
          underscore.each(data.links, function (rel, relationshipName) {
            // Is there data?
            if (rel) {
              // __chicken variable?
              if (relationshipName.match(/^__/)) return; // Camelize

              var modelRelName = inflection.camelize(relationshipName, true);
              var resourceType = apiCall.relationshipMap[localModelKey][relationshipName]; // Is it one record?

              if (rel instanceof Array) {
                // Find relationship
                var relationship = model.getRelationship(modelRelName); // Loop and add

                underscore.each(rel, function (relData) {
                  // Get the model
                  var relatedModel = _this4._getRelatedModel(relData, resourceType, apiCall);

                  if (relatedModel) {
                    // Pivot data defined?
                    var pivotAttributes = null;

                    if (relData.meta && relationship.isPivot() && relationship.pivotModel) {
                      // Collect pivot attributes
                      pivotAttributes = {};

                      underscore.each(relData.meta, function (value, key) {
                        pivotAttributes[inflection.camelize(key, true)] = value;
                      });
                    } // Add to collection


                    model.addRelatedModel(modelRelName, relatedModel, true, pivotAttributes);
                  }
                });
              } else {
                // Get the one
                var relatedModel = _this4._getRelatedModel(rel, resourceType, apiCall);

                if (relatedModel) {
                  // Set it
                  model.setRelatedModel(modelRelName, relatedModel);
                }
              }
            }
          });
        } // Trigger the event


        model.trigger('deserialized', [this]);
      }
    }, {
      key: "_getRelatedModel",
      value: function _getRelatedModel(relId, relType, apiCall) {
        // Check data integrity
        if (!relType) throw new TypeError('Api result did not specify the relationship type');
        if (!relId) throw new TypeError('Api result did not specify the relationship record id'); // Find model in store

        relType = this._getModelName(relType);
        var relModel = apiCall.getResponseModel(relType, relId);
        return relModel;
      }
    }, {
      key: "_getModelName",
      value: function _getModelName(resourceType) {
        // directions.locations => Directions.Location
        // times => Time
        var parts = resourceType.split('.');

        var modelType = underscore.map(parts, function (part, index) {
          part = inflection.camelize(part);
          return index === parts.length - 1 ? inflection.singularize(part) : part;
        }).join('.');

        return modelType;
      }
    }]);

    return PrimitiveJsonApi;
  }(Api);

  /**
   * @module Auth
   */

  var Auth =
  /*#__PURE__*/
  function (_Observable) {
    _inherits(Auth, _Observable);

    /**
     * @class Auth.Auth
     *
     * @param 	{Object} options 
     * @constructor
     */
    function Auth() {
      var _this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, Auth);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Auth).call(this)); // Default options

      _this.settings = underscore.defaults(options, {
        getUserUri: '/me',
        onAuthenticated: null,
        onUnauthenticated: null,
        onSessionTimedOut: null,
        onInvalidated: null,
        middlewareName: 'auth'
      });

      _this.set('isAuthenticated', false); // Register the middleware


      _this.middleware = new Middleware(_this.settings.middlewareName, function (next, request, routeMatch) {
        return _this.middlewareAction(next, request, routeMatch);
      });
      Middleware.register(_this.middleware);
      return _this;
    }
    /**
     * Act as middleware for given request
     *
     * @method middleWareAction
     * @param  {Callback} 			next		The callback to call when everything is okay
     * @param  {Routing.Request} 	request 
     * @param  {Routing.RouteMatch} 		routeMatch   	 	 
     */


    _createClass(Auth, [{
      key: "middlewareAction",
      value: function middlewareAction(next, request, routeMatch) {
        // Are we not authenticated?
        if (!this.isAuthenticated()) {
          // Trigger the unauthenticated event
          if (!this.settings.onUnauthenticated) {
            throw new Error('Protected route called without authentication.');
          } // Do the callback


          this.doCallback('onUnauthenticated', [request, routeMatch]);
          return;
        } // Ok.


        next();
      }
    }, {
      key: "doCallback",
      value: function doCallback(key, params) {
        var _this2 = this;

        // Promise
        return new Promise(function (resolve, reject) {
          // Do we have one?
          var callback = _this2.settings[key];

          if (!callback) {
            reject('There is no callback defined for ' + key);
          } // Is it a string with a uri?


          if (typeof callback === 'string') {
            App().goto(callback);
            resolve();
          } // Get the result from the callback


          var result = callback.apply(_this2, params); // Is there something resolvable in there?

          if (result && result instanceof Promise) {
            // Link it.
            result.then(function (result) {
              resolve(result);
            }, function (error) {
              reject(error);
            });
          } else {
            // Just resolve now
            resolve(result);
          }
        });
      }
      /**
       * Try to authenticate using given credentials
       * 
       * @method authenticate
       * @param  {object} credentials 
       * @return {Promise}
       */

    }, {
      key: "authenticate",
      value: function authenticate()
      /* credentials */
      {
        throw new Error('The ' + this.constructor.name + ' class has not implemented the "authenticate" method');
      }
      /**
       * Try to invalidate the current authenticated session
       *
       * @method invalidate
       * @return {Promise}
       */

    }, {
      key: "invalidate",
      value: function invalidate() {
        throw new Error('The ' + this.constructor.name + ' class has not implemented the "invalidate" method');
      }
      /**
       * Check whether the session is authenticated
       * 
       * @method isAuthenticated
       * @return {Boolean}
       */

    }, {
      key: "isAuthenticated",
      value: function isAuthenticated() {
        return this.get('isAuthenticated');
      }
      /**
       * Authorize given ApiCall instance, adding necessary
       * authorization headers, etc.
       * 
       * @method authorizeApiCall
       * @param  {Api.ApiCall} apiCall 
       * @return {Api.ApiCall}
       */

    }, {
      key: "authorizeApiCall",
      value: function authorizeApiCall(apiCall) {
        // Extend with my options
        var ajaxOptions = this.getAjaxOptions();
        jquery.extend(apiCall.ajaxOptions, ajaxOptions);
        return apiCall;
      }
    }, {
      key: "getAjaxOptions",
      value: function getAjaxOptions() {
        return {};
      }
      /**
       * Read given Api Error and update session accordingly, if
       * appropriate.
       *
       * @method processApiError
       * @param  {object} error 
       * @return {object}       
       */

    }, {
      key: "processApiError",
      value: function processApiError(error) {
        return error;
      }
    }]);

    return Auth;
  }(Observable);

  /**
   * @module AuthError
   */
  var AuthError =
  /*#__PURE__*/
  function () {
    function AuthError(auth, xhrError) {
      _classCallCheck(this, AuthError);

      /**
       * @property auth
       * @type {Auth.Auth}
       */
      this.auth = auth;
      /**
       * @property xhrError
       * @type {jqXHR}
       */

      this.xhrError = xhrError;
    }

    _createClass(AuthError, [{
      key: "getMessage",
      value: function getMessage() {
        // JSON body with message?
        if (this.xhrError.responseJSON && this.xhrError.responseJSON.message) {
          return this.xhrError.responseJSON.message;
        } // Text?


        if (this.xhrError.responseText) return this.xhrError.responseText; // Don't know

        return 'Unknown error';
      }
    }]);

    return AuthError;
  }();

  /**
   * @module Auth
   */

  var JWTAuth =
  /*#__PURE__*/
  function (_Auth) {
    _inherits(JWTAuth, _Auth);

    /**
     * @class Auth.JWTAuth
     * @extends Auth.Auth
     *
     * @param 	{Object} options 
     * @constructor
     */
    function JWTAuth() {
      var _this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, JWTAuth);

      // Default options
      options = jquery.extend({
        baseUrl: '',
        authenticateUri: '/authenticate',
        refreshUri: '/authenticate/refresh',
        currentUserUri: '/me',
        authenticateMethod: 'post',
        refreshMethod: 'post',
        middlewareName: 'auth.jwt',
        beforeSend: false,
        identifierKey: 'email',
        passwordKey: 'password',
        tokenValidForMinutes: 360,
        autoRefreshToken: true,
        autoRefreshInterval: 7200,
        // 2 hours
        localStorageKey: 'ChickenJWTAuthToken',
        storeCredentialsLocally: false
      }, options);
      _this = _possibleConstructorReturn(this, _getPrototypeOf(JWTAuth).call(this, options));
      /**
       * The current token
       * 
       * @property token
       * @type {string}
       */

      _this.token = null;
      return _this;
    }

    _createClass(JWTAuth, [{
      key: "initialize",
      value: function initialize() {
        var _this2 = this;

        // Get token from localstorage
        try {
          this.token = JSON.parse(localStorage.getItem("".concat(this.settings.localStorageKey, ".token")));
        } catch (err) {
          this.token = null;
        } // Do we have a non-expired token?


        var hasToken = false;

        if (this.token && this.token.receivedAt) {
          // More than 30 minutes old?
          var minTime = moment().unix() - this.settings.tokenValidForMinutes * 60;
          hasToken = this.token.receivedAt > minTime;
        } // No token?


        if (!hasToken) {
          // Credentials stored locally?
          if (this.settings.storeCredentialsLocally) {
            try {
              // Retrieve credentials
              var credentials = JSON.parse(localStorage.getItem("".concat(this.settings.localStorageKey, ".credentials")));

              if (credentials) {
                return new Promise(function (resolve) {
                  // Try to authenticate using stored creds
                  _this2.authenticate(credentials.identifier, credentials.password).then(function () {
                    // Auth Successful!
                    resolve(true);
                  }, function () {
                    // Auth failed
                    resolve(false);
                  });
                });
              }
            } catch (err) {// Continue...
            }
          }
        } // Validate the token


        return new Promise(function (resolve) {
          // No token?
          if (!hasToken) {
            resolve(false);
            return;
          } // Wheter we are or are not authenticated, we resolve, because initializion is complete


          _this2.validateToken().then(function () {
            // Authenticated
            _this2.doCallback('onAuthenticated', []).then(function () {
              _this2.set('isAuthenticated', true);

              resolve(true);
            });
          }, function () {
            resolve(false);
          });
        });
      }
      /**
       * Try to authenticate using given credentials
       * 
       * @method authenticate
       * @param  {string} identifier 	Usually the email address
       * @param  {string} password   
       * @return {Promise} 
       */

    }, {
      key: "authenticate",
      value: function authenticate(identifier, password) {
        var _this3 = this;

        // Make a call.
        return new Promise(function (resolve, reject) {
          // Prepare data
          var data = {};
          data[_this3.settings.identifierKey] = identifier;
          data[_this3.settings.passwordKey] = password; // Make the call.

          jquery.ajax({
            url: _this3.settings.baseUrl + _this3.settings.authenticateUri,
            data: data,
            method: _this3.settings.authenticateMethod,
            beforeSend: _this3.settings.beforeSend
          }).then(function (result) {
            // Check token.
            if (!result.token) reject('Could not find token in result'); // Store it.

            _this3.setToken(result.token); // Store credentials


            if (_this3.settings.storeCredentialsLocally) {
              localStorage.setItem("".concat(_this3.settings.localStorageKey, ".credentials"), JSON.stringify({
                identifier: identifier,
                password: password
              }));
            } // Handle user events


            _this3.doCallback('onAuthenticated', []).then(function () {
              _this3.set('isAuthenticated', true);

              resolve(_this3.token);
            });
          }).fail(function (error) {
            reject(new AuthError(_this3, error));
          });
        });
      }
    }, {
      key: "invalidate",
      value: function invalidate() {
        var _this4 = this;

        return new Promise(function (resolve
        /*, reject*/
        ) {
          // Waiting to time out?
          if (_this4.sessionTimeoutTimeout) {
            clearTimeout(_this4.sessionTimeoutTimeout);
            _this4.sessionTimeoutTimeout = false;
          }

          if (_this4.autoRefreshTimeout) {
            clearTimeout(_this4.autoRefreshTimeout);
            _this4.autoRefreshTimeout = false;
          } // Remove token


          _this4.token = false;
          localStorage.removeItem("".concat(_this4.settings.localStorageKey, ".token"));

          _this4.set('isAuthenticated', false);

          _this4.doCallback('onInvalidated', []);

          _this4.trigger('invalidated');

          resolve();
        });
      }
    }, {
      key: "refreshToken",
      value: function refreshToken() {
        var _this5 = this;

        // Waiting to time out?
        if (this.autoRefreshTimeout) {
          clearTimeout(this.autoRefreshTimeout);
          this.autoRefreshTimeout = false;
        } // Make a call.


        return new Promise(function (resolve, reject) {
          // Already timed out?
          if (!_this5.isAuthenticated()) {
            reject('Cannot refresh token when not authenticated');
            return;
          } // Make the call.


          jquery.ajax({
            url: _this5.settings.baseUrl + _this5.settings.refreshUri,
            method: _this5.settings.refreshMethod,
            beforeSend: function beforeSend(xhr) {
              xhr.setRequestHeader('Authorization', 'Bearer ' + _this5.token.token);
            }
          }).then(function (result) {
            // Check token.
            if (!result.token) reject('Could not find token in result'); // Store it.

            _this5.setToken(result.token);

            resolve(_this5.token); // Authenticated

            _this5.trigger('tokenRefreshed');
          }).fail(function (error) {
            _this5.invalidate();

            reject(new AuthError(_this5, error));
          });
        });
      }
    }, {
      key: "setToken",
      value: function setToken(tokenString) {
        // Store it
        this.token = {
          token: tokenString,
          receivedAt: moment().unix()
        }; // Waiting to time out?

        if (this.sessionTimeoutTimeout) {
          clearTimeout(this.sessionTimeoutTimeout);
          this.sessionTimeoutTimeout = false;
        }

        if (this.autoRefreshTimeout) {
          clearTimeout(this.autoRefreshTimeout);
          this.autoRefreshTimeout = false;
        } // Remember it.


        localStorage.setItem("".concat(this.settings.localStorageKey, ".token"), JSON.stringify(this.token)); // We are logged in

        this.validateToken();
      }
    }, {
      key: "clearToken",
      value: function clearToken() {
        this.token = null;
        localStorage.removeItem("".concat(this.settings.localStorageKey, ".token"));
      }
    }, {
      key: "forgetCredentials",
      value: function forgetCredentials() {
        localStorage.removeItem("".concat(this.settings.localStorageKey, ".credentials"));
      }
    }, {
      key: "validateToken",
      value: function validateToken() {
        var _this6 = this;

        return new Promise(function (resolve, reject) {
          // Any token?
          if (_this6.token) {
            // Is it an object?
            if (_this6.token instanceof Object) {
              // Still valid?
              var now = moment().unix();
              var timesOutAt = _this6.token.receivedAt + _this6.settings.tokenValidForMinutes * 60;

              if (timesOutAt < now) {
                // No longer valid.
                _this6.set('isAuthenticated', false);

                _this6.clearToken();

                reject();
                return;
              } // Auto refresh?


              if (_this6.settings.autoRefreshToken) {
                // Wait a bit and then refresh
                if (_this6.autoRefreshTimeout) clearTimeout(_this6.autoRefreshTimeout);
                var refreshAt = _this6.token.receivedAt + _this6.settings.autoRefreshInterval;
                var timeoutMs = Math.max((refreshAt - now) * 1000, 5000);
                _this6.autoRefreshTimeout = setTimeout(function () {
                  _this6.autoRefreshTimeout = false;

                  _this6.refreshToken();
                }, timeoutMs);
              } // Wait for it to timeout


              if (_this6.sessionTimeoutTimeout) clearTimeout(_this6.sessionTimeoutTimeout);
              _this6.sessionTimeoutTimeout = setTimeout(function () {
                ////////////////////////////////
                // Make the session time out! //
                ////////////////////////////////
                _this6.sessionTimeoutTimeout = false;

                _this6.trigger('sessionTimedOut');

                _this6.set('isAuthenticated', false);

                _this6.token = null;
                if (_this6.autoRefreshTimeout) clearTimeout(_this6.autoRefreshTimeout);
              }, (timesOutAt - now) * 1000); // Done!

              resolve();
            } else {
              // Not valid
              _this6.set('isAuthenticated', false);

              reject();
              _this6.token = null;
            }
          } else {
            // Not authenticated
            _this6.set('isAuthenticated', false);

            reject();
          }
        });
      }
    }, {
      key: "processApiError",
      value: function processApiError(error) {
        // Unauthorized?
        if (error.xhrError.status === 401) {
          if (error.getMessage() === 'Unable to authenticate with invalid token.') {
            this.invalidate();
          }
        }

        return error;
      }
    }, {
      key: "getAjaxOptions",
      value: function getAjaxOptions() {
        var _this7 = this;

        // Add token.
        var options = {};

        if (this.token) {
          // Add the bearer token
          options.beforeSend = function (xhr) {
            xhr.setRequestHeader('Authorization', 'Bearer ' + _this7.token.token);
          };
        }

        return options;
      }
    }]);

    return JWTAuth;
  }(Auth);

  JWTAuth.Events = {
    /**
     * This event is triggered when a successful token refresh
     * action is completed
     * 
     * @event tokenRefreshed
     * @type {String}
     */
    TokenRefreshed: 'tokenRefreshed'
  };

  var ModelAttribute =
  /*#__PURE__*/
  function () {
    function ModelAttribute(name, type) {
      _classCallCheck(this, ModelAttribute);

      this.name = name;
      this.type = type;
      this.isPrimaryKey = false;
      this.isNullable = false;
      this.isUnique = false;
      this.defaultValue = undefined;
      this.includeInRequests = true;
      this.size = null;
      this.enumOptions = null;
    }

    _createClass(ModelAttribute, [{
      key: "default",
      value: function _default(value) {
        this.defaultValue = value;
        return this;
      }
    }, {
      key: "primary",
      value: function primary() {
        var isPrimaryKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this.isPrimaryKey = isPrimaryKey;
        return this;
      }
    }, {
      key: "unique",
      value: function unique() {
        var isUnique = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this.isUnique = isUnique;
        return this;
      }
    }, {
      key: "nullable",
      value: function nullable() {
        var isNullable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this.isNullable = isNullable;
        return this;
      }
    }, {
      key: "hidden",
      value: function hidden() {
        var isHiddenFromRequests = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this.includeInRequests = !isHiddenFromRequests;
        return this;
      }
      /**
       * Cast given (database) value for use in the application,
       * according to the type of this attribute
       * 
       * @method cast
       * @param  {mixed} value 
       * @return {mixed}       
       */

    }, {
      key: "cast",
      value: function cast(value) {
        // Undefined and null will remain so
        if (value === undefined || value === null) return value;

        switch (this.type) {
          ////////////////
          // Primitives //
          ////////////////
          // Number
          case ModelAttribute.Number:
            return value instanceof Number ? value : Number.parseFloat(value);
          // Integer

          case ModelAttribute.Integer:
            return Number.isInteger(value) ? value : Number.parseInt(value);
          // String

          case ModelAttribute.String:
            return value instanceof String ? value : '' + value;
          // Array

          case ModelAttribute.Array:
            return typeof value === 'string' ? JSON.parse(value) : value;
          ///////////
          // Dates //
          ///////////
          // Date or date time

          case ModelAttribute.Date:
          case ModelAttribute.DateTime:
            return value && !moment.isMoment(value) ? moment(value) : value;

          default:
            return value;
        }
      }
      /**
       * Cast given application value back for use in the database/api.
       *
       * @method uncast
       * @param  {mixed} value 
       * @return {mixed}       
       */

    }, {
      key: "uncast",
      value: function uncast(value) {
        // Undefined and null will remain so
        if (value === undefined || value === null) return value;
        var v;

        switch (this.type) {
          ////////////////
          // Primitives //
          ////////////////
          // Number
          case ModelAttribute.Number:
            return value instanceof Number ? value : Number.parseFloat(value);
          // Integer

          case ModelAttribute.Integer:
            return Number.isInteger(value) ? value : Number.parseInt(value);
          // String

          case ModelAttribute.String:
            return value instanceof String ? value : '' + value;
          //Array

          case ModelAttribute.Array:
            if (value instanceof ObservableArray) value = value.toArray();
            return value;
          ///////////
          // Dates //
          ///////////
          // Date or date time

          case ModelAttribute.Date:
            return moment.isMoment(value) ? value.format('YYYY-MM-DD') : value;

          case ModelAttribute.DateTime:
            return moment.isMoment(value) ? value.format('YYYY-MM-DD HH:mm:ss') : value;
          /////////////
          // Objects //
          /////////////

          case ModelAttribute.Object:
            v = underscore.omit(value instanceof Observable ? value.attributes : value, function (foo, key) {
              return /^__/.test(key);
            });
            return v;

          default:
            return value;
        }
      }
    }, {
      key: "getDefaultValue",
      value: function getDefaultValue() {
        // Is there a value?
        if (this.defaultValue) return this.defaultValue; // Nullable?

        if (this.isNullable) return null; // Default for type

        switch (this.type) {
          ////////////////
          // Primitives //
          ////////////////
          // Number
          case ModelAttribute.Number:
          case ModelAttribute.Integer:
            return 0;
          // String

          case ModelAttribute.String:
            return '';
          // Boolean

          case ModelAttribute.Boolean:
            return false;
          ///////////
          // Dates //
          ///////////
          // Date or date time

          case ModelAttribute.DateTime:
          case ModelAttribute.Time:
          case ModelAttribute.Date:
            return moment();
          ///////////
          // Model //
          ///////////

          case ModelAttribute.Model:
          case ModelAttribute.Translations:
            return {};

          default:
            return null;
        }
      }
    }]);

    return ModelAttribute;
  }();

  ModelAttribute.Number = 'Number';
  ModelAttribute.Boolean = 'Boolean';
  ModelAttribute.Integer = 'Integer';
  ModelAttribute.String = 'String';
  ModelAttribute.Enum = 'Enum';
  ModelAttribute.Date = 'Date';
  ModelAttribute.DateTime = 'DateTime';
  ModelAttribute.Time = 'Time';
  ModelAttribute.Array = 'Array';
  ModelAttribute.Object = 'Object';
  ModelAttribute.Translations = 'Translations';
  ModelAttribute.Model = 'Model';

  /**
   * @module Data
   */

  var Pivot =
  /*#__PURE__*/
  function (_Model) {
    _inherits(Pivot, _Model);

    function Pivot() {
      _classCallCheck(this, Pivot);

      return _possibleConstructorReturn(this, _getPrototypeOf(Pivot).apply(this, arguments));
    }

    return Pivot;
  }(Model);

  ClassMap.register('Pivot', Pivot);

  Pivot.createFor = function (model, pivotAttributes) {
    // The pivot itself is a model too
    var pivot = new Pivot(pivotAttributes); // Make it

    var proxy = new Proxy(model, {
      get: function get(target, property
      /*, receiver*/
      ) {
        // Get pivot?
        if (property === 'getPivot') {
          return function () {
            return pivot;
          };
        }

        if (property === 'getModel') {
          return function () {
            return model;
          };
        }

        if (property === 'pivot') {
          return pivot;
        } // Is pivot.


        if (property === 'isPivot') {
          return function () {
            return true;
          };
        } // Is it a method?


        var value = target[property];

        if (typeof value === 'function') {
          // Wrap it
          return function () {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            // Is the first argument a key, starting with 'pivot.'?
            if (args.length > 0 && typeof args[0] === 'string' && args[0].match(/^pivot\./)) {
              // Pass on to the pivot model
              args[0] = args[0].replace(/^pivot\./, '');
              return pivot[property].apply(pivot, args);
            } else {
              // Pass on to the regular model
              return target[property].apply(target, args);
            }
          };
        } else {
          // Normal behaviour
          return value;
        }
      }
    });
    return proxy;
  };

  /**
   * @module Data
   */

  var PivotCollection =
  /*#__PURE__*/
  function (_Collection) {
    _inherits(PivotCollection, _Collection);

    function PivotCollection(modelClass, relationship) {
      var _this;

      _classCallCheck(this, PivotCollection);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(PivotCollection).call(this, modelClass)); // Localize

      _this.relationship = relationship;
      return _this;
    }

    _createClass(PivotCollection, [{
      key: "add",
      value: function add(model) {
        var pivotAttributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        // Already a pivot?
        if (!model.isPivot()) {
          // Proxy it
          model = Pivot.createFor(model, pivotAttributes);
        } // Add it.


        _get(_getPrototypeOf(PivotCollection.prototype), "add", this).call(this, model);

        return this;
      }
    }]);

    return PivotCollection;
  }(Collection);

  var Relationship =
  /*#__PURE__*/
  function () {
    function Relationship(name, localModel) {
      _classCallCheck(this, Relationship);

      this.name = name;
      this.type = null;
      this.localModel = localModel;
      this.localKey = null;
      this.remoteModel = null;
      this.remoteKey = null;
      this.morphModelKey = null;
      this.morphModelValuePrefix = null;
      this.pivotModel = null;
      this.pivotAttributes = [];
      this.inverseRelationshipName = null;
      this.touchLocalOnUpdate = false;
      this.sortCallback = false;
    } ////////////////////////
    // Relationship types //
    ////////////////////////


    _createClass(Relationship, [{
      key: "hasMany",
      value: function hasMany(remoteModel) {
        var localKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'id';
        var remoteKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        // Basics
        this.type = Relationship.HasMany;
        this.remoteModel = remoteModel;

        var cleanModel = underscore.last(this.localModel.split('.')); // Guess/store the keys


        if (!this.localKey) this.localKey = localKey;

        if (remoteKey || !this.remoteKey) {
          this.remoteKey = remoteKey || inflection.camelize(inflection.singularize(cleanModel), true) + 'Id';
        } // Guess the inverse relationship name


        this.inverseRelationshipName = inflection.camelize(inflection.singularize(cleanModel), true);
        return this;
      }
    }, {
      key: "belongsTo",
      value: function belongsTo(remoteModel) {
        var localKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var remoteKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'id';
        // Basics
        this.type = Relationship.BelongsTo;
        this.remoteModel = remoteModel; // Guess/store the keys

        if (localKey || !this.localKey) {
          this.localKey = localKey || inflection.camelize(inflection.singularize(this.name), true) + 'Id';
        }

        if (!this.remoteKey) this.remoteKey = remoteKey;
        return this;
      }
    }, {
      key: "hasOne",
      value: function hasOne(remoteModel) {
        var localKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'id';
        var remoteKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        // Basics
        this.type = Relationship.HasOne;
        this.remoteModel = remoteModel; // Guess/store the keys

        if (!this.localKey) this.localKey = localKey;

        if (remoteKey || !this.remoteKey) {
          this.remoteKey = remoteKey || inflection.camelize(inflection.singularize(this.localModel), true) + 'Id';
        }

        return this;
      } ///////////
      // Pivot //
      ///////////

    }, {
      key: "belongsToMany",
      value: function belongsToMany(remoteModel) {
        var localKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'id';
        var remoteKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'id';
        var pivotModel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        // Basics 
        this.type = Relationship.BelongsToMany;
        this.remoteModel = remoteModel;
        this.localKey = localKey;
        this.remoteKey = remoteKey; // Pivot model given?

        if (!pivotModel) {
          var models = [this.localModel, this.remoteModel];
          models.sort();
          pivotModel = models.join('');
        }

        this.pivotModel = pivotModel;
        return this;
      } /////////////////////////
      // Morph relationships //
      /////////////////////////

    }, {
      key: "belongsToMorph",
      value: function belongsToMorph(morphModelKey, localKey) {
        var remoteKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'id';
        var morphModelValuePrefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'App\\';
        // Basics
        this.type = Relationship.BelongsToMorph;
        this.remoteModel = null; // Guess/store the keys

        this.localKey = localKey;
        this.remoteKey = remoteKey;
        this.morphModelKey = morphModelKey;
        this.morphModelValuePrefix = morphModelValuePrefix;
        return this;
      }
    }, {
      key: "hasManyMorph",
      value: function hasManyMorph(remoteModel, morphModelKey) {
        var localKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var remoteKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'id';
        var morphModelValuePrefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'App\\';
        // Basics
        this.type = Relationship.HasManyMorph;
        this.remoteModel = remoteModel; // Guest/store the keys

        this.morphModelKey = morphModelKey;

        if (localKey || !this.localKey) {
          this.localKey = localKey || this.morphModelKey.replace(/Type$/, 'Id');
        }

        if (!this.remoteKey) this.remoteKey = remoteKey;
        this.morphModelValuePrefix = morphModelValuePrefix;
        return this;
      }
    }, {
      key: "getMorphModelValue",
      value: function getMorphModelValue(remoteModel) {
        // Check prefix
        var name = remoteModel.getModelName();

        if (this.morphModelValuePrefix) {
          name = "".concat(this.morphModelValuePrefix).concat(name);
        }

        return name;
      }
    }, {
      key: "usesCollection",
      value: function usesCollection() {
        return this.type == Relationship.BelongsToMany || this.type == Relationship.HasMany || this.type == Relationship.HasManyThrough || this.type == Relationship.HasManyMorph;
      } /////////////
      // Setters //
      /////////////

    }, {
      key: "setLocalKey",
      value: function setLocalKey(value) {
        this.localKey = value;
        return this;
      }
    }, {
      key: "setRemoteKey",
      value: function setRemoteKey(value) {
        this.remoteKey = value;
        return this;
      } /////////////
      // Methods //
      /////////////

      /**
       * set a flag to update the dirty attribute of local model
       * @return {Relationship} Chainable
       */

    }, {
      key: "touchLocal",
      value: function touchLocal() {
        var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this.touchLocalOnUpdate = value;
      }
      /**
       * Add local key as attribute to the modelDefinition to ensure 
       * that it is being serialized in the apiCall.
       * Attributes with `Id` will be cast as an integer,
       * Attributes with 'Key' will be cast as a string.
       * For other keys manually define them in the model.
       * 
       * @param {ModelDefinition} modelDefinition the definition to at the attribute to
       * @return {Relationship} chainable
       */

    }, {
      key: "addLocalKeyToModelDefinitionAttributes",
      value: function addLocalKeyToModelDefinitionAttributes(modelDefinition) {
        // Add morph type
        if (this.morphModelKey) {
          modelDefinition.string(this.morphModelKey);
        } // Skip if `id` or already exists


        if (this.localKey == 'id' || modelDefinition.hasAttribute(this.localKey)) return this; // Add key as string

        if (/Key$/.test(this.localKey)) {
          modelDefinition.string(this.localKey);
        } else {
          modelDefinition.integer(this.localKey);
        }

        return this;
      }
      /**
       * Add sorting method to the relationship. The given callback will be
       * called when the relationship Collection is instantiated from the API.
       * 
       * @param  {Function} callback 
       * @chainable
       */

    }, {
      key: "sorted",
      value: function sorted(callback) {
        this.sortCallback = callback;
        return this;
      }
    }, {
      key: "inverse",
      value: function inverse(relationshipName) {
        this.inverseRelationshipName = relationshipName;
        return this;
      }
    }, {
      key: "isStoredOnLocalModel",
      value: function isStoredOnLocalModel() {
        return this.type === Relationship.BelongsTo || this.type == Relationship.BelongsToMorph;
      }
    }, {
      key: "isStoredOnRemoteModel",
      value: function isStoredOnRemoteModel() {
        return this.type === Relationship.HasOne || this.type === Relationship.HasMany || this.type == Relationship.HasManyMorph;
      }
    }, {
      key: "getInitValue",
      value: function getInitValue() {
        // Depends on the type
        switch (this.type) {
          case Relationship.HasMany:
          case Relationship.HasManyThrough:
          case Relationship.HasManyMorph:
            return new Collection(Model.registry.get(this.remoteModel));

          case Relationship.BelongsToMany:
            return new PivotCollection(Model.registry.get(this.remoteModel), this);

          default:
            return null;
        }
      }
      /**
       * Add one or more attributes as pivot attributes
       * 
       * @method withPivot
       * @param  {...string} attributes  One or more attribute names
       * @chainable
       */

    }, {
      key: "withPivot",
      value: function withPivot() {
        for (var _len = arguments.length, attributes = new Array(_len), _key = 0; _key < _len; _key++) {
          attributes[_key] = arguments[_key];
        }

        this.pivotAttributes = underscore.union(this.pivotAttributes, attributes);
        return this;
      }
    }, {
      key: "isPivot",
      value: function isPivot() {
        return this.type === Relationship.BelongsToMany;
      }
    }]);

    return Relationship;
  }();

  Relationship.HasMany = 'HasMany';
  Relationship.HasOne = 'HasOne';
  Relationship.BelongsTo = 'BelongsTo';
  Relationship.HasManyThrough = 'HasManyThrough';
  Relationship.BelongsToMany = 'BelongsToMany';
  Relationship.BelongsToMorph = 'BelongsToMorph';
  Relationship.HasManyMorph = 'HasManyMorph';

  /**
   * @module Data
   */

  var ModelDefinition =
  /*#__PURE__*/
  function () {
    function ModelDefinition(name, callback) {
      var _this = this;

      _classCallCheck(this, ModelDefinition);

      this.name = name; // Guess api uri from model name

      var parts = name.split('.');
      this.apiUri = '/' + underscore.map(parts, function (part, index) {
        return inflection.underscore(index === parts.length - 1 ? inflection.pluralize(part) : part);
      }).join('/');
      this.api = 'default';
      this.attributes = {};
      this.attributeNames = [];
      this.relationships = {};
      this.relationshipsByLocalKey = null;
      this.apiAttributeNames = null;
      this.hiddenAttributeNames = null;
      this.computedAttributes = {};
      this.validationRules = {};
      this.isDynamic = false;
      this.searchFields = null;
      this.primaryKey = 'id';
      callback.apply(this, [this]);

      underscore.each(this.relationships, function (rel) {
        rel.addLocalKeyToModelDefinitionAttributes(_this);
      }); // Guess the default table name


      this.tableName = inflection.pluralize(underscore.underscored(this.name));
    }
    /**
     * Making a model dynamic means that not all attributes are defined,
     * and when submitting the model to an API, all set attributes will
     * be sent.
     * 
     * @method dynamic
     * @param  {Boolean} [isDynamic=true] 	
     * @chainable
     */


    _createClass(ModelDefinition, [{
      key: "dynamic",
      value: function dynamic() {
        var isDynamic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this.isDynamic = isDynamic;
        return this;
      }
    }, {
      key: "setPrimaryKey",
      value: function setPrimaryKey() {
        var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'id';
        this.primaryKey = key;
        return this;
      }
    }, {
      key: "getRelationshipsByLocalKey",
      value: function getRelationshipsByLocalKey() {
        var _this2 = this;

        // Initialized?
        if (!this.relationshipsByLocalKey) {
          // Loop through relationships
          this.relationshipsByLocalKey = {};

          underscore.each(this.relationships, function (relationship) {
            // Stored on local model?
            if (relationship.isStoredOnLocalModel()) {
              _this2.relationshipsByLocalKey[relationship.localKey] = relationship;
            }
          });
        }

        return this.relationshipsByLocalKey;
      }
    }, {
      key: "getRelationshipByLocalKey",
      value: function getRelationshipByLocalKey(localKey) {
        return this.getRelationshipsByLocalKey()[localKey];
      }
    }, {
      key: "getApiAttributeNames",
      value: function getApiAttributeNames() {
        var _this3 = this;

        // Initialized?
        if (!this.apiAttributeNames) {
          this.apiAttributeNames = underscore.filter(this.attributeNames, function (name) {
            return _this3.attributes[name].includeInRequests;
          });
        }

        return this.apiAttributeNames;
      }
    }, {
      key: "getHiddenAttributeNames",
      value: function getHiddenAttributeNames() {
        var _this4 = this;

        // Initialized?
        if (!this.hiddenAttributeNames) {
          this.hiddenAttributeNames = underscore.filter(this.attributeNames, function (name) {
            return !_this4.attributes[name].includeInRequests;
          });
        }

        return this.hiddenAttributeNames;
      }
    }, {
      key: "hasAttribute",
      value: function hasAttribute(key) {
        return this.attributes[key] !== undefined;
      }
    }, {
      key: "initializeModel",
      value: function initializeModel(model) {
        var _this5 = this;

        // Don't notify
        model.withoutNotifications(function () {
          // Default values
          underscore.each(_this5.attributes, function (attr) {
            if (attr.defaultValue && model.attributes[attr.name] === undefined) {
              model.set(attr.name, attr.defaultValue);
            }
          }); // Add computed


          underscore.each(_this5.computedAttributes, function (attr, key) {
            model.set(key, new ComputedProperty(attr.dependencies, attr.callback));
          });
        });
        return model;
      }
    }, {
      key: "attribute",
      value: function attribute(name, type) {
        var attr = new ModelAttribute(name, type);
        this.attributeNames.push(name);
        this.attributes[name] = attr;
        return attr;
      }
    }, {
      key: "computed",
      value: function computed(name, dependencies, callback) {
        this.computedAttributes[name] = {
          dependencies: dependencies,
          callback: callback
        };
        return true;
      } //////////////////////
      // Column defitions //
      //////////////////////

    }, {
      key: "integer",
      value: function integer(name) {
        var attr = this.attribute(name, ModelAttribute.Integer);
        return attr;
      }
    }, {
      key: "number",
      value: function number(name) {
        var attr = this.attribute(name, ModelAttribute.Number);
        return attr;
      }
    }, {
      key: "string",
      value: function string(name, size) {
        var attr = this.attribute(name, ModelAttribute.String);
        attr.size = size;
        return attr;
      }
    }, {
      key: "date",
      value: function date(name) {
        var attr = this.attribute(name, ModelAttribute.Date);
        return attr;
      }
    }, {
      key: "dateTime",
      value: function dateTime(name) {
        var attr = this.attribute(name, ModelAttribute.DateTime);
        return attr;
      }
    }, {
      key: "time",
      value: function time(name) {
        var attr = this.attribute(name, ModelAttribute.Time);
        return attr;
      }
    }, {
      key: "text",
      value: function text(name) {
        var attr = this.attribute(name, ModelAttribute.Text);
        return attr;
      }
    }, {
      key: "boolean",
      value: function boolean(name) {
        var attr = this.attribute(name, ModelAttribute.Boolean);
        return attr;
      }
    }, {
      key: "enum",
      value: function _enum(name, options) {
        var attr = this.attribute(name, ModelAttribute.Enum);
        attr.enumOptions = options;
        return attr;
      } ///////////
      // Model //
      ///////////

    }, {
      key: "model",
      value: function model(name) {
        var attr = this.attribute(name, ModelAttribute.Model);
        return attr;
      } //////////
      // JSON //
      //////////

    }, {
      key: "array",
      value: function array(name) {
        var attr = this.attribute(name, ModelAttribute.Array);
        return attr;
      }
    }, {
      key: "object",
      value: function object(name) {
        var attr = this.attribute(name, ModelAttribute.Object);
        return attr;
      }
    }, {
      key: "translations",
      value: function translations(name) {
        var attr = this.attribute(name, ModelAttribute.Object);
        return attr;
      } //////////////////////
      // Column shortcuts //
      //////////////////////

    }, {
      key: "timestamps",
      value: function timestamps() {
        this.dateTime('createdAt').hidden();
        this.dateTime('updatedAt').hidden();
        return this;
      } ///////////////////
      // Relationships //
      ///////////////////

    }, {
      key: "relationship",
      value: function relationship(name) {
        var rel = new Relationship(name, this.name);
        this.relationships[name] = rel;
        return rel;
      } /////////////////////
      // Form validation //
      /////////////////////

    }, {
      key: "validation",
      value: function validation(rules) {
        var formKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
        this.validationRules[formKey] = rules;
        return this;
      } ///////////////
      // Searching //
      ///////////////

    }, {
      key: "searchable",
      value: function searchable() {
        for (var _len = arguments.length, fields = new Array(_len), _key = 0; _key < _len; _key++) {
          fields[_key] = arguments[_key];
        }

        // Stroe
        this.searchFields = fields;
      }
    }, {
      key: "getSearchFields",
      value: function getSearchFields() {
        return this.searchFields;
      } /////////
      // Api //
      /////////

    }, {
      key: "getApiUri",
      value: function getApiUri() {
        var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var uri = this.apiUri;
        if (id) uri += '/' + id;
        return uri;
      }
    }]);

    return ModelDefinition;
  }();

  var FakeHistory =
  /*#__PURE__*/
  function () {
    function FakeHistory() {
      var location = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      _classCallCheck(this, FakeHistory);

      this.location = location || {
        action: 'POP',
        hash: '',
        key: 'abc',
        pathname: '/',
        search: ''
      };
    }

    _createClass(FakeHistory, [{
      key: "listen",
      value: function listen()
      /*callback*/
      {}
    }, {
      key: "getCurrentLocation",
      value: function getCurrentLocation() {
        return this.location;
      }
    }]);

    return FakeHistory;
  }();

  var _this = window;
  // Make sure dependencies are loaded //
  ///////////////////////////////////////

  if (jquery === undefined || typeof jquery !== 'function') throw new Error('Error while initializing Chicken: could not find global jQuery ($). Was jQuery not loaded?');
  if (underscore === undefined || typeof underscore !== 'function') throw new Error('Error while initializing Chicken: could not find global Underscore (_). Was Underscore not loaded?');
  if (xregexpAll === undefined || typeof xregexpAll !== 'function') throw new Error('Error while initializing Chicken: could not find global XRegExp. Was XRegExp not loaded?');
  if (underscore_string === undefined || typeof underscore_string !== 'function') throw new Error('Error while initializing Chicken: could not find global Underscore.string (s). Was Underscore.string not loaded?');

  underscore.mixin(underscore_string.exports()); /////////////////////
  // Chicken Package exports //
  /////////////////////////////

  var Chicken = {
    ////////////////
    // Class tree //
    ////////////////
    Api: {
      Api: Api,
      ApiCall: ApiCall,
      ApiError: ApiError,
      JsonApi: JsonApi,
      JsonApiCall: JsonApiCall,
      PrimitiveJsonApi: PrimitiveJsonApi,
      PrimitiveJsonApiCall: PrimitiveJsonApiCall
    },
    Application: Application,
    Auth: {
      Auth: Auth,
      JWTAuth: JWTAuth
    },
    Core: {
      ComputedProperty: ComputedProperty,
      Obj: Obj,
      Observable: Observable,
      ObservableArray: ObservableArray,
      Reference: Reference,
      SettingsObject: SettingsObject$1
    },
    Data: {
      Collection: Collection,
      Model: Model,
      ModelAttribute: ModelAttribute,
      ModelDefinition: ModelDefinition,
      ModelStore: ModelStore,
      Pivot: Pivot,
      Relationship: Relationship,
      Service: Service
    },
    Dom: {
      ActionBinding: ActionBinding,
      Binding: Binding,
      Component: Component,
      ComponentDefinition: ComponentDefinition,
      Element: Element,
      Helpers: Helpers,
      Renderer: Renderer,
      Transition: Transition,
      View: View,
      ViewContainer: ViewContainer
    },
    Helpers: {
      App: App,
      Chainable: Chainable,
      ClassMap: ClassMap,
      Utils: Utils
    },
    Localization: {
      I18n: I18n
    },
    Routing: {
      Action: Action,
      Controller: Controller,
      FakeHistory: FakeHistory,
      Middleware: Middleware,
      Redirect: Redirect,
      Request: Request,
      Route: Route,
      RouteMatch: RouteMatch,
      Router: Router,
      RoutingError: RoutingError
    },
    inflection: inflection,
    /////////////////
    // Application //
    /////////////////
    application: function application() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Arguments given?
      if (args.length > 0) {
        // Create app
        var app = _construct(Application, args); // Store globally


        Chicken.app = app; // Return

        return app;
      } else {
        return Application.getInstance();
      }
    },
    api: function api() {
      var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
      return Application.getInstance().apis[key];
    },
    ////////////////////////
    // Easy instantiators //
    ////////////////////////
    controller: function controller(name, actions) {
      // Create class
      var ChickenController =
      /*#__PURE__*/
      function (_Controller) {
        _inherits(ChickenController, _Controller);

        function ChickenController(action) {
          _classCallCheck(this, ChickenController);

          return _possibleConstructorReturn(this, _getPrototypeOf(ChickenController).call(this, action));
        }

        return ChickenController;
      }(Controller);

      jquery.extend(ChickenController.prototype, actions); // Store it

      Controller.registry.set(name, ChickenController);
      return ChickenController;
    },
    component: function component(name, source, initCallback) {
      var methods = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var renderer = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var overwrite = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
      // Create definition
      var def = new ComponentDefinition(name, source, initCallback, methods, renderer); // Register it.

      if (Component.registry.has(name) && !overwrite) throw new Error('A component with the name ' + name + ' was already defined. If you want to overwrite this, use the "overwrite" parameter.');
      Component.registry.set(name, def);
      return def;
    },
    helper: function helper(name, callback) {
      var overwrite = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      // Already there?
      if (Chicken.Dom.Helpers.User[name] !== undefined && overwrite !== true) {
        throw new Error('A helper with the name ' + name + ' was already defined. If you want to overwrite this, use the "overwrite" parameter.');
      } // Register


      Chicken.Dom.Helpers.User[name] = callback;
      return Chicken.Dom.Helpers.User;
    },
    model: function model(name) {
      var configCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var methods = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      // Getter?
      if (configCallback === null) {
        // Get from registry
        return Model.registry.get(name);
      } // Create class


      var ChickenModel =
      /*#__PURE__*/
      function (_Model) {
        _inherits(ChickenModel, _Model);

        function ChickenModel() {
          var initValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          var convertToObservables = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          _classCallCheck(this, ChickenModel);

          return _possibleConstructorReturn(this, _getPrototypeOf(ChickenModel).call(this, initValues, convertToObservables));
        }

        return ChickenModel;
      }(Model); // Add given methods to prototype


      if (methods) {
        jquery.extend(ChickenModel.prototype, methods);
      } // Configure it.


      ChickenModel.definition = new ModelDefinition(name, configCallback);
      ChickenModel.modelName = name;

      ChickenModel.create = function () {
        var initValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var convertToObservables = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return new ChickenModel(initValues, convertToObservables);
      }; // Store it.


      Model.registry.set(name, ChickenModel);
      return ChickenModel;
    },
    extendModel: function extendModel(name, configCallback) {
      var methods = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      // Get the class
      var ChickenModel = Model.registry.get(name);
      if (!ChickenModel) throw new Error('Cannot extend unknown model ' + name); // Add given methods to prototype

      if (methods) {
        jquery.extend(ChickenModel.prototype, methods);
      } // Apply config callback


      configCallback.apply(ChickenModel.definition, [ChickenModel.definition]);
      return ChickenModel;
    },
    service: function service(name) {
      var methods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      // Getter?
      if (methods === null) {
        return Service.get(name);
      } // Create class


      var ChickenService =
      /*#__PURE__*/
      function (_Service) {
        _inherits(ChickenService, _Service);

        function ChickenService() {
          _classCallCheck(this, ChickenService);

          return _possibleConstructorReturn(this, _getPrototypeOf(ChickenService).call(this, name));
        }

        return ChickenService;
      }(Service); // Add given methods to prototype


      jquery.extend(ChickenService.prototype, methods); // Configure it.

      ChickenService.serviceName = name; // Store it.

      Service.registry.set(name, ChickenService);
      return ChickenService;
    },
    middleware: function middleware(name) {
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      // Getter?
      if (callback === null) {
        return Middleware.registry.get(name);
      } // Make it a middleware instance


      var middleware = new Middleware(name, callback); // Store it

      Middleware.registry.set(name, middleware);
      return middleware;
    },
    redirect: function redirect(uri) {
      return new Redirect(uri);
    },
    redirectNamed: function redirectNamed(name) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // Relative route?
      var app = Application.getInstance();

      if (/^\./.test(name)) {
        // Current name?
        var curName = app && app.currentRoute ? app.currentRoute.route.name : false;
        if (!curName) throw new Error('The current route does not have a name, so relative links are not possible from here'); // ..? (Level up)

        if (/^\.\./.test(name)) {
          // Remove last part
          var parts = curName.split(/\./);
          parts.pop();
          curName = parts.join('.');
          name = name.replace(/^\./, '');
        } // Add it.


        name = curName + name; // Remove any trailing dots

        name = name.replace(/\.+$/, '');
      } // Find route


      var route = app.router.namedRoutes.get(name);
      if (!route) throw new Error('There is no route with the name "' + name + '"'); // Make uri

      var uri = route.makeUrl(attributes);
      return new Redirect(uri);
    },
    computed: function computed(dependencies, callback) {
      return new ComputedProperty(dependencies, callback);
    },
    observable: function observable() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return new Observable(data);
    },
    view: function view() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return _construct(View, args);
    },
    /////////////
    // Helpers //
    /////////////
    each: function each() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return Utils.each.apply(_this, args);
    },
    map: function map() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return Utils.map.apply(_this, args);
    },
    debug: function debug(message) {
      var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      switch (Chicken.debugging) {
        case 'console':
          console.log((key ? '[' + key + '] ' : '') + message);
          break;
      }
    },
    getValue: function getValue(obj) {
      return Utils.getValue(obj);
    },
    translate: function translate(key) {
      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return Application.getInstance().i18n.translate(key, attributes);
    },
    queryString: queryString,
    debugging: 'console',
    /////////////
    // Filters //
    /////////////
    isNullFilter: '@Q' + JSON.stringify({
      'operator': 'IS NULL'
    }),
    isNotNullFilter: '@Q' + JSON.stringify({
      'operator': 'IS NOT NULL'
    }),
    makeFilter: function makeFilter(operator, value) {
      var addWildcards = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      if (addWildcards === null) addWildcards = operator === 'LIKE';
      if (addWildcards) value = '%' + value + '%';
      return '@Q' + JSON.stringify({
        value: value,
        operator: operator
      });
    },
    multiFilter: function multiFilter() {
      for (var _len5 = arguments.length, filters = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        filters[_key5] = arguments[_key5];
      }

      // Collect strings
      var objects = underscore.map(filters, function (f) {
        return JSON.parse(f.replace(/^@Q/, ''));
      }); // Put 'em together


      return '@Q' + JSON.stringify(objects);
    }
  };
  window.Chicken = Chicken;

  return Chicken;

})));
//# sourceMappingURL=chicken.js.map
